{"/docs/core-elements":{"title":"Core Elements","data":{"":"Interactive and User-Friendly Interface\nThe user-friendly agentic interface that allows users to communicate and view the execution process of the Studio autonomous agent in the form of a workflow.\nWorkflow\nThe execution path designed by the Studio autonomous agent to achieve the user's desired goals, broken down into actionable units.\nWorkflow Canvas\nA drag-and-drop low-code editor that visualizes the design and action-level execution paths created by the Studio autonomous agent. Connector node blocks are displayed and can be edited by the user as needed.\nMarketplace\nA store where users can share or sell completed workflows, bot agents, connectors, and APIs. It aims to create an ecosystem that allows users to benefit from the collective expertise of the community.\nConnector\nThe external service and data connections, programming syntax, and expressions needed for the Studio autonomous agent to execute actions based on user context. Connectors are represented by Swagger documentation and visualized as node blocks on the Workflow Canvas. They are essential for connecting external services and data to execute user requests. In addition to core connectors, acquiring connectors for services frequently used in the local market is necessary for the Studio autonomous agent to understand and execute various user requests via natural language.\nHuman-in-the-loop\nA feature that enhances trust and control over outputs by allowing users to make immediate modifications, adjustments, and approvals within desired parameters under the supervision of the Studio autonomous agent."}},"/docs/getting-started/language-settings":{"title":"Language settings","data":{"step-1-go-to-settings#Step 1. Go to Settings":"Hover over the left navigation bar and access the settings page.","step-2-select-language#Step 2. Select Language":"Click on the second item ‘Change Language / 언어 변경’ and select your preferred language from the dropdown menu. (Currently, Korean and English are supported.)"}},"/docs/getting-started/register-and-login":{"title":"Register and Login","data":{"step-1-access#Step 1. Access":"Search for ‘WRTN Studio Pro’ on Google and access the login page, or visit the following link. (https://studio-pro.wrtn.ai)","step-2-go-to-login-page#Step 2. Go to Login Page":"Click the login button.","step-3-choose-login-method#Step 3. Choose Login Method":"Select the service you want to use to sign up and log in to the product. If this is your first time using the service, you will be registered as a new user. If you have already signed up, you will be logged in and redirected to the home screen.","step-4-select-login-id#Step 4. Select Login ID":"Log in and select the ID you want to use for the service.","step-5-agree-to-terms#Step 5. Agree to Terms":"Check the terms of the service box and click the Complete Registration button.","step-6-move-to-studio-pro#Step 6. Move to Studio Pro":"Click the Start button.","step-7-enter-account-information#Step 7. Enter Account Information":"Please enter the necessary information to use the studio.","step-8-connect-external-services#Step 8. Connect External Services":"Connect your frequently used account to integrate external services. You can also connect or disconnect it later in tasks and settings.","step-9-select-template#Step 9. Select Template":"Choose your preferred template, or go directly to the home screen to make a request.","step-10-home-screen#Step 10. Home Screen":"Welcome to the home screen! Select your task or make a request directly through input!"}},"/docs":{"title":"Overview","data":{"":"Studio Pro is a creation tool that enhances productivity by allowing users to easily build their own AI workflow apps and agents using an AI agent-based low-code builder tool. Studio Pro provides an optimal AI user experience designed to automatically perform tasks as desired by the user. Within the studio, there is an AI agent that assists throughout the entire user journey. This agent is the autonomous agent that receives user requests via natural language or voice, formulates an execution plan, and uses the provided connectors to integrate with external services and data, creating action-node-block-based workflows. After user confirmation, it can directly perform tasks.Users can view the workflow, which represents the execution process established by the meta agent, on a low-code canvas and, if necessary, edit it to further optimize the work process or outcomes. Through these workflows, users can execute batch operations for repetitive tasks or set execution cycles. For workflows that need to be executed periodically, the results can be set as widgets on the home dashboard and updated in a feed format. Users can create multiple widget dashboards, categorized as needed.For power users, there is an option to extract their own workflow apps and APIs and share them on the marketplace, contributing to community engagement. This series of features is suitable not only for general users but also for integration with various tools and platforms needed to enhance productivity in complex B2B environments."}},"/docs/use-cases/github":{"title":"Example 5  GitHub Project Review & Contributions","data":{"":"Review the GitHub repository, identify areas for improvement or additional features, and suggest ways to contribute to the project.","step-1-authentication#Step 1. Authentication":"Register or log in on the product page. (https://studio-pro.wrtn.ai)","step-2-request#Step 2. Request":"In the prompt field, type a request to review a specific GitHub repository and suggest potential ideas for contributing to the project.","step-3-selection#Step 3. Selection":"Please select a specific project from the suggested ones and provide guidance on what to consider during the selection.","step-4-initiation#Step 4. Initiation":"In the prompt field, type a request to initiate a new development phase by branching off, documenting progress incrementally, and submitting the work for peer review. Include guidance on involving specific team members for feedback and mention any preliminary research or tools that may be required.","step-5-commit#Step 5. Commit":"Complete the implementation and commit the final changes to the branch.","step-6-pull-request#Step 6. Pull Request":"Create a pull request for the completed work and submit it.","step-7-link#Step 7. Link":"Complete all the steps and provide a link to the pull request.","step-8-progress#Step 8. Progress":"Review the progress of the project through the provided link."}},"/docs/use-cases/invite-1on1":{"title":"Example 1  Scheduling 1-on-1 Meetings","data":{"":"Find a mutually available time with another person, add the event to Google Calendar, and notify via Slack. Then, create a workflow for this process to make it reusable.","step-1-authentication#Step 1. Authentication":"Register or log in on the product page. (https://studio-pro.wrtn.ai)","step-2-request#Step 2. Request":"In the prompt field, type a request to schedule a meeting with a specific person (include their email), specify the timeframe for the meeting (e.g., next week between certain days), and ask to add it to Google Calendar.","step-3-account-connection#Step 3. Account Connection":"If a prompt appears asking you to connect your account to a specific service to perform the requested actions (e.g., viewing and creating events), simply click the dropdown menu and select the connected account. (If the service connector has not been connected before, an account authentication process will be required.)","step-4-verification#Step 4. Verification":"Check the intermediate results as the AI agent performs actions based on your request, then provide approval or additional comments to proceed.","step-5-workflow-setup#Step 5. Workflow Setup":"If all the requested actions have been completed, ask to create an automated workflow for the task.","step-6-canvas-access#Step 6. Canvas Access":"If the AI agent creates a workflow, click the ‘Go to Workflow’ button to navigate to the Workflow Canvas.","step-7-customization#Step 7. Customization":"Click on the nodes of the created workflow to modify their detailed properties in Inspector. (For example, delete the email address entered in the previous conversation and input the email address of the new person to invite.)","step-8-configuration#Step 8. Configuration":"In the service connector, click the authentication information dropdown menu to connect your account. Then, fill in the empty fields with the appropriate values.","step-9-execution#Step 9. Execution":"Once all the fields are filled in, click Run to execute, and check the results in the execution history."}},"/docs/use-cases/google-docs":{"title":"Example 3  Investment Report Generation","data":{"":"Find detailed information about the company for investment purposes and generate a report.","step-1-authentication#Step 1. Authentication":"Register or log in on the product page. (https://studio-pro.wrtn.ai)","step-2-request#Step 2. Request":"In the prompt field, type a request to gather comprehensive investment details and ask for a detailed corporate research report to be written and organized into a document.","step-3-info-input#Step 3. Info Input":"Please provide the additional information required by the requested service to create the document.","step-4-verification#Step 4. Verification":"Check that the document has been fully completed as requested."}},"/docs/use-cases/marketing":{"title":"Example 2  Generating Marketing Image & Text","data":{"":"Create a workflow that repeatedly generates marketing copy and image materials based on the information you input. Build a widget from this workflow to view the automated results on the dashboard.","step-1-authentication#Step 1. Authentication":"Register or log in on the product page. (https://studio-pro.wrtn.ai)","step-2-request#Step 2. Request":"In the prompt field, type a request to generate marketing copy and images for your product.","step-3-info-input#Step 3. Info Input":"Please provide the detailed information requested by the agent to perform the task.","step-4-canvas-access#Step 4. Canvas Access":"When the agent creates the workflow, click the “Go to Workflow” button to navigate to the Workflow Canvas.","step-5-customization#Step 5. Customization":"Click on the node and enter the values you want to change or add from the pre-filled template.","step-6-execution#Step 6. Execution":"Click the Run button in the upper-right corner and check the generated results in the Execution History tab.","step-7-update#Step 7. Update":"To reuse the workflow and change the generated content, click the existing node and update the entered values to the desired content.","step-8-export#Step 8. Export":"Check the newly generated results in the Execution History tab, and click Export to register this workflow as a widget.","step-9-format-selection#Step 9. Format Selection":"Please select the export format you want.","step-10-naming#Step 10. Naming":"Enter the name and description of the content to be exported, then click the Next button in the upper-right corner.","step-11-preview#Step 11. Preview":"Check the preview of the content to be exported, then click the Next button in the upper-right corner.","step-12-set-up#Step 12. Set Up":"Please set the conditions for automatically running the workflow repeatedly.","step-13-dashboard#Step 13. Dashboard":"You can check the generated widget when you enter the dashboard."}},"/docs/use-cases/picture-books":{"title":"Example 6  Storytelling Agent for Picture books in Google Slides.","data":{"step-1-authentication#Step 1. Authentication":"Register or log in on the product page. (https://studio-pro.wrtn.ai)","step-2-request#Step 2. Request":"In the prompt field, type a request to create an AI agent capable of generating a personalized story and picture book.","step-3-connection#Step 3. Connection":"You will be prompted to connect to your Google Slides account. Select your account and log in.","step-4-workflow#Step 4. Workflow":"The Studio autonomous agent will then create a workflow to develop the storyteller bot and generate a unique picture book. Click the “View Workflow” button on the workflow card to see the details.","step-5-customization#Step 5. Customization":"View the workflow in the Canvas. Please fill in the guidance for the story agent’s responses in the right inspector panel.","step-6-execution#Step 6. Execution":"Click the “Run Chatbot” button in the top right corner.","step-7-generation#Step 7. Generation":"The storybook author bot will be launched. You can provide instructions on the theme or characters for the story. Then, it will generate a personalized picture book based on your request. (Currently, story creation is only supported in Korean.)","step-8-connection#Step 8. Connection":"Please connect the required account information to generate the completed story in Google Slides."}},"/docs/use-cases/tweet":{"title":"Example 4  Tweet Fetching & Summary","data":{"":"Gather and summarize tweets from influencers in specific fields like economics or politics, then compile them into a document or share them.","step-1-authentication#Step 1. Authentication":"Register or log in on the product page. (https://studio-pro.wrtn.ai)","step-2-request#Step 2. Request":"In the prompt field, type a request to summarize the tweets of people whose tweets you want to gather all at once. Please provide the required account information at this time.","step-3-review#Step 3. Review":"Check the quantity and content of the information found by the agent and provide additional instructions as needed.","step-4-save#Step 4. Save":"Please input how to save or send the information to use it, and provide any additional information needed for this purpose.","step-5-workflow#Step 5. Workflow":"Request to create a workflow for detailed editing and repetitive use of this task.","step-6-execution#Step 6. Execution":"Run the workflow to check the results.","step-7-format-selection#Step 7. Format Selection":"Please select the export format you want.","step-8-naming#Step 8. Naming":"Enter the name and description of the content to be exported, then click the Next button in the upper-right corner.","step-9-preview#Step 9. Preview":"Check the preview of the content to be exported, then click the Next button in the upper-right corner.","step-10-set-up#Step 10. Set Up":"Please set the conditions for automatically running the workflow repeatedly.","step-11-dashboard#Step 11. Dashboard":"You can check the generated widget when you enter the dashboard."}},"/tech-specs":{"title":"Index","data":{"":"\"Wrtn Studio Pro\" is a service providing an evolved Meta LLM (A.I. chatbot) than ever.\"Wrtn Studio Pro\" provides a Meta LLM (A.I. Chatbot) which can perform various function callings obtained from API marketplace sales of OpenAPI specification. \"Wrtn Studio Pro\" also provides an Workflow Compiler (+SWL language) which automates the Meta LLM scenario to an re-usable and executable program function with visual diagrams.In here technical document, you can learn how the \"Wrtn Studio Pro\" has developed the Meta LLM (A.I. chatbot) and how it obtains the function calling schemas from the API marketplace. Also, you can learn how the user utternance and LLM function call histories are reborn as reusable programs through the workflow compiler.Let's see the \"Wrtn Studio Pro\" in the technical apsects.\nOpenAPI Specification\nMeta LLM (A.I. Chatbot)\nWorkflow Engine\nSWL Language\nAPI Marketplace"}},"/tech-specs/marketplace/application":{"title":"Application","data":{"new-era-of-ai-chatbot#New Era of A.I. Chatbot":"The days of creating full page applications that took a long time and effort are over. It's the age of A.I. Chatbot. When user inputs a conversation to an A.I. Chatbot, A.I. Chatbot will do everything.And if you come to our \"Wrtn Studio Pro\", you can create that A.I. Chatbot with just a few mouse clicks. Visit our API Marketplace, select the features you want, and click the \"Launch my A.I. App\" button. An A.I. Chatbot Application that can be ported immediately will be created.Through \"Application Creator\" of \"Wrtn Studio Pro\", you can turn your business into a product and launch it faster than anyone else. We will make your bright idea come true right now.","application-creator#Application Creator":"\"Application Creator\" is a service providing Meta LLM (A.I. Chatbot) as an embeddable application.When a customer purchases some OpenAPI goods from the \"API marketplace\" and publish them as a \"Application Creator\", the purchased OpenAPI operations would be utilized by the A.I. Chatbot's LLM (Large Language Model) function calling. It is the way to make a custom A.I. Chatbot with isolated sandbox environment.Also, the \"Application Creator\" is an embeddable application that can be ported to the user's website or application. Therefore, the \"Application Creator\" is the superfast way to make a custom A.I. Chatbot. Considering the fact that the A.I. Chatbot is the most popular and useful application in the current era, the \"Application Creator\" is the most valuable service in the \"Wrtn Studio Pro\" saving costs and times for business development.","pricing-model#Pricing Model":"When configuring the \"Application Creator\" and building up a \"custom A.I. Chatbot\", if there are some OpenAPI goods that is not free but commercial, the customer who've created the A.I. Chatbot must pay every fees occured in the \"custom A.I. Chatbot\" by the API calls.Considering aspects of the marketplace schema and pricing model of the \"API marketplace\", the fee structure will be determined based on the stock and price band selected by the customer when making the final purchase, and actual charges will be made based on the number of API calls made by LLM (Large Language Model) function calling in the A.I. chatbot.For reference, the custom A.I. chatbot applications created by \"Application Creator\" can be resold without licensing restrictions, so if the cost of purchased OpenAPI products is burdensome for you, consider a way to pass this on to end customers.\nNo\tFixed Cost\tVariable cost\t1\t$500 for 100 calls\t$10 per a call for the rest\t2\t$1,000 for 250 calls\t$5 per a call for the rest\t3\t$1,500 for 600 calls\t$2 per a call for the rest\t4\t$2,000 for 900 calls\t$1 per a call for the rest"}},"/tech-specs/marketplace/preface":{"title":"Preface","data":{"openapi-marketplace#OpenAPI Marketplace":"Marketplace of OpenAPI documents for Meta LLM.\"Wrtn Studio Pro\" operates an \"OpenAPI Marketplace\" to provide OpenAPI documents for the \"Meta LLM (A.I. Chatbot)\" from the market. Participants of the \"OpenAPI Marketplace\" can trade the OpenAPI document, so that customers can obtain functions to call by LLM (Large Language Model). And the providers can earn money by selling the OpenAPI documents.For reference, when seller uploads an OpenAPI document, \"Wrtn Studio Pro\" converts it to the OpenAPI v3.1 (emended) format. It is to unify the OpenAPI document to the latest version, and make the specification more concise by emendation. The emended OpenAPI v3.1 document would be utilized for LLM function calling bypass the migration process.","marketplace-schema#Marketplace Schema":"Descrition of the marketplace schema.Here is the summary of some entities written in the marketplace schema chapter.The schema of marketplace sale has defined SKU (Stock Keepting Unit) structured OpenAPI produces. It starts from the hub_sales (or hub_sale_snapshots) entity, and its final goal is to reaching to the target stock by configuring each candidate value for each option of each unit. After reaching to the target stock record, the customer may purchase the product with price model specification.When customer wants to buy a sale from the marketplace, he or she may specify the stocks from the sale and put them into the cart as a commodity. After that, customer can proceed the order from the prepared cart. When the cart is submitted as an order, its children commodities are changed to goods. When customer wants to complete the order as a formal contract, the order be published.","pricing-model#Pricing Model":"Step pricing model with fixed/variable const combinations.\"Wrtn Studio Pro\" has adopted step pricing model for the marketplace with fixed/variable cost combinations.It means that there are many fixed and variable combinated costs into a product (especially into a stock). For example, let's imagine that there is a stock that has 4 steps of pricing model as below. As you can see, if you pay $500 fixed cost, you can call 100 times of the API without any additional cost. However, if the number of API calls overs the 100, you should pay $10 per a call for the rest.Such stepping but fixed/variable separated pricing model is what \"Wrtn Stdio Pro\" has adopted. Also, the fixed and variable costs are inversely proportional. If a customer selects a higher fixed cost, the variable cost will be lower. Otherwise a customer selects a lower fixed cost, the variable cost would be higher. Of course, the quantity that can be used without additional charges is proportional to the fixed cost.\nNo\tFixed Cost\tVariable cost\t1\t$500 for 100 calls\t$10 per a call for the rest\t2\t$1,000 for 250 calls\t$5 per a call for the rest\t3\t$1,500 for 600 calls\t$2 per a call for the rest\t4\t$2,000 for 900 calls\t$1 per a call for the rest","application-creator#Application Creator":"Make A.I. Chatbot superfast from the API marketplace.\"Wrtn Studio Pro\" provides an Application Creator, which can make a custom A.I. Chatbot performing the LLM function calling that is obtained by the API Marketplace. The A.I. Chatbot can be embedded to the user's website or application, so that it is the superfast way to make an A.I. Chatbot.This is the agenda of the \"Application Creator\":\nThe days of creating full page applications that took a long time and effort are over. It's the age of A.I. Chatbot. When user inputs a conversation to an A.I. Chatbot, A.I. Chatbot will do everything.And if you come to our \"Wrtn Studio Pro\", you can create that A.I. Chatbot with just a few mouse clicks. Visit our API Marketplace, select the features you want, and click the \"Launch my A.I. App\" button. An A.I. Chatbot Application that can be ported immediately will be created.Through \"Application Creator\" of \"Wrtn Studio Pro\", you can turn your business into a product and launch it faster than anyone else. We will make your bright idea come true right now.","example-projects#Example Projects":"\"Wrtn Studio Pro\" provides some example OpenAPI projects/products.The connector is an example project made by \"Wrtn Studio Pro\" team. It is a representative and default OpenAPI product in the marketplace. If a new customer has not purchased anything in the API marketplace, only the connector belonged API functions would be utilized in the \"Meta LLM (A.I. Chatbot)\".Also, the connector is a good example to learn how to make a well-structured OpenAPI based project disclosured in the Github repository with open source license. The connector has been  developed with NestJS framework, and its Restful API functions are always 100% synchronized with the OpenAPI document without any type error.\nGithub Repository: https://github.com/wrtnio/connectors\nSwagger UI: https://wrtnio.github.io/connectors/swagger/"}},"/tech-specs/marketplace/price":{"title":"Price","data":{"step-pricing-model#Step Pricing Model":"Step pricing model with fixed/variable const combinations.\"Wrtn Studio Pro\" has adopted step pricing model for the marketplace with fixed/variable cost combinations.It means that there are many fixed and variable combinated costs into a product (especially into a stock). For example, let's imagine that there is a stock that has 4 steps of pricing model as below. As you can see, if you pay $500 fixed cost, you can call 100 times of the API without any additional cost. However, if the number of API calls overs the 100, you should pay $10 per a call for the rest.Such stepping but fixed/variable separated pricing model is what \"Wrtn Stdio Pro\" has adopted. Also, the fixed and variable costs are inversely proportional. If a customer selects a higher fixed cost, the variable cost will be lower. Otherwise a customer selects a lower fixed cost, the variable cost would be higher. Of course, the quantity that can be used without additional charges is proportional to the fixed cost.\nNo\tFixed Cost\tVariable cost\t1\t$500 for 100 calls\t$10 per a call for the rest\t2\t$1,000 for 250 calls\t$5 per a call for the rest\t3\t$1,500 for 600 calls\t$2 per a call for the rest\t4\t$2,000 for 900 calls\t$1 per a call for the rest","price-on-the-stock#Price on the Stock":"The stepping pricing model is defined in the stock level.Do you remember? \"API Marketplace\" supports the SKU (Stock Keeping Unit) concept, so that the final good to purchase by the customer is the stock. Here is the concept of the stock in the \"API Marketplace\". If you have not read the previous Marketplace Schema chapter or have forgotten it, read the below summarized paragraph.\nAs you can see, the schema of the marketplace starts from the Marketplace Schema > Sales section. In the Marketplace Schema > Sales section, it has defined SKU (Stock Keeping Unit) structured OpenAPI products. It starts from the hub_sales (or hub_sale_snapshots) entity, and its final goal is to reaching to the target stock by configuring each candidate value for each option of each unit. After reaching to the target stock record, the customer may purchase the product with price model specification.\nAlso, the stepping pricing model is defined in the stock level. It means that a sale unit can have multiple stepping pricing models per each stock. Each stock can have different pricing models, even though they are in the same sale unit with the same OpenAPI document.The represenative example case of multiple stocks in a sale unit (in a same OpenAPI document) is the different device environments. Let's imagine that there is a sale unit that has (CPU, GPU, RAM) options like below. Every customeres who has purchased the sale unit may have the same API specification, but the price of the API call must be different according to the device environments.High-end stock buyers pay more, that's the pricing model of the \"API Marketplace\".\nCPU: (i5, i7, i9)\nGPU: (GTX 2050, GTX 3060, GTX 4070)\nRAM: (8GB, 16GB, 32GB)","predication#Predication":"Only 2xx status codes are valid and will be payed.When a seller uploads an OpenAPI product, and customer buys it and calls the API, the marketplace proxy server intermediates the request and response between the client and the server. In the intermediation process, the proxy server checks the status code of the response.If the status code is not 2xx, the proxy server will not count the API call and will not charge from the customer. Only the 2xx status code responses are valid and will be payed. By the way, do not abuse the 2xx status code. If a seller abuses the 2xx status code even when the actual error case, the seller will be punished by the marketplace."}},"/tech-specs/marketplace/schema":{"title":"Schema","data":{"summary#Summary":"In here chapter, we will learn about the schema of the marketplace.As you can see, the schema of the marketplace starts from the Sales section. In the Sales section, it has defined SKU (Stock Keeping Unit) structured OpenAPI products. It starts from the hub_sales (or hub_sale_snapshots) entity, and its final goal is to reaching to the target stock by configuring each candidate value for each option of each unit. After reaching to the target stock record, the customer may purchase the product with price model specification.In the next Audit section, we will learn about the audit process of the sale. Whenever seller newly creates a sale or updates ordinary one, administrator may write an audit article issuing the audit process. In the audit process, both administrator and seller can emend the sale content, and administrator may determine to approve or reject the sale. When adminnistrator approves it, the sale would be started and the customer may purchase it. Also, even though administrator has rejected it, seller can request re-audit by comment, so that it can be reversely approved in sometimes.When customer wants to buy a sale from the marketplace, he or she may specify the stocks from the sale and put them into the cart as a commodity. After that, customer can proceed the order from the prepared cart. When the cart is submitted as an order, its children commodities are changed to goods. When customer wants to complete the order as a formal contract, the order be published.By the way, if administrator or seller hopes to take a discount event, how should do? In this case, Coupon is the answer. Administrator and seller can design a discount coupon, and customer take advantage of it by issuing a ticket of the coupon and paying it to the order. You can limit the total amount of the coupon by configuring inventory, and also possible to restrict variable conditions such as the minimum amount of the order or the expiration date of the coupon.At last, there can be a customer who wants after service about the purchased product. For example, some customer requests additional features to the OpenAPI product seller. In that case, customer can write an issue about the order good to requesting the new features. Communicating with reply comments, seller can charge a fee to the issue, because the new features need additional labor cost. If customer accepts the fee charge, the seller must do his/her job and close the issue with completion flag. Otherwise, customer can reject the fee charge and close the issue with cancellation flag.","sale#Sale":"IHubSale\nIHubSaleSnapshot\nIHubSaleUnit\nIHubSaleUnitOption\nIHubSaleUnitOptionCandidate\nIHubSaleUnitStock\nIHubSaleUnitStockChoice\nIHubSaleUnitStockPrice","hub_sales#hub_sales":"Seller sales products (API).hub_sales 는 판매자가 등록한 \"API 제품 판매\" (세일즈)\n정보를 형상화한 엔티티이다.그리고 매물의 주 정보는 본 hub_sales 가 아닌, 하위  hub_sale_snapshots 에\n기록된다. 판매자가 기 등록한 매물을 변경하면, 기존의 hub_sales 레코드가 변경되는 것이\n아니라, 새로운 스냅샷 레코드가 생겨나는 것. 이는 고객이 특정 매물을\n구입한 이후, 판매자가 해당 매물의\n구성품이나 가격 등을 변경하더라도, 고객의 당시\n구매 내역을 무결적으로 보존하기 위함이다. 또한, 판매자가 구성품이나 가격 등을 변경하며\n각각의 경우에 대한 성과를 측정하는, 이른바 A/B 테스트를 할 수 있게 지원하기 위함이기도\n하다.Properties\nid: Primary Key.\nhub_section_id: 귀속 섹션의 hub_sections.id\nhub_customer_id: 매물을 등록한 판매자 고객의 hub_customers.id\ncreated_at: 레코드 생성 일시.\nopened_at\n판매 개시 일시.이 값이 NULL 이거든, 아직 판매를 개시하지 않은 상태.\nclosed_at\n판매 종료 일시.이 값이 NULL 이거든, 영원히 판매가 계속된다.\npaused_at\n판매 일시 정지.판매자가 모종의 이유로 API 판매를 일시적으로 중단한 상태.고객은 여전히 리스트 및 상세 페이지에서 해당 매물을 열람할 수 있으되,\n해당 매물에는 \"판매자가 일시 중지된 상품입니다\" 라는 라벨이 붙는다.\nsuspended_at\n판매 중단.판매자가 모종의 이유로 판매를 중단한 상태.고객은 해당 매물을 리스트 및 상세 페이지에서 일절 조회할 수 업다.\n언뜻 보면 soft delete 와 비슷해보이나, 판매 당사자와 관리자는 여전히 이를\n조회할 수 있고, 언제든지 판매를 재개할 수 있다는 점이 다르다.","hub_sale_snapshots#hub_sale_snapshots":"매물 스냅샷 정보.hub_sale_snapshots 은 매물의 스냅샷을 형상화한\n엔티티이다. 그리고 hub_sale_snapshots 레코드는 새 매물을 생성 혹은\n기존의 매물을 수정할 때마다 생성된다.참고로 매물을 편집 (새 스냅샷 레코드 생성) 하는 일은,\n판매자 외에 관리자\n또한 가능하다. 관리자가 해당 매물을 심사하는 도중,\n첨삭을 하는 경우가 바로 그러하다.Properties\nid:\nhub_sale_id: 귀속 매물의 hub_sales.id\nversion\n버전명.ISwaggerInfo.version 과 다른 값을 설정할 수 있다.즉, 서버 스펙 (스웨거 문서) 상 버전명과, 제품상 버전명이 다를 수 있음.\nversion_description\n버전 설명.버전 설명에 대한 정보를 기록할 수 있다.\ncreated_at: 레코드 생성 일시.\nactivated_at\n스냅샷의 활성화 시점.본 스냅샷에 대한 심사가 승인되어, 최초 활성화된 시각.본디 hub_sale_audit_approvals 를 통하여 유추 가능한 정보이나,\n빠른 레코드 탐색을 위하여 중복 기록함.\nexpired_at: 스냅샷 내 모든 API 의 만료 시점.","hub_sale_snapshot_units#hub_sale_snapshot_units":"매물에서 취급하는 제품 구성 정보.hub_sale_snapshot_units 은 매물에서 취급하는 \"개별 제품\" 정보를\n형상화한 엔티티이다. 그리고 여기서 말하는 \"개별 제품\" 이란, 허브 시스템에서의\n개별 서버 단위, 즉 스웨거 문서에 대응하는 개념이다.참고로 hub_sale_snapshot_units 이 hub_sale_snapshots 로부터\n1: N 의 대수관계로 분리된 이유는 바로, 하나의 매물에서 복수의 제품을 판매하는 경우가\n종종 있기 때문이다. 이른바 \"묶음 상품\" 의 경우가 그러하다.\n일반 상품에서의 묶음 상품 (노트북 세트)\n본체\n키보드\n마우스\n애플 케어 (무료 A/S 권)\n허브 시스템에서의 묶음 상품 (작가 AI 세트)\n글쓰기 서버\n이미지 생성 서버\n로고/표지 생성 서버\n그리고 hub_sale_snapshot_units 은 다시, 그 자체로써 고객이 구매하게 될\n최종 구성품을 의미하지는 않는다.\n최종 구성품은 주어진 옵션과 그\n후보값들을 모두 선택한\n끝에라야, 비로소 만나볼 수 있는 것.가령 노트북을 한 대 사더라도, 그 안에서 각각 (CPU / RAM / SSD) 등의 옵션을\n모두 고른 뒤에야, 최종 구성품이 정해지듯이 말이다.Properties\nid:\nhub_sale_snapshot_id: 귀속 스냅샷의 hub_sale_snapshots.id\nstudio_repository_release_id\n귀속 릴리즈의 studio_repository_release.id@format uuid\n이 필드를 사용하여 이 Unit이 Workflow 인지 API 인지 확인한다.\nparent_id\n부모 유닛의 hub_sale_snapshot_units.id부모 유닛을 구매한 고객은, 현 유닛의 API 를 이어서 사용할 수 있다.\nname: 유닛의 대표 이름.\nhost_real: 실제 서버 주소.\nhost_dev: 테스트 서버 주소.\nswagger\n스웨거 문서 데이터.OpenAPI v3.1 스펙으로 변환하여 사용 중.\nprimary\n주/부 여부.단순 표기상 속성.\nrequired\n필수 여부.필수 유닛의 경우, 이를 배제하고 구매할 수 없다.\nsequence: 귀속 스냅샷 내 배치 순서.","hub_sale_snapshot_unit_parameters#hub_sale_snapshot_unit_parameters":"매물 유닛의 파라미터 정보.판매자 서버로 전송될 추가 파라미터에 대한 정의.Properties\nid:\nhub_sale_snapshot_unit_id: 귀속 유닛의 hub_sale_snapshot_units.id\nin\n파라미터의 유형.현재 본 시스템에서는 두 가지 유형의 파라미터를 지원 중.\nquery\nheader\nkey: Key 값, 즉 변수명.\nvalue: Value 값, 즉 변수값.\ndescription:\nsequence:\ncreated_at:\nupdated_at:\ndeleted_at:","hub_sale_snapshot_unit_options#hub_sale_snapshot_unit_options":"매물 유닛에서의 개별 옵션 정보.hub_sale_snapshot_unit_options 은 매물 내 개별 제품을 형상화한\nhub_sale_snapshot_units 의 하위 엔티티로써, 해당 유닛의\n개별 옵션 정보를 형상화하기 위하여 설계된 엔티티이다.\n옵션의 사례\n선택형 옵션\n컴퓨터 성능: CPU, GPU, RAM 등\n이미지 생성 AI: 랜더링 퀄리티, 라이선스 종류, 테마 등\n서술형 옵션\n라벨링\n사용 목적 (설문조사)\n만일 옵션의 타입이 select 에 가변값이 참이라면, 그\n후보값의 선택에 따라,\n고객이 구매하게 될 최종 구성품이\n달라진다.반대로 select 이외에 타입이라던가, 타입은 select 이되, 가변 여부가 거짓이라면,\n이는 단순 정보 전달 이상의 의미가 없는 옵션이다. 따라서 고객이 이를 구매하며\n그 어떠한 값을 기재하고 선택하던, 이 경우의 옵션은 최종 구성품에 영향을 주지 않는다.Properties\nid:\nhub_sale_snapshot_unit_id: 귀속 유닛의 hub_sale_snapshot_units.id\nname: 옵션의 이름.\ntype\n옵션의 타입.\nselect: 후보 아이템 중 하나를 선택하는 방식\nboolean\nnumber\nstring\nvariable\n가변형 여부.현 옵션의 타입이 \"select\" 일 때, 후보값을 다르게 선택하는 것이,\n최종 구성품에 변화를 주는지 여부.\nsequence: 귀속 유닛 내 배치 순서.","hub_sale_snapshot_unit_option_candidates#hub_sale_snapshot_unit_option_candidates":"옵션 내 선택 가능 후보 값.hub_sale_snapshot_unit_option_candidates 는 \"select\" 타입의\n옵션에서 선택할 수 있는,\n개개별별 후보값을 형상화한 엔티티이다.\n사례\n옵션) RAM: 8GB, 16GB, 32GB\n옵션) GPU: RTX 3060, RTX 4080, TESLA\n옵션) 라이선스 종류: 개인용, 상업용, 교육용\n다만 귀속 옵션의 타입이 \"select\" 가 아니라면, 본 엔티티는 필요 없다.Properties\nid:\nhub_sale_snapshot_unit_option_id: 귀속 옵션의 hub_sale_snapshot_unit_options.id\nname: 후보값의 대표 이름.\nsequence: 귀속 옵션 내 배치 순서.","hub_sale_snapshot_unit_stocks#hub_sale_snapshot_unit_stocks":"매물 유닛에서의 최종 구성품 정보.hub_sale_snapshot_unit_stocks 은 매물 내 제품 카탈로그를 형상화한\nhub_sale_snapshot_units 의 하위 엔티티로써, 귀속 유닛 내 모든\n옵션 (가변형 \"select\" 타입) 및 그\n후보값들을 모두\n선택함으로써 구성되는, 일종의 최종 구성품이다. 고객이 실제로 구매하게 되는 \"재화\"\n그 자체인 셈.\n유닛명) 맥북 본체\n옵션\nCPU: { i3, i5, i7, i9 }\nRAM: { 8GB, 16GB, 32GB, 64GB, 96GB }\nSSD: { 256GB, 512GB, 1TB }\n최종 구성품 수: 4 * 5 * 3 = 60 개\n참고로 귀속 유닛 내 hub_sale_snapshot_unit_stocks 레코드의 총 수는\n카테시안 곱 (Cartesian Sale) 으로 구할 수 있다. 즉, 각각의 (가변형 \"select\" 타입)\n옵션이 가질 수 있는 후보값들을 경우의 수로 모두 곱한 값이 곧, 해당 유닛에서의\n최종 구성품의 총 수효인 것. 물론, 단 하나의 가변형 \"select\" 타입 옵션도 없다면,\n해당 유닛에서의 최종 구성품 수는 오직 1 개에 그친다.Properties\nid:\nhub_sale_snapshot_unit_id: 귀속 유닛의 hub_sale_snapshot_units.id\nname: 최종 구성품의 이름.\nsequence: 귀속 유닛 내 배치 순서.","hub_sale_snapshot_unit_stock_choices#hub_sale_snapshot_unit_stock_choices":"최종 구성품의 선택 정보.hub_sale_snapshot_unit_stock_choices 는 귀속\n스톡이 각각 어느 가변형 select 타입의\n옵션 선택하였고, 그 안에서 다시 어떤\n후보값을 선택하여 구성되었는\n지를 형상화한 엔티티이다.물론, 귀속 유닛에 그 어떠한 옵션도 없노라면,\n이 엔티티 또한 무시해도 좋다.Properties\nid:\nhub_sale_snapshot_unit_stock_id: 귀속 스톡의 hub_sale_snapshot_unit_stocks.id\nhub_sale_snapshot_unit_option_candidate_id: 귀속 후보값의 hub_sale_snapshot_unit_option_candidates.id\nsequence: 귀속 스톡 내 배치 순서.","hub_sale_snapshot_unit_stock_prices#hub_sale_snapshot_unit_stock_prices":"스톡의 가격 정보.hub_sale_snapshot_unit_stock_prices 는 스톡의 계단식 가격 정보를 형상화한 엔티티이다.\n그리고 여기서 말하는 계단식 가격이란, 각각이 고정비와 변동비를 모두 아우르며, 그러한 구간이\n여럿 있는 것을 뜻한다.계단형 가격 정보가 무엇인지는, 아래 예시를 보면 쉬이 이해할 수 있을 것이다.\n고정비 50,000 원에 API 1,000 건까지 무료, 초과분 1건당 100 원\n고정비 100,000 원에 API 2,500 건까지 무료, 초과분 1건당 75 원\n고정비 150,000 원에 API 4,000 건까지 무료, 초과분 1건당 50 원\nProperties\nid:\nhub_sale_snapshot_unit_stock_id: 귀속 스톡의 hub_sale_snapshot_unit_stocks\nthreshold: 고정 금액 내 무료 수량.\nfixed: 고정 금액.\nvariable\n변동 금액.한도 수량을 초과하여 API 가 사용된 경우의 건당 비용.","hub_sale_snapshot_contents#hub_sale_snapshot_contents":"매물 스냅샷의 컨텐츠 정보.hub_sale_snapshot_contents 는 매물 스냅샷의\n본문 컨텐츠를 형상화한 엔티티이다. 제목과 본문, 그리고 첨부 파일이나 썸네일\n등의 서술 정보를 담당하고 있다.참고로 매물에 기재된 제목이나 본문 컨텐츠 등의 경우, 고객의 구매 의사 결정에\n결정적인 영향을 주기 마련이다. 때문에 매물을 수정하며 API 서버 스펙은 전혀\n변하지 않고, 그저 제목이나 본문 텍스트 정도나 변했음에도 불구하고, 새로운\n스냅샷을 필히 발급해야하며 심사도 다시 받아야하고 버전도 바뀌어야함은 바로 이\n때문이다.즉 API 상 변경사항만큼이나 컨텐츠 상 변경 내용도 중대하게 보기 때문에,\n매물 스냅샷과 그 컨텐츠의 구조가 1: N 이 아닌 1: 1 로 고정화 된 것.Properties\nid: Primary Key.\nhub_sale_snapshot_id: 귀속 스냅샷의 hub_sale_snapshots.id\ntitle: 제목.\nsummary: 요약 설명\nformat\n본문의 형식, 거진 확장자.txt 나 html 또는 md 사용.\nbody: 본문 컨텐츠.","audit#Audit":"IHubSaleAudit\nIHubSaleAuditEmendation\nIHubSaleAuditRejection\nIHubSaleAuditApproval\nIHubSaleAuditComment","hub_sale_audits#hub_sale_audits":"매물 스냅샷에 대한 심사 정보.본 거래소는 판매자가 매물을 등록하고 이를 수정할 때마다\n(새로운 매물 스냅샷 레코드가 생성될 때마다),\n관리자의 심사를 필요로 하며, 이를 통과하지 못하는 경우에는\n판매 행위 자체가 불가능하다. hub_sale_audits 는 바로 이러한 매물 스냅샷의 심사를\n형상화한 엔티티이다.그리고 관리자는 심사 사항을 일종의 게시물로써 작성할 수 있으며,\n심사 과정 혹은 그 결과에 대하여, 판매자와 관리자가 댓글을 통하여 지속적으로 소통할 수 있다.\n때문에 본 hub_sale_audits 는 bbs_articles 의 서브타입 엔티티로써 설계되었다.또한, 본 심사 게시물은 관리자가 이를 수정할 때마다, 그 수정 내역을 모두 기록하여\n판매자와 관리자가 모두 열람할 수 있도록 하고 있다. 돈이 오가는 전자상거래의 특성상 분쟁의\n소지는 늘 만연하며, 관리자 또한 예외가 될 수 없기 때문이다. 분쟁시 관리자가 자신의 주장을\n번복하며 게시물을 수정하여 정황을 조작하는 일을 막기 위함이다.이외에 관리자가 심사를 거절했다가 이를 번복하여 승인하는 것은 가능하되, 이미 승인한\n심사 내역을 번복하여 거절하는 것은 불가능하다. 심사를 승인한 순간 이미 매물의 판매가\n개시되어버리기 때문.Properties\nid:\nhub_sale_snapshot_id: 귀속 매물 스냅샷의 hub_sale_snapshots.id\nhub_customer_id: 심사를 개시한 관리자 고객의 hub_customers.id","hub_sale_audit_emendations#hub_sale_audit_emendations":"매물 심사의 첨삭 정보.본 거래소는 hub_sellers 가 등록 혹은 수정한\n매물에 대하여 관리자의\n심사가 필요하다. 그리고 심사 중에 관리자와\n판매자는 상호 댓글을 주고받으며,\n해당 매물을 첨삭하고 수정할 수 있다.본 엔티티 hub_sale_audit_emendations 는 이러한 첨삭을 형상화한 엔티티로써,\n관리자 혹은 판매자가 어떤 스냅샷을 대상으로 첨삭을\n행하였고, 그 결과 새로이 탄생한 스냅샷이 무엇인지의 정보를 가지고 있다.그리고 첨삭 대상은 반드시 가장 최근 스냅샷일 필요는 없으며, 경우에 따라 그 이전\n스냅샷에 대한 첨삭을 행함으로써, 롤백 내지 분기 처리하는 것도 가능하다. 물론,\n첨삭 대상 스냅샷은 현재의 심사와 관련이 있어야하며, 이전 심사 통과된 스냅샷을\n대상으로는 첨삭을 일절 행할 수 없다.이외에 첨삭은 오직 심사가 진행 중에만 가능하며, 심사가\n승인되거든 더 이상의 첨삭은 불가능하다. 다만\n관리자가 심사 거절 처리를 하는 경우에는,\n판매자가 스스로 첨삭하고 보강하며, 관리자에게 재심을 요청할 수 있다.Properties\nid:\nhub_sale_audit_id: 귀속 심사의 hub_sale_audits.id\nhub_customer_id: 첨삭 수행자 고객의 hub_customers.id.\nprevious_hub_sale_snapshot_id\n첨삭 전 매물 스냅샷의 hub_sale_snapshots.id.첨삭 대상 스냅샷이, 반드시 심사 개시 당시의 스냅샷일 필요는 없다. 또다른\n첨삭의 결과물에 대하여 추가로 첨삭하는 것이 가능하며, 이전의 첨삭으로 돌아가\n다시 첨삭을 하는 것도 가능하다.\nafter_hub_sale_snapshot_id\n첨삭 결과물의 스냅샷 hub_sale_snapshots.id.판매자 또는 관리자가 첨삭을 행한 결과로써 탄생한 새 스냅샷.\nactor_type\n첨삭을 행한 고객의 유형\nadministrator: 관리자\nseller: 판매자\ndescription\n첨삭에 대한 부가 서술부.본 첨삭에 대하여 따로이 설명할 내용이 있을 때.\ncreated_at: 레코드 생성 일시.","hub_sale_audit_rejections#hub_sale_audit_rejections":"매물 스냅샷 심사에 대한 거절.hub_sale_auditsRejection 은 관리자가\n매물 심사를 거절한 이력을 형상화한 엔티티이다.참고로 매물 스냅샷 심사를 발제한 관리자와, 거절 처리하는\n관리자는 서로 다른 사람일 수 있다. 또한, 판매자가\n댓글로 재심의를 요청하는 경우, 관리자는 반복하여\n거절 처리할 수 있다.Properties\nid:\nhub_sale_audit_id: 귀속 심사의 hub_sale_audits.id.\nhub_customer_id: 거절한 관리자 고객의 hub_customers.id.\nreversible\n번복 가능 여부.현재의 심사 거절을 확정하고, 번복하지 않을지 여부.단, 이는 판대자에게 현재의 거절을 확정하고, 향후 번복하여 승인하는 일이 없을\n것이라는 의사 표현에 불과할 뿐이다. 실제로는 이렇게 의사를 표현해놓고,\n나중에 번복하여 승인 처리하는 것이 가능함.\ncreated_at: 레코드 생성 일시.","hub_sale_audit_approvals#hub_sale_audit_approvals":"매물 스냅샷 심사에 대한 승인.hub_sale_audit_approvals 는 관리자가\n매물 심사를 승인하는 행위를 형상화한 엔티티이다.참고로 매물 스냅샷 심사를 발제한 관리자와, 승인 처리하는 관리자는 서로 다른 사람일 수\n있다. 또한, 심사를 거절하였다가 번복하여 승인하는 것이 가능하다. 단, 반대로 이미\n승인한 심사를 번복하여 거절하는 것은 불가능하다. 승인시\n매물이 실제로 판매 개시되기 때문이다.Properties\nid:\nhub_sale_audit_id: 귀속 심사의 hub_sale_audits.id.\nhub_sale_snapshot_id\n심사 승인 대상 스냅샷의 hub_sale_snapshots.id.심사를 승인할 때, 반드시 마지막 첨삭본만을\n대상으로 승인할 필요는 없다. 경우에 따라 원본 스냅샷 내지, 이전 첨삭본을 대상으로\n승인하여 활성화 가능.\nhub_customer_id: 승인한 관리자 고객의 hub_customers.id.\nfee_ratio: 수수료율.\ncreated_at: 레코드 생성 일시.","hub_sale_audit_comments#hub_sale_audit_comments":"심사 게시물에 작성한 댓글.hub_sale_audit_comments 는 bbs_article_comments 의 서브타입 엔티티로써,\n관리자가 발의한 심사에\n대하여, 관리자와 판매자가 상호 소통할 때 사용한다.이는 심사가 종료된 이후로도 그러하며, 한 번 거절 처리된 심사 건에 대하여도, 판매자가\n댓글로써 재심을 요청할 수 있다. 물론, 판매자가 재심을 요청하기 전 관리자의 가이드에 따라\n자체 첨삭을 진행하는 경우가 대부분이다.Properties\nid:\nhub_customer_id: 댓글을 작성한 고객의 hub_customers.id.\nactor_type\n댓글을 작성한 고객의 유형.\nadministrator: 관리자\nseller: 판매자","order#Order":"IHubCartCommodity\nIHubOrder\nIHubOrderGood\nIHubOrderPrice\nIHubOrderPublish","hub_carts#hub_carts":"장바구니.장바구니 hub_carts 는 문자 그대로, 고객이 상품을\n구매하기 전 잠시 담아두는 공간이다.다만, 여기서의 hub_carts 는 장바구니에 상품을 담는 대상이 반드시 소비자라 정해진 것은\n아니다. 판매자 및 관리자 또한 스스로\n장바구니를 구성할 수 있는데, 그 목적은 그들 스스로가 상품을 구매하기 위함은 아니며,\n단지 고객에게 제공할 장바구니 템플릿을 미리 구성하기 위함이다.Properties\nid:\nhub_customer_id: 장바구니 생성자 고객의 hub_customers.id\nactor_type: 장바구니 생성자의 유형.\ncreated_at: 레코드 생성 일시.\ndeleted_at: 레코드 삭제 일시.","hub_cart_commodities#hub_cart_commodities":"장바구니에 담은 상품 (원재료).hub_cart_commodities 는 고객이 구매를\n염두에 두고, 장바구니에 담은 매물 스냅샷을 형상화한 엔티티이다.\n그리고 향후 고객이 이를 실제 주문으로 이어나간다면, 그 때의 단위는\nhub_cart_commodities 에서 hub_order_goods 이 된다.그리고 장바구니에 매물 스냅샷을 담으면서, 필연적으로 고객은 매물 스냅샷 내의 특정\n유닛 및\n최종 구성품 등을 선택하기 마련이다.\n이 유닛 및 구성품에 대한 정보는 하위 엔티티인 hub_cart_commodity_stocks 에\n기록된다.Properties\nid:\nhub_cart_id: 귀속 장바구니의 hub_carts.id\nhub_sale_snapshot_id: 대상 매물 스냅샷의 hub_sale_snapshots\ncreated_at: 레코드 생성 일시.\ndeleted_at: 레코드 삭제 일시.\npublished\n출판 여부.현 장바구니 상품으로 주문하고 결제 완료되었는가.주문 완료 전까지, 장바구니 상품을 재활용하여 신규 주문 신청 레코드 계속 생성 가능.역 정규화의 일환으로써, 실제로는 계산 가능한 속성이되, 다만 성능을 위함.","hub_cart_commodity_stocks#hub_cart_commodity_stocks":"장바구니에 담은 매물의 최종 구성품 정보.hub_cart_commodity_stocks 은 장바구니에 담은\n매물 스냅샷의 정보를 형상화한 hub_cart_commodities\n의 하위 엔티티로써, 대상 매물 스냅샷 내의 개별 유닛 및\n그 유닛 중에 최종 선택하게 된 구성품과 대응되는 개념이다./ 따라서 만일 고객이 대상 매물 스냅샷으로부터 복수의 유닛 및 구성품을 선택하였다면,\n귀속 hub_cart_commodities 레코드 또한 복수의 대응되는\nhub_cart_commodity_stocks 레코드들을 가지게 된다.Properties\nid:\nhub_cart_commodity_id: 귀속 장바구니 상품의 hub_cart_commodities\nhub_sale_snapshot_unit_id: 대상 유닛의 hub_sale_snapshot_units.id\nhub_sale_snapshot_unit_stock_id: 대상 최종 구성품의 hub_sale_snapshot_unit_stocks\nhub_sale_snapshot_unit_stock_price_id: 선택한 가격 모형의 hub_sale_snapshot_unit_stock_prices\nsequence: 귀속 장바구니 상품 내 배치 순서.","hub_cart_commodity_stock_choices#hub_cart_commodity_stock_choices":"장바구니에 담은 최종 구성품의 옵션 선택 정보.hub_cart_commodity_stock_choices 는 hub_cart_commodity_stocks 의 하위\n엔티티로써, 고객이 장바구니에\n매물 스냅샷의 특정 유닛\n및 특정 구성품)을 담으면서, 구체적으로 어떠한\n옵션)들을 사용하였으며, 그 안에서 다시 어떠한\n후보 아이템들을 선택하거나 또는\n기재했는지를 기록한다.따라서 hub_cart_commodity_stock_choices 는\n옵션)에 대한 참조 외에,\n후보 아이템에 대한 참조 속성 및\n서술부 속성을 가지는데, 대상 옵션)의 타입이\nselect 이거든 고객이 선택한\n후보 아이템을 입력하고,\n그 외의 것이라면 고객이 기입한 값을 기재하면 된다.Properties\nid:\nhub_cart_commodity_stock_id: 귀속 장바구니 상품 스톡의 hub_cart_commodity_stocks.id\nhub_sale_snapshot_unit_option_id: 대상 옵션의 hub_sale_snapshot_unit_options.id\nhub_sale_snapshot_unit_option_candidate_id\n선택한 옵션에 대하여 고객이 선택한 후보값의\nhub_sale_snapshot_unit_option_candidates.id\nvalue: 서술형 옵션에 대하여 고객이 기재한 값.\nsequence: 귀속 장바구니 상품 내 배치 순서.","hub_orders#hub_orders":"주문 정보.hub_orders 는 고객의 주문 정보를 형상화한 엔티티이다.그리고 고객이 주문을 행하는 즉시, 대상 장바구니에 들은\n장바구니 상품들이 모두 주문 상품으로\n격상, hub_orders 의 하위에 hub_order_goods 레코드를 구성하게 된다.물론, 대상 장바구니에 들은 모든 상품 원재료가 주문 상품이 되는 것은 아니며, 그 중 고객이\n선택한 것만이 hub_order_goods 가 된다.Properties\nid:\nhub_customer_id: 귀속 고객의 hub_customers.id\ncreated_at: 레코드 생성 일시.\ncancelled_at: 주문 취소 일시.","hub_order_goods#hub_order_goods":"주문을 구성하는 개별 상품 정보.hub_order_goods 은 고객이 주문한 각각의 상품을 뜻하는\n엔티티로써, 장바구니에 담긴 상품 원재료가,\n고객의 주문 신청으로 인하여 상품으로 격상되는 과정에서 그 레코드가\n생성된다.그리고 hub_order_goods 는 hub_cart_commodities 가 그러하였든,\n매물 스냅샷 단위에 대응되는 개념이다.더하여 hub_order_goods 은 주문 이후의 과정, 즉 사후 처리 (A/S) 에 대한 가장 기본 단위가\n된다. 가령 고객이 주문 상품에 대하여 이슈를 발행하거나,\n환불을 요청하는 단위도 바로 이 hub_order_goods 이다.Properties\nid:\nhub_order_id: 귀속 주문의 hub_orders.id\nhub_cart_commodity_id: 귀속 장바구니 상품의 hub_cart_commodities.id\nhub_seller_id\n귀속 판매자의 hub_sellers.id귀속 매물의 판매자 정보, 빠른 탐색을 위하여 한 번 더 기록함.\nopened_at\n계약 개시 일시.주문의 확정 시점과 다르게, 효력의 발생 시점을 그보다 뒤로 미룰 수 있다.\n그리고 계약 효력의 발생 시점은, 그것이 도래하기 전까지, 계속 편집할 수 있다.\n또한 월 고정비 과금은, 본 개시 일자를 기준으로 계상된다.참고로 고객이 판매자의 API 를 구입한 후, 이를 검토하고 개발하는 과정이\n필요하기에, 본디 계약의 효력 발휘 일시는 주문 확정보다 더 뒤로 밀릴 수밖에\n없는 법.\nclosed_at\n계약 종료 일시.단, 계약의 종료 시점을 지금 즉시로 할 수 없다. 계약 개시 시점을 기준으로,\n최소 1 개월의 기간이 지나야만 취소할 수 있다. 그리고 이미 계약애 개시된\n상태라면, 마찬가지로 1 개월 단위로만 계약 종료가 가능하다.\nsequence: 귀속 주문 내 배치 순서.","hub_order_publishes#hub_order_publishes":"주문의 확정 정보.hub_order_publishes 는 주문의 확정 정보를 형상화한 엔티티이다. 따라서\n본 엔티티가 존재한다는 것은, 고객이\n신청한 주문이 계약으로써 성립하였고 확정되었음을 뜻한다.단, 계약이 확정되었다하여, 그것이 곧바로 개시되는 것은 아니다. 계약의 개시는\n각 상품마다 각각이 설정할 수 있으며, 이는 고객이\n판매자의 API 를 구입한 후, 이를 분석하고 개발하는 과정이 필요하기에,\n계약의 개시 시점을 뒤로 미룰 수 있도록 설계한 것.단 계약의 개시 시점이 나중이더라도, 계약의 효력이 발휘된 시점에서, 첫 달 분의\n고정비는 예치 상태로 전환된다. 물론, 계약의 개시 시점 전까지는 주문 계약을\n취소하여, 이를 환불할 수 있다.Properties\nid: Primary Key.\nhub_order_id: 귀속 주문의 hub_orders.id\ncreated_at: 레코드 생성 일시.","hub_order_good_calls#hub_order_good_calls":"주문 상품에 대한 API 호출 내역.고객이 자신이 주문한 상품을 토대로, API 를 호출한 내역을 기록한 엔티티.Properties\nid:\nhub_order_good_id: 귀속 주문 상품의 hub_order_goods.id\nhub_sale_snapshot_unit_id: 호출한 API 에 해당하는 유닛의 hub_sale_snapshot_units.id\narguments: 입력한 인자값 리스트.\noutput: 실행 결과로써의 리턴값.\nmethod: API 호출 메서드.\npath: API 호출 경로.\nstatus: 판매자 서버로부터의 응답 코드.\ncreated_at: 레코드 생성 일시.\nrespond_at: API 호출 완료 일시.","coupon#Coupon":"IHubCoupon\nIHubCouponCriteria\nIHubCouponCriteriaOfChannel\nIHubCouponCriteriaOfFunnel\nIHubCouponCriteriaOfSale\nIHubCouponCriteriaOfSection\nIHubCouponCriteriaOfSeller\nIHubCouponInventory\nIHubCouponTicket\nIHubCouponTicketPayment","hub_coupons#hub_coupons":"할인 쿠폰.hub_coupons 은 거래소에서의 할인 쿠폰을 형상화한 엔티티이다.단, hub_coupons 은 그저 할인 쿠폰에 대한 명세 (사양) 정보만을 담고 있을\n뿐이다. 할인 쿠폰에 대한 발급을 의미하는 hub_coupon_tickets 내지\n그것의 지급을 의미하는 hub_coupon_ticket_payments 와는 다른\n개념이니, 이 점 유의하기 바란다.또한 할인 쿠폰은 주문 단위로 적용하되, 각각이 나름의\n고유한 제약사항을 가진다. 예를 들어\n판매자 제약이 걸린 쿠폰은, 오직 해당\n판매자가 등록한 매물 스냅샷에 대해서만 사용할\n수 있거나 또는 사용할 수 없다. 그리고 할인 쿠폰을 사용하기 위한 최소 금액\n제한이라던가, 할인 금액의 최대 한도 등의 제약도 존재한다.이외에 할인 쿠폰을 공개적으로 발행하냐, 아니면 특정 발급 코드를 아는 사람에게만\n줄 것이냐 등을 설정할 수 있다. 더하여 발급받은 할인 쿠폰에 만료 기한이 있다거나,\n오직 특정 경로를 통하여 유입된 고객에게만 발행한다던가 하는 제약도 있다.자세한 내용은 아래의 속성 및 후술할 하위 엔티티들을 참고하기 바란다.Properties\nid:\nhub_customer_id: 할인 쿠폰을 등록한 판매자 또는 관리자의 고객 hub_customers.id\nactor_type\n할인 쿠폰을 등록한 사용자의 유형.\nf\nseller: 판매자\nadministrator: 관리자\nname: 할인 쿠폰의 대표 이름.\naccess\n할인 쿠폰을 공개적으로 열람할 수 있는가.\npublic: 주문시 사용 가능한 쿠폰으로 일괄 조회 가능\nprivate: 일괄 조회 불가\n판매자 혹은 관리자가 임의 부여해주거나\n일회용 링크를 통해서만 발급 가능\nexclusive\n배타성 여부.배타적 할인 쿠폰이란, 다른 할인 쿠폰에 대하여 배타적 관계를 가져, 오직 단독\n사용만이 가능한 할인 쿠폰을 가르키는 말이다. 즉, 배타적 할인 쿠폰을 사용하는\n경우, 동일 주문 내지\n상품에 대하여, 그 어떠한 다른 할인 쿠폰도\n사용할 수 없게 된다.\nunit\n할인 단위.만일 할인 단위가 절대 금액인 경우, 오직\n고정비에 대해서만\n1회 적용되며, 반대로 단위가 퍼센트인 경우에는 고정비과 변동비 모두를 대상으로\n매달 반복하여 적용된다.\namount: 절대 금액\npercent: 퍼센트\nvalue\n할인 금액.할인 단위가 퍼센트일 경우 0 ~ 100, 절대 금액인 경우 자유롭게 기입.\nthreshold\n할인을 위한 최소 구매 금액.이 값을 설정시, 해당 값을 하회하는 주문 총액 (월 고정비) 에 대하여는\n할인 쿠폰 적용을 적용할 수 없다. 물론 이 값이 NULL 이거든, 최소 금액에\n대한 조건이 없다는 것.\nlimit\n할인 가능 최대 금액.이 값을 설정시, 제 아무리 많은 금액을 주문해도, 그 이상 할인되지 아니함.\nvolume\n발급 수량 제한.발급 수량에 제한이 있는 경우, 이 값을 넘어서는 티켓 발행이 불가능해짐.즉, 쿠폰에 선착순 N 매 개념이 생긴다는 뜻.\nvolume_per_citizen\n1 인당 발급 수량 제한.1 인 단위의 발급 총량 제한으로써, 동일 시민에게의 중복 발급을 제한하기 위하여\n1 을 할당하거나, 아니면 제한을 두지 않고자 NULL 값을 사용하는 게 보통이다.물론 N 값을 부여하여, 동일 시민에게로의 발행 총량을 제한할 수 있다.\nexpired_in\n만료 도래일 수.할인 쿠폰 티켓을 발급받은 후, N 일이 지나면 만료되는 개념.때문에 고객은 티켓을 발급한 이후로, 가급 N 일 안에 소모해야 함.\nexpired_at\n만료 도래 날짜.할인 쿠폰 티켓을 발급받은 후, YYYY-MM-DD 가 지나면 만료되는 개념.hub_coupons.expired_in 과 함께 이중 제약 가능.\nopened_at: 발급 개시 일자.\nclosed_at\n발급 종료 일자.이 시점이 지난 이후로 티켓 발급 불가.다만 기 발행된 티켓은 여전히 그들의\n만료 도래일까지 사용 가능.\ncreated_at: 레코드 생성 일시.\nupdated_at\n할인 쿠폰 편집 일시.발급 개시일 이전까지만 편집 가능하다.\ndeleted_at: 할인 쿠폰 삭제 일시.","hub_coupon_criterias#hub_coupon_criterias":"할인 쿠폰의 적용 대상 조건에 대한 슈퍼타입.hub_coupon_criterias 는 할인 쿠폰의 적용 대상 조건을 형상화한 슈퍼타입\n엔티티이다. 할인 쿠폰의 참조 단위에 대하여 제약을 가하고자 하는 모든 서브타입\n엔티티들이, 이를 상속하여 만들어졌다. 예를 들어,\n특정 섹션에 대하여 적용 대상을 제한하기 위하여 설계된\nhub_coupon_criteria_of_sections 엔티티가, 본 엔티티\nhub_coupon_criterias 를 상속하고 있다.이외에 참조 단위에 대한 제약은, direction 속성을 통하여 포함 조건으로\n나아갈 지, 반대로 배제 조건으로 나아갈 지 정할 수 있다. 만약 direction 값이\n\"include\" 이거든, 해당 참조 대상에 대해서만 적용 가능한 쿠폰이 되는 것이고,\n반대로 direction 값이 \"exclude\" 이거든, 해당 참조 대상에 대해서는 적용할\n수 없는 쿠폰이 되는 것이다.Properties\nid:\nhub_coupon_id: 귀속 할인 쿠폰의 hub_coupons.id\ntype\n할인 쿠폰의 타입.어떠한 서브타입을 가지냐를 의미함.\ndirection\n제약 조건이 적용되는 방향.\ninclude: 포함 조건\nexclude: 배제 조건\nsequence: 귀속 할인 쿠폰 내 배치 순서.","hub_coupon_criteria_of_sections#hub_coupon_criteria_of_sections":"할인 쿠폰의 섹션에 대한 조건.hub_coupon_criteria_of_sections 는 hub_coupon_criterias 의\n서브타입 엔티티로써, 특정 hub_sections 에 대하여 조건을 걸 때 사용한다.만일 hub_coupon_criterias.direction 값이 \"include\" 이거든\n해당 섹션에 대해서만 사용 가능한 쿠폰이, 반대로 \"exclude\" 이거든 사용 불가능한\n쿠폰이 된다. 그리고 한 쿠폰 내에 복수의\nhub_coupon_criteria_of_sections 레코드가 존재한다면, 이 때는 묶음 단위로\n조건이 걸린다. 대상 섹션들에 대하여 적용 가능 혹은 적용 불가능한 쿠폰이 되는 것.Properties\nid:\nhub_section_id: 귀속 할인 쿠폰의 hub_coupon_criterias.id","hub_coupon_criteria_of_channels#hub_coupon_criteria_of_channels":"할인 쿠폰의 채널에 대한 조건.hub_coupon_criteria_of_channels 는 hub_coupon_criterias 의\n서브타입 엔티티로써, 특정 채널 혹은 해당\n채널의 카테고리에 대하여 조건을 걸 때 사용한다.만일 hub_coupon_criterias.direction 값이 \"include\" 이거든\n해당 채널 (또는 카테고리)에 대해서만 사용 가능한 쿠폰이, 반대로 \"exclude\" 이거든\n사용 불가능한 쿠폰이 된다. 그리고 한 쿠폰 내에 복수의\nhub_coupon_criteria_of_channels 레코드가 존재한다면, 이 때는 묶음 단위로\n조건이 걸린다. 대상 채널 및 카테고리들에 대하여, 적용 가능 혹은 적용 불가능한\n쿠폰이 되는 것.Properties\nid:\nhub_channel_id: 대상 채널의 hub_channels.id\nhub_channel_category_id: 대상 채널 카테고리의 hub_channel_categories.id","hub_coupon_criteria_of_sellers#hub_coupon_criteria_of_sellers":"할인 쿠폰의 판매자에 대한 조건.hub_coupon_criteria_of_sellers 는 hub_coupon_criterias 의\n서브타입 엔티티로써, 특정 판매자에 대하여 조건을 걸 때\n사용한다.만일 hub_coupon_criterias.direction 값이 \"include\" 이거든\n해당 판매자에 대해서만 사용 가능한 쿠폰이, 반대로 \"exclude\" 이거든 사용\n불가능한 쿠폰이 된다.그리고 한 쿠폰 내에 복수의\nhub_coupon_criteria_of_sellers 레코드가 존재한다면, 이 때는 묶음 단위로\n조건이 걸린다. 대상 판매자들에 대하여 적용 가능 혹은 적용 불가능한 쿠폰이 되는 것.Properties\nid:\nhub_seller_id: 대상 판매자의 hub_sellers.id","hub_coupon_criteria_of_sales#hub_coupon_criteria_of_sales":"할인 쿠폰의 특정 매물에 대한 조건.hub_coupon_criteria_of_sales 는 hub_coupon_criterias 의\n서브타입 엔티티로써, 특정 매물에 대하여 조건을 걸 때\n사용한다.만일 hub_coupon_criterias.direction 값이 \"include\" 이거든\n해당 매물에 대해서만 사용 가능한 쿠폰이, 반대로 \"exclude\" 이거든 사용\n불가능한 쿠폰이 된다.그리고 한 쿠폰 내에 복수의\nhub_coupon_criteria_of_sales 레코드가 존재한다면, 이 때는 묶음 단위로\n조건이 걸린다. 대상 매물들에 대하여 적용 가능 혹은 적용 불가능한 쿠폰이 되는 것.Properties\nid:\nhub_sale_id: 대상 매물의 hub_sales.id","hub_coupon_criteria_of_funnels#hub_coupon_criteria_of_funnels":"할인 쿠폰의 유입 경로 제한.hub_coupon_criteria_of_funnels 은 hub_coupon_criterias 의\n서브타입 엔티티로써, 할인 쿠폰을 특정한 경로에서 유입된\n고객에게만 발급 또는 배제하고자 할 때 사용한다.그리고 유입 경로 제한은 다음과 같이 3 가지 방식으로 가능하다. 첫째는\nhub_customers.referrer 이며, 이외에 고객의 접속 주소를 기록한\nhub_customers.href 를 파싱함으로써, 특정 URL 내지 변수 단위로\n제약이 가능하다.Properties\nid: PK + FK.\nkind\nWhat kind of funnel is it?\npath\nreferrer\nvariable\nkey: 제약 조건의 키, kind 가 \"variable\" 일 때 사용.\nvalue: 제약 조건의 값.","hub_coupon_tickets#hub_coupon_tickets":"할인 쿠폰 티켓 발급 내역.hub_coupon_tickets 은 고객이 발급받은 할인 쿠폰 티켓을 형상화한 엔티티이다.그리고 만일 대상 할인 쿠폰 사양 자체에 유효 기간이 있다면,\n이는 expired_at 에 그 기한이 기록되고, 그 시일이 지난 후에 자동으로 폐기된다.\n물론, 할인 쿠폰 티켓을 기한 내에 주문에\n사용했다면, 상관없을 이야기다.Properties\nid: Primary Key.\nhub_customer_id: 귀속 고객의 hub_customers.id\nhub_coupon_id: 귀속 쿠폰의 hub_coupons.id\nhub_coupon_disposable_id\n귀속 일회용 코드의 hub_coupon_disposables.id본 티켓이 private 할인 쿠폰의 일회용 코드를 통하여 발급된 경우에 사용.\ncreated_at: 티켓 발행 일시.\nexpired_at: 티켓 만료 일시.","hub_coupon_ticket_payments#hub_coupon_ticket_payments":"할인 쿠폰 티켓 지불 (결제) 내역.hub_coupon_ticket_payments 는 할인 쿠폰 티켓\nhub_coupon_tickets 의 주문에 대한\n지급 정보를 형상화한 엔티티로써, 소비자가 자신이\n발급받은 할인 쿠폰 티켓을\n주문에 사용하여 결제 금액을 차감받았을 때 사용한다.그리고 hub_orders 자체가 주문이 완료된 상황에 쓰이는 엔티티가 아닌,\n주문 신청 단계도 함께 표현하기 위하여 설계된 엔티티인 바, 본\nhub_coupon_ticket_payments 레코드가 생성되었다하여 실제로 귀속\n티켓이 사라지는 것은 아니다. 고객이 주문을 확장하기\n전까지, 티켓은 일종의 예치 상태로 이해하면 된다.또한, 본 레코드는 고객 스스로가 티켓의 지급을 번복하여 삭제할 수도 있지만,\n귀속 주문 그 자체가 취소되어 함께 삭제되기도 한다.Properties\nid: Primary Key.\nhub_coupon_ticket_id: 귀속 티켓의 hub_coupon_tickets.id\nhub_order_id: 대상 주문의 hub_orders.id\nsequence: 귀속 주문 내 배치 순서.\ncreated_at: 레코드 생성 일시.","hub_coupon_disposables#hub_coupon_disposables":"할인 쿠폰 발급 코드 관리.할인 쿠폰이 공개되어 누구나 그 티켓을 발급받아갈 수 있는 게 아니라,\n특정한 비밀번호 (일회용 코드) 를 입력해야만 받을 수 있는 경우,\n바로 이 hub_coupon_disposables 엔티티를 사용한다.그리고 이 코드는 \"일회용\" 이다. 즉, 고객 중 그 누구라도 그 코드를 입력하면,\n고객에게 티켓 발급이 완료된 시점에서, 해당 코드는 폐기된다. 따라서 할인 쿠폰을\n비밀 코드로써 여러 번에 걸치에 티켓을 발급하고자 한다면, 당연히 발급 코드 또한\n그만큼의 수량이 뒷받침되어야 할 것이다.Properties\nid: Primary Key.\nhub_coupon_id: 귀속 할인 쿠폰의 hub_coupons.id\ncode\n식별자 코드.일회용 발급 코드.\ncreated_at: 레코드 생성 일시.\nexpired_at: 일회용 코드 만료 일시.","issue#Issue":"IHubOrderGoodIssue\nIHubOrderGoodIssueFee\nIHubOrderGoodIssueFeeAccept\nIHubOrderGoodIssueComment","hub_order_good_issues#hub_order_good_issues":"구매 상품 관련 이슈 게시글.hub_order_good_issues 는 고객이\n주문하고 결제 완료하여\n구성된 상품에 대하여, 고객 및 판매자\n양측이 상호간에 이슈를 제기할 수 있는 게시판이다.고객과 판매자는 상품에 대하여, 주제 단위별로 이슈 게시글을 작성하고, 그 안에서\n댓글로 토의를 이어나가면 된다.또한, 이슈의 종류 중에는 고객이 판매자에게 커스텀 제작이나 개조 등의 추가 작업을\n요청할 수도 있는 법이다. 이 경우, 판매자는 고객에게\n수임료를 부과, 추가 작업에 대한 정당한\n비용 청구가 가능하다.마지막으로, 이슈를 작성한 고객 또는 판매자는, 이슈를 완결한 후 이를 종료\n(closed_at) 처리할 수 있다. 단, 이슈를 종료한 이후에도, 해당 이슈에 댓글을\n계속 작성하는 것이 가능하며, 판매자가 수임료를 부과하는 것 또한 동일하게 가능하다.Properties\nid: PK + FK.\nhub_order_good_id: 귀속 주문 상품의 hub_order_goods.id\nhub_customer_id: 이슈 작성 고객의 hub_customers.id\nactor_type\n이슈 작성자의 유형\ncustomer: 고객\nseller: 판매자\nclosed_at: 추후 누가 닫았는지 알수 있어야함","hub_order_good_issue_comments#hub_order_good_issue_comments":"이슈에 작성한 댓글.hub_order_good_issue_comments 는 bbs_article_comments 의 서브타입\n엔티티로써, 주문 상품에 대하여 작성된\n이슈에 관하여, 고객과\n판매자가 상호 소통할 때 사용한다.참고로 이슈가 종료된 이후로도, 댓글은 계속 작성할 수 있다.Properties\nid: PK + FK.\nhub_customer_id: 댓글을 작성한 고객의 hub_customers.id\nactor_type\n댓글 작성한 고객의 유형\ncustomer: 고객\nseller: 판매자","hub_order_good_issue_fees#hub_order_good_issue_fees":"이슈 해결을 위한 수임료 제시.HubOrderItemIssueFee 는, 판매자가 고객이 주문한\n상품에 대한 이슈를 해결해주며,\n고객에게 제시하는 수임료를 의미한다. 주로 고객이\n이슈를 통하여 커스텀 제작이나 개조 등의 추가 작업을 요청하는 경우에 발생한다.고객은 이에 응하여 수임료를 지불할 수도\n있고, 거절할 수도 있으며, 경우에 따라서는 가격을 갂아달라 네고를 할 수도 있다. 만약\n판매자가 이에 응하여 가격을 조정하려거든, 현 레코드를 삭제하고 새 수임료 레코드를\n다시 발행하면 된다.Properties\nid:\nhub_order_good_issue_id: 귀속 이슈의 hub_order_good_issues.id\nhub_customer_id: 수임료를 제시한 판매자 고객의 hub_customers.id\nvalue: 수임료 금액.\ncreated_at: 레코드 생성 일시.\ndeleted_at\n레코드 삭제 일시.고객이 수임료를 승낙한 이후로는 삭제 불가.","hub_order_good_issue_fee_accepts#hub_order_good_issue_fee_accepts":"이슈에 대한 수임료 수락.hub_order_good_issue_fee_accepts 는, 판매자가 부과한\n이슈 수임료를, 고객이\n받아들여 수락하는 행위를 형상화한 엔티티이다.참고로 수임료를 고객이 수락한 순간과, 이에 대한 효력이 발휘되는 시점을 다르게 할 수 있다.\n즉, 현 시점에서 수임료를 수락하여 예치금이 인출되기는 하되, 이에 대한 효력을 뒤로 미루어,\n판매자가 작업에 대한 착수를 미래에 하게끔 한다던가, 여지를 두어 향후 번복을 한다던가 하는게\n가능하다.Properties\nid:\nhub_order_good_issue_fee_id:\nhub_customer_id: 수임료를 수락한 고객의 hub_customers.id\ncreated_at: 레코드 생성 일시.\npublished_at: 수임료 수락의 효력 개시 일시.\ncancelled_at\n수임료 수락의 취소 일시.효력이 발휘한 이후로는 취소할 수 없다."}},"/tech-specs/meta/execution":{"title":"Execution","data":{"summary#Summary":"Summarize LLM function call execution principles.In this technical documents, the concept of LLM (Large Language Model) funtion call execution is the most important part. Therefore, even though the LLM function call execution concept has been explained detaily in the previous chapters, it would be better to summarize again for the readers who want to understand the concept at a glance.\nConvert to specific and emended OpenAPI specification\nNormalize the OpenAPI specification to the migration schema\nTransform migration schema to the LLM function schema\nPerform the function call execution through WebSocket RPC communication\nLLM Function CallingLLM selects proper function and fill arguments.In nowadays, most LLM (Large Language Model) like OpenAI are supporting \"function calling\" feature. The \"function calling\" means that LLM automatically selects a proper function and compose parameter values from the user's chatting text.https://platform.openai.com/docs/guides/function-calling","openapi-emension#OpenAPI Emension":"Convert to a specific and emended OpenAPI version.To accomplish the LLM (Large Language Model) function call execution mission, \"Wrtn Studio Pro\" starts from converting the OpenAPI document to a specific version (v3.1) with emension for clarity and consistency.The reason of conversion is, there're many versions in the OpenAPI document specification, and there're too many synonym expression ways even in the same version. By unifying a specific version and emending every synonym types, \"Wrtn Studio Pro\" acquires consistent API structures, so that get a change to compose the LLM function schema easier and safer than any others.Also, as \"Wrtn Studio Pro\" operates API Marketplace to supply API operations (functions to call by LLM) to the Meta LLM (A.I. Chatbot), such standardization is essential to provide a stable and reliable service.\nOpenAPI v3.1 emended\nOpenAPI v3.1\nOpenAPI v3.0\nSwagger v2.0","migration-process#Migration Process":"Before converting OpenAPI operations to LLM function calling schemas, \"Wrtn Studio Pro\" transforms the OpenAPI operations to an intermediate structure. The intermediate structure is called migration schema, and normalizes parameters/reponses of the OpenAPI opertion.In other words, the migration schema is called to a helper schema for RPC (Remote Procedure Call) function conversion from OpenAPI operation. By providing noramlized definitions close to the RPC function, \"Wrtn Studio Pro\" can easily convert to the LLM function calling schema from the OpenAPI document.For example, migration schema forces path parameters to have their own names, and combines query/headers to be a single object. Also, separates the response body to success and exceptional cases, and provides a description comment for the RPC function.\nIMigrateDocument\nIMigrateRoute","llm-function-schema#LLM Function Schema":"/**\n * Document of OpenAI function call metadata.\n *\n * `IOpenAiDocument` is a data structure representing content of\n * {@link IOpenAiDocument.functions OpenAI function call metadata}, composed by\n * {@link OpenAiComposer} from the {@link ISwagger} document, with\n * {@link IOpenAiDocument.errors} and adjusted {@link IOpenAiDocument.options}.\n *\n * The different between `IOpenAiDocument` and its origin source {@link ISwagger}\n * is, `IOpenAiDocument` has converted every {@link ISwaggerOperation API endpoints}\n * to {@link IOpenAiFunction function metadata}. You can execute the function call\n * with OpenAI constructed arguments by using the {@link OpenAiFetcher.execute}\n * function with the function metadata.\n *\n * Also, every type schema informations are casted from {@link ISwaggerSchema} to\n * {@link IOpenAiSchema} to escape {@link ISwaggerSchema.IReference reference types},\n * and downgrade the version of the JSON schema to OpenAPI 3.0. It's because\n * OpenAI function call feature cannot understand both reference types and\n * OpenAPI 3.1 specification.\n *\n * Additionally, if you've composed `IOpenAiDocument` with\n * {@link IOpenAiDocument.IOptions.keyword} configuration (as `true`), number of\n * {@link IOpenAiFunction.parameters} are always 1 and the first parameter's type is\n * always {@link IOpenAiSchema.IObject}. The properties' rule is:\n *\n * - `pathParameters`: Path parameters of {@link ISwaggerMigrateRoute.parameters}\n * - `query`: Query parameter of {@link ISwaggerMigrateRoute.query}\n * - `body`: Body parameter of {@link ISwaggerMigrateRoute.body}\n *\n * ```typescript\n * {\n *   ...pathParameters,\n *   query,\n *   body,\n * }\n * ```\n *\n * Otherwise, the parameters would be multiple, and the sequence of the parameters\n * are following below rules:\n *\n * ```typescript\n * [\n *   ...pathParameters,\n *   ...(query ? [query] : []),\n *   ...(body ? [body] : []),\n * ]\n * ```\n */\nexport interface IOpenAiDocument {\n  /**\n   * Version of OpenAPI.\n   *\n   * OpenAI function call schemas are based on OpenAPI 3.0.3.\n   */\n  openapi: \"3.0.3\";\n  /**\n   * List of function metadata.\n   *\n   * List of function metadata that can be used for the OpenAI function call.\n   *\n   * When you want to execute the function with OpenAI constructed arguments,\n   * you can do it through {@link OpenAiFetcher.execute} function.\n   */\n  functions: IOpenAiFunction[];\n  /**\n   * List of errors occurred during the composition.\n   */\n  errors: IOpenAiDocument.IError[];\n  /**\n   * Options for the document.\n   *\n   * Adjusted options when composing the document through {@link OpenAiComposer}.\n   */\n  options: IOpenAiDocument.IOptions;\n}\nexport namespace IOpenAiDocument {\n  /**\n   * Error occurred in the composition.\n   */\n  export interface IError {\n    /**\n     * HTTP method of the endpoint.\n     */\n    method: \"get\" | \"post\" | \"put\" | \"patch\" | \"delete\" | \"head\";\n    /**\n     * Path of the endpoint.\n     */\n    path: string;\n    /**\n     * Error messsages.\n     */\n    messages: string[];\n    /**\n     * Get the Swagger operation metadata.\n     *\n     * Get the Swagger operation metadata, of the source.\n     */\n    operation: () => ISwaggerOperation;\n    /**\n     * Get the migration route metadata.\n     *\n     * Get the migration route metadata, of the source.\n     *\n     * If the property returns `undefined`, it means that the error has been\n     * occured in the migration level, not of OpenAI document composition.\n     *\n     * @returns Migration route metadata.\n     */\n    route: () => ISwaggerMigrateRoute | undefined;\n  }\n  /**\n   * Options for composing the OpenAI document.\n   */\n  export interface IOptions {\n    /**\n     * Whether the parameters are keyworded or not.\n     *\n     * If this property value is `true`, length of the\n     * {@link IOpenAiDocument.IFunction.parameters} is always 1, and type of the\n     * pararameter is always {@link IOpenAiSchema.IObject} type. Also, its\n     * properties are following below rules:\n     *\n     * - `pathParameters`: Path parameters of {@link ISwaggerMigrateRoute.parameters}\n     * - `query`: Query parameter of {@link ISwaggerMigrateRoute.query}\n     * - `body`: Body parameter of {@link ISwaggerMigrateRoute.body}\n     *\n     * ```typescript\n     * {\n     *   ...pathParameters,\n     *   query,\n     *   body,\n     * }\n     * ```\n     *\n     * Otherwise (this property value is `false`), length of the\n     * {@link IOpenAiDocument.IFunction.parameters} is variable, and sequence of the\n     * parameters are following below rules.\n     *\n     * ```typescript\n     * [\n     *   ...pathParameters,\n     *   ...(query ? [query] : []),\n     *   ...(body ? [body] : []),\n     * ]\n     * ```\n     *\n     * @default false\n     */\n    keyword: boolean;\n    /**\n     * Separator function for the parameters.\n     *\n     * When composing parameter arguments through OpenAI function call,\n     * there can be a case that some parameters must be composed by human, or\n     * LLM cannot understand the parameter. For example, if the parameter type\n     * has configured {@link IOpenAiSchema.IString[\"x-wrtn-secret-key\"]}, the\n     * secret key value must be composed by human, not by LLM (Large Language Model).\n     *\n     * In that case, if you configure this property with a function that\n     * predicating whether the schema value must be composed by human or not,\n     * the parameters would be separated into two parts.\n     *\n     * - {@link IOpenAiFunction.separated.llm}\n     * - {@link IOpenAiFunction.separated.human}\n     *\n     * When writing the function, note that returning value `true` means to be\n     * a human composing the value, and `false` means to LLM composing the value.\n     * Also, when predicating the schema, it would better to utilize the\n     * {@link OpenAiTypeChecker} features.\n     *\n     * @param schema Schema to be separated.\n     * @returns Whether the schema value must be composed by human or not.\n     * @default null\n     */\n    separate: null | ((schema: IOpenAiSchema) => boolean);\n  }\n}\n/**\n * OpenAI function metadata.\n *\n * `IOpenAiFunction` is a data structure representing a function,\n * which is provided by Restful API, and used for the OpenAI function call.\n *\n * If you provide this `IOpenAiFunction` instance to the OpenAI, the OpenAI\n * will construct arguments by conversating with the user. Also, you can\n * execute the function call with the OpenAI constructed arguments by using\n * {@link OpenAiFetcher.execute}.\n *\n * For reference, different between `IOpenAiFunction` and its origin source\n * {@link ISwaggerOperation} is, `IOpenAiFunction` has converted every type schema\n * informations from {@link ISwaggerSchema} to {@link IOpenAiSchema} to escape\n * {@link ISwaggerSchema.IReference reference types}, and downgrade the version of\n * the JSON schema to OpenAPI 3.0. It's because OpenAI function call feature cannot\n * understand both reference types and OpenAPI 3.1 specification.\n *\n * Additionally, if you've composed `IOpenAiFunction` with\n * {@link IOpenAiDocument.IOptions.keyword} configuration (as `true`), number of\n * {@link IOpenAiFunction.parameters} are always 1 and the first parameter's type is\n * always {@link IOpenAiSchema.IObject}. The properties' rule is:\n *\n * - `pathParameters`: Path parameters of {@link ISwaggerMigrateRoute.parameters}\n * - `query`: Query parameter of {@link ISwaggerMigrateRoute.query}\n * - `body`: Body parameter of {@link ISwaggerMigrateRoute.body}\n *\n * ```typescript\n * {\n *   ...pathParameters,\n *   query,\n *   body,\n * }\n * ```\n *\n * Otherwise, the parameters would be multiple, and the sequence of the parameters\n * are following below rules:\n *\n * ```typescript\n * [\n *   ...pathParameters,\n *   ...(query ? [query] : []),\n *   ...(body ? [body] : []),\n * ]\n * ```\n */\nexport interface IOpenAiFunction {\n  /**\n   * HTTP method of the endpoint.\n   */\n  method: \"get\" | \"post\" | \"patch\" | \"put\" | \"delete\";\n  /**\n   * Path of the endpoint.\n   */\n  path: string;\n  /**\n   * Representative name of the function.\n   *\n   * The `name` is a repsentative name identifying the function in the\n   * {@link IOpenAiDocument}. The `name` value is just composed by joining the\n   * {@link IMigrateRoute.accessor} by underscore `_` character.\n   *\n   * Here is the composition rule of the  {@link IMigrateRoute.accessor}:\n   *\n   * > The `accessor` is composed with the following rules. At first, namespaces\n   * > are composed by static directory names in the {@link path}. Parametric\n   * > symbols represented by `:param` or `{param}` cannot be a part of the\n   * > namespace.\n   * >\n   * > Instead, they would be a part of the function name. The function\n   * > name is composed with the {@link method HTTP method} and parametric symbols\n   * > like `getByParam` or `postByParam`. If there are multiple path parameters,\n   * > they would be concatenated by `And` like `getByParam1AndParam2`.\n   * >\n   * > For refefence, if the {@link operation}'s {@link method} is `delete`, the\n   * > function name would be replaced to `erase` instead of `delete`. It is\n   * > the reason why the `delete` is a reserved keyword in many programming\n   * > languages.\n   * >\n   * > - Example 1\n   * >   - path: `POST /shopping/sellers/sales`\n   * >   - accessor: `shopping.sellers.sales.post`\n   * > - Example 2\n   * >   - endpoint: `GET /shoppings/sellers/sales/:saleId/reviews/:reviewId/comments/:id\n   * >   - accessor: `shoppings.sellers.sales.reviews.getBySaleIdAndReviewIdAndCommentId`\n   */\n  name: string;\n  /**\n   * Whether the function schema types are strict or not.\n   *\n   * Newly added specification at 2024-08-07.\n   *\n   * @reference https://openai.com/index/introducing-structured-outputs-in-the-api/\n   */\n  strict: true;\n  /**\n   * List of parameter schemas.\n   *\n   * If you've configured {@link IOpenAiDocument.IOptions.keyword} (as `true`),\n   * number of {@link IOpenAiFunction.parameters} are always 1 and the first parameter's\n   * type is always {@link IOpenAiSchema.IObject}. The properties' rule is:\n   *\n   * - `pathParameters`: Path parameters of {@link IMigrateRoute.parameters}\n   * - `query`: Query parameter of {@link IMigrateRoute.query}\n   * - `body`: Body parameter of {@link IMigrateRoute.body}\n   *\n   * ```typescript\n   * {\n   *   ...pathParameters,\n   *   query,\n   *   body,\n   * }\n   * ```\n   *\n   * Otherwise, the parameters would be multiple, and the sequence of the parameters\n   * are following below rules:\n   *\n   * ```typescript\n   * [\n   *   ...pathParameters,\n   *   ...(query ? [query] : []),\n   *   ...(body ? [body] : []),\n   * ]\n   * ```\n   */\n  parameters: IOpenAiSchema[];\n  /**\n   * Collection of separated parameters.\n   *\n   * Filled only when {@link IOpenAiDocument.IOptions.separate} has been configured.\n   */\n  separated?: IOpenAiFunction.ISeparated;\n  /**\n   * Expected return type.\n   *\n   * If the function returns nothing (`void`), then the output is `undefined`.\n   */\n  output?: IOpenAiSchema | undefined;\n  /**\n   * Description of the function.\n   *\n   * Composed by such rule:\n   *\n   * 1. Starts from the {@link OpenApi.IOperation.summary} paragraph.\n   * 2. The next paragraphs are filled with the {@link OpenApi.IOperation.description}.\n   *    By the way, if the first paragraph of {@link OpenApi.IOperation.description} is same\n   *    with the {@link OpenApi.IOperation.summary}, it would not be duplicated.\n   * 3. Parameters' descriptions are added with `@param` tag.\n   * 4. {@link OpenApi.IOperation.security Security requirements} are added with `@security` tag.\n   * 5. Tag names are added with `@tag` tag.\n   * 6. If {@link OpenApi.IOperation.deprecated}, `@deprecated` tag is added.\n   */\n  description?: string;\n  /**\n   * Get the Swagger operation metadata.\n   *\n   * Get the Swagger operation metadata, of the source.\n   *\n   * @returns Swagger operation metadata.\n   */\n  operation: () => ISwaggerOperation;\n  /**\n   * Get the migration route metadata.\n   *\n   * Get the migration route metadata, of the source.\n   *\n   * @returns Migration route metadata.\n   */\n  route: () => ISwaggerMigrateRoute;\n}\nexport namespace IOpenAiFunction {\n  /**\n   * Collection of separated parameters.\n   */\n  export interface ISeparated {\n    /**\n     * Parameters that would be composed by the OpenAI.\n     */\n    llm: ISeparatedParameter[];\n    /**\n     * Parameters that would be composed by the human.\n     */\n    human: ISeparatedParameter[];\n  }\n  /**\n   * Separated parameter.\n   */\n  export interface ISeparatedParameter {\n    /**\n     * Index of the parameter.\n     */\n    index: number;\n    /**\n     * Type schema info of the parameter.\n     */\n    schema: IOpenAiSchema;\n  }\n}\n/**\n * Type schema info of OpenAI function call.\n *\n * `IOpenAiSchema` is a type schema info of OpenAI function call.\n *\n * `IOpenAiSchema` is basically follows the JSON schema definition of\n * OpenAI v3.0: {@link OpenApiV3.IJsonSchema}. However, `IOpenAiSchema` does not\n * have the reference type {@link OpenApiV3.IJsonSchema.IReference}. It's because\n * the OpenAI cannot compose\n * {@link OpenAiFetcher.IProps.arguments function call arguments} of\n * the reference type.\n *\n * For reference, the OpenAPI v3.0 based JSON schema definition can't express\n * the tuple array type. It has been supported since OpenAPI v3.1. Therefore,\n * it would better to avoid using the tuple array type.\n */\nexport type IOpenAiSchema =\n  | IOpenAiSchema.IBoolean\n  | IOpenAiSchema.IInteger\n  | IOpenAiSchema.INumber\n  | IOpenAiSchema.IString\n  | IOpenAiSchema.IArray\n  | IOpenAiSchema.IObject\n  | IOpenAiSchema.IUnknown\n  | IOpenAiSchema.INullOnly\n  | IOpenAiSchema.IOneOf;\nexport namespace IOpenAiSchema {\n  /**\n   * Boolean type schema info.\n   */\n  export interface IBoolean extends __ISignificant<\"boolean\"> {\n    /**\n     * Default value.\n     */\n    default?: boolean;\n    /**\n     * Enumeration values.\n     */\n    enum?: boolean[];\n  }\n  /**\n   * Integer type schema info.\n   */\n  export interface IInteger extends __ISignificant<\"integer\"> {\n    /**\n     * Default value.\n     *\n     * @type int64\n     */\n    default?: number;\n    /**\n     * Enumeration values.\n     *\n     * @type int64\n     */\n    enum?: number[];\n    /**\n     * Minimum value restriction.\n     *\n     * @type int64\n     */\n    minimum?: number;\n    /**\n     * Maximum value restriction.\n     *\n     * @type int64\n     */\n    maximum?: number;\n    /**\n     * Exclusive minimum value restriction.\n     *\n     * For reference, even though your Swagger (or OpenAPI) document has\n     * defined the `exclusiveMinimum` value as `number`, {@link OpenAiComposer}\n     * forcibly converts it to `boolean` type, and assign the numeric value to\n     * the {@link minimum} property.\n     */\n    exclusiveMinimum?: boolean;\n    /**\n     * Exclusive maximum value restriction.\n     *\n     * For reference, even though your Swagger (or OpenAPI) document has\n     * defined the `exclusiveMaximum` value as `number`, {@link OpenAiComposer}\n     * forcibly converts it to `boolean` type, and assign the numeric value to\n     * the {@link maximum} property.\n     */\n    exclusiveMaximum?: boolean;\n    /**\n     * Multiple of value restriction.\n     *\n     * @type uint64\n     * @exclusiveMinimum 0\n     */\n    multipleOf?: number;\n  }\n  /**\n   * Number type schema info.\n   */\n  export interface INumber extends __ISignificant<\"number\"> {\n    /**\n     * Default value.\n     */\n    default?: number;\n    /**\n     * Enumeration values.\n     */\n    enum?: number[];\n    /**\n     * Minimum value restriction.\n     */\n    minimum?: number;\n    /**\n     * Maximum value restriction.\n     */\n    maximum?: number;\n    /**\n     * Exclusive minimum value restriction.\n     *\n     * For reference, even though your Swagger (or OpenAPI) document has\n     * defined the `exclusiveMinimum` value as `number`, {@link OpenAiComposer}\n     * forcibly converts it to `boolean` type, and assign the numeric value to\n     * the {@link minimum} property.\n     */\n    exclusiveMinimum?: boolean;\n    /**\n     * Exclusive maximum value restriction.\n     *\n     * For reference, even though your Swagger (or OpenAPI) document has\n     * defined the `exclusiveMaximum` value as `number`, {@link OpenAiComposer}\n     * forcibly converts it to `boolean` type, and assign the numeric value to\n     * the {@link maximum} property.\n     */\n    exclusiveMaximum?: boolean;\n    /**\n     * Multiple of value restriction.\n     *\n     * @exclusiveMinimum 0\n     */\n    multipleOf?: number;\n  }\n  /**\n   * String type schema info.\n   */\n  export interface IString extends __ISignificant<\"string\"> {\n    /**\n     * Default value.\n     */\n    default?: string;\n    /**\n     * Enumeration values.\n     */\n    enum?: string[];\n    /**\n     * Format restriction.\n     */\n    format?:\n      | \"binary\"\n      | \"byte\"\n      | \"password\"\n      | \"regex\"\n      | \"uuid\"\n      | \"email\"\n      | \"hostname\"\n      | \"idn-email\"\n      | \"idn-hostname\"\n      | \"iri\"\n      | \"iri-reference\"\n      | \"ipv4\"\n      | \"ipv6\"\n      | \"uri\"\n      | \"uri-reference\"\n      | \"uri-template\"\n      | \"url\"\n      | \"date-time\"\n      | \"date\"\n      | \"time\"\n      | \"duration\"\n      | \"json-pointer\"\n      | \"relative-json-pointer\"\n      | (string & {});\n    /**\n     * Pattern restriction.\n     */\n    pattern?: string;\n    /**\n     * Minimum length restriction.\n     *\n     * @type uint64\n     */\n    minLength?: number;\n    /**\n     * Maximum length restriction.\n     *\n     * @type uint64\n     */\n    maxLength?: number;\n    /**\n     * Content media type restriction.\n     */\n    contentMediaType?: string;\n    /**\n     * Secret key for the schema.\n     *\n     * `x-wrtn-secret-key` is a property means a secret key that is required\n     * for the target API endpoint calling. If the secret key is not filled,\n     * the API call would be failed.\n     */\n    \"x-wrtn-secret-key\"?: string;\n    /**\n     * Secret scopes for the schema.\n     *\n     * `x-wrtn-secret-scopes` is a property means a list of secret scopes that\n     * are required for the target API endpoint calling. If the secret scopes\n     * are not satisfied, the API call would be failed.\n     */\n    \"x-wrtn-secret-scopes\"?: string[];\n  }\n  /**\n   * Array type schema info.\n   */\n  export interface IArray extends __ISignificant<\"array\"> {\n    /**\n     * Items type schema info.\n     *\n     * The `items` means the type of the array elements. In other words, it is\n     * the type schema info of the `T` in the TypeScript array type `Array<T>`.\n     */\n    items: IOpenAiSchema;\n    /**\n     * Unique items restriction.\n     *\n     * If this property value is `true`, target array must have unique items.\n     */\n    uniqueItems?: boolean;\n    /**\n     * Minimum items restriction.\n     *\n     * Restriction of minumum number of items in the array.\n     *\n     * @type uint64\n     */\n    minItems?: number;\n    /**\n     * Maximum items restriction.\n     *\n     * Restriction of maximum number of items in the array.\n     *\n     * @type uint64\n     */\n    maxItems?: number;\n  }\n  /**\n   * Object type schema info.\n   */\n  export interface IObject extends __ISignificant<\"object\"> {\n    /**\n     * Properties of the object.\n     *\n     * The `properties` means a list of key-value pairs of the object's\n     * regular properties. The key is the name of the regular property,\n     * and the value is the type schema info.\n     *\n     * If you need additional properties that is represented by dynamic key,\n     * you can use the {@link additionalProperties} instead.\n     */\n    properties?: Record<string, IOpenAiSchema>;\n    /**\n     * List of key values of the required properties.\n     *\n     * The `required` means a list of the key values of the required\n     * {@link properties}. If some property key is not listed in the `required`\n     * list, it means that property is optional. Otherwise some property key\n     * exists in the `required` list, it means that the property must be filled.\n     *\n     * Below is an example of the {@link properties} and `required`.\n     *\n     * ```typescript\n     * interface SomeObject {\n     *   id: string;\n     *   email: string;\n     *   name?: string;\n     * }\n     * ```\n     *\n     * As you can see, `id` and `email` {@link properties} are {@link required},\n     * so that they are listed in the `required` list.\n     *\n     * ```json\n     * {\n     *   \"type\": \"object\",\n     *   \"properties\": {\n     *     \"id\": { \"type\": \"string\" },\n     *     \"email\": { \"type\": \"string\" },\n     *     \"name\": { \"type\": \"string\" }\n     *   },\n     *   \"required\": [\"id\", \"email\"]\n     * }\n     * ```\n     */\n    required?: string[];\n    /**\n     * Additional properties' info.\n     *\n     * The `additionalProperties` means the type schema info of the additional\n     * properties that are not listed in the {@link properties}.\n     *\n     * If the value is `true`, it means that the additional properties are not\n     * restricted. They can be any type. Otherwise, if the value is\n     * {@link IOpenAiSchema} type, it means that the additional properties must\n     * follow the type schema info.\n     *\n     * - `true`: `Record<string, any>`\n     * - `IOpenAiSchema`: `Record<string, T>`\n     */\n    additionalProperties?: boolean | IOpenAiSchema;\n  }\n  /**\n   * Unknown type schema info.\n   *\n   * It means the type of the value is `any`.\n   */\n  export interface IUnknown extends __IAttribute {\n    /**\n     * Type is never be defined.\n     */\n    type?: undefined;\n  }\n  /**\n   * Null only type schema info.\n   */\n  export interface INullOnly extends __IAttribute {\n    /**\n     * Type is always `null`.\n     */\n    type: \"null\";\n  }\n  /**\n   * One of type schema info.\n   *\n   * `IOneOf` represents an union type of the TypeScript (`A | B | C`).\n   *\n   * For reference, even though your Swagger (or OpenAPI) document has\n   * defined `anyOf` instead of the `oneOf`, {@link OpenAiComposer} forcibly\n   * converts it to `oneOf` type.\n   */\n  export interface IOneOf extends __IAttribute {\n    /**\n     * List of the union types.\n     */\n    oneOf: IOpenAiSchema[];\n  }\n  /**\n   * Significant attributes that can be applied to the most types.\n   */\n  export interface __ISignificant<Type extends string> extends __IAttribute {\n    /**\n     * Discriminator value of the type.\n     */\n    type: Type;\n    /**\n     * Whether to allow `null` value or not.\n     */\n    nullable?: boolean;\n  }\n  /**\n   * Common attributes that can be applied to all types.\n   */\n  export interface __IAttribute {\n    /**\n     * Title of the schema.\n     */\n    title?: string;\n    /**\n     * Detailed description of the schema.\n     */\n    description?: string;\n    /**\n     * Whether the type is deprecated or not.\n     */\n    deprecated?: boolean;\n    /**\n     * Placeholder value for frontend application.\n     *\n     * Placeholder means the value to be shown in the input field as a hint.\n     * For example, when an email input field exists, the placeholder value\n     * would be \"Insert your email address here\".\n     */\n    \"x-wrtn-placeholder\"?: string;\n    /**\n     * Prerequisite API endpoint for the schema.\n     *\n     * `x-wrtn-prerequisite` is a property representing the prerequisite API\n     * interaction. It means that, the endpoint API should be called before\n     * calling the target API, for composing some argument value.\n     *\n     * @reference https://github.com/wrtnio/decorators/blob/main/src/Prerequisite.ts\n     */\n    \"x-wrtn-prerequisite\"?: {\n      /**\n       * HTTP method to call the endpoint.\n       */\n      method: \"get\" | \"post\" | \"patch\" | \"put\" | \"delete\";\n      /**\n       * Path of the endpoint.\n       */\n      path: string;\n      /**\n       * Function returning transformed values using JMESPath expression.\n       *\n       * `Prerequisite.Props.jmesPath` is a string typed property that extracts desired values\n       * from the prerequisite API response using a JMESPath expression. This property simplifies\n       * and replaces the `label`, `value`, and `array` properties.\n       *\n       * JMESPath expressions are used to extract the desired data based on the API response.\n       * The expression must always be a valid JMESPath syntax.\n       *\n       * - Type: `jmesPath: string`\n       * - Example: `\"members[*].data.title\"`\n       * - Usage: `jmespath.search(response, jmesPath)`\n       *\n       * Note: The `label`, `value`, and `array` properties are no longer in use.\n       */\n      jmesPath: string;\n    }\n  }\n}\nTransform to the LLM function calling schema.After converting to OpenAPI v3.1 emended specification, and normalizing to the migration schema, we can finally transform to the LLM function calling schema. The LLM function calling schema is a typical RPC (Remote Procedure Call) structure representing a function which has its own name, description, parameters and return value types.About the type schema, it is similar with OpenAPI v3.0 speicified JSON schema, however, it does not have reference type ($ref). Therefore, LLM function calling schema cannot express recursive types, so that only flat structured OpenAPI operation can be transformed to the LLM function schema.Additionally, \"Wrtn Studio Pro\" is separating the parameters of LLM function schema into two parts; Human and LLM. The Human side parameters mean that, the value must be composed by human, not by LLM. For example, secret key value for identifying user or file uploading feature must be composed by Human, and such parameters are separated from the LLM side parameters.","meta-llm-ai-chatbot#Meta LLM (A.I. Chatbot)":"/**\n * Set of functions provided by the Meta LLM server to the client.\n * \n * `IStudioMetaChatService` is an interface that defines the set of functions\n * provided by the **server** to the Meta LLM (Large Language Model) client. The Meta \n * LLM client remotely calls the server's `IStudioMetaChatService` functions through \n * this interface with RPC (Remote Procedure Call) paradigm.\n * \n * Note that the client must call the {@link initialize} function immediately\n * after connecting to the Meta LLM server. If the client tries to skip the\n * {@link initialize} function call and directly call {@link talk}, the function\n * call will fail, so that exception would be thrown.\n */\nexport interface IStudioMetaChatService {\n  /**\n   * Publish/restore/initialize the chat session.\n   * \n   * The client must call this function once after connecting to the Meta LLM\n   * server to publish a new chat session or restore an existing session. If\n   * the client tries to skip the {@link initialize} function call and directly\n   * call {@link talk}, the function call will fail, so that exception would be\n   * thrown.\n   * \n   * Also, the returned session would be a new chat session if the client connected\n   * to the server via the new chat session API, and the existing session would be\n   * restored if the client connected to the server via the continue chat session\n   * API.\n   *\n   * - {@link HubApi.functional.studio.customers.meta.chat.sessions.start}\n   * - {@link HubApi.functional.studio.customers.meta.chat.sessions.restart}\n   */\n  initialize(): Promise<IStudioMetaChatSession>;\n  /**\n   * User talks to Meta LLM.\n   * \n   * A function called by the client to talk to the Meta LLM server.\n   * \n   * @param dialogue Dialogue information\n   */\n  talk(dialogue: IStudioMetaChatDialogue): Promise<void>;\n}\n/**\n * Set of functions provided by the Meta LLM client to the server.\n * \n * `IStudioMetaChatListener` is an interface that defines the set of functions\n * provided by the **client** to the Meta LLM (Large Language Model) server. The Meta \n * LLM server remotely calls the client's `IStudioMetaChatListener` functions through\n * this interface with RPC (Remote Procedure Call) paradigm.\n */\nexport interface IStudioMetaChatListener {\n  /**\n   * Meta LLM server talks to the user.\n   * \n   * A function called by the Meta LLM server to talk to the user.\n   *\n   * @param dialogue Dialogue information\n   */\n  talk(dialogue: IStudioMetaChatDialogue): Promise<void>;\n  /**\n   * Notify the client of the server's listenability.\n   * \n   * The Meta LLM server notifies the client whether it is possible to listen.\n   *  \n   * In other words, this function informs the client whether it can call\n   * {@link IStudioMetaChatService.talk} immediately or not.\n   * \n   * Note that when the client calls the server's RPC function\n   * {@link IStudioMetaChatService.talk}, the value `false` is passed to this\n   * function {@link IStudioMetaChatListener.listenable} immediately. On the\n   * other hand, the value `true` is passed to this function in various cases.\n   *\n   * @param status Listenability status\n   */\n  listenable(status: boolean): Promise<void>;\n  /**\n   * Explain the function call plan.\n   * \n   * The Meta LLM server explains the function call plan to the user.\n   * \n   * The function call plan provided includes a list of functions that LLM\n   * wants to execute in order, and a description of the entire plan and the\n   * purpose of each function call.\n   * \n   * The client can read this and decide whether to proceed with the LLM\n   * function call execution. If `true` is returned, the Meta LLM will call\n   * the functions according to the plan. Otherwise `false` be returned, the plan\n   * would be withdrawn.\n   * \n   * @param plan Function call plan\n   * @returns Whether to proceed with the plan or not\n   */\n  explainFunctionCall(plan: IStudioMetaChatFunctionCallPlan): Promise<boolean>;\n  /**\n   * Select a function to call.\n   * \n   * A function called by the Meta LLM server when LLM (Large Language Model) has\n   * determined the target function to call during the conversation with the user.\n   * \n   * After this function be called, the server will call the {@link fillArguments} \n   * functionns remotely to commpose parameter values, and then call the \n   * {@link completeFunction} function after the function call execution.\n   *\n   * @param props Information of the target function\n   */\n  selectFunction(props: IStudioMetaChatFunctionCall.ISelect): Promise<void>;\n  /**\n   * Fill in the argument of the function call.\n   * \n   * A function called by the Meta LLM server when the user needs to fill in \n   * some of the argument for the LLM function call. For example, when the user\n   * needs to enter an authentication key for a Google account, or upload a file\n   * manually.\n   * \n   * `IStudioMetaFunctionCall.arguments` is a function called when the user needs\n   * to compose some (or all) of the arguments to be used in the function call\n   * directly. The returned value means the value that the client has composed.\n   * \n   * The only cases where the client receives input separately from the server\n   * in our service are as follows:\n   *\n   * - {@link IOpenAiSchema.IString[\"x-wrtn-secret-key\"]}\n   * - {@link IOpenAiSchema.IString.contentMediaType}\n   *\n   * @param props Information of the target function and argument types\n   * @returns The value composed by the client, or rejection by hin/her\n   */\n  fillArgument(\n    props: IStudioMetaChatFunctionCall.IFillArgument,\n  ): Promise<IStudioMetaChatListener.IFillArgumentResult>;\n  /**\n   * Complete the function call.\n   * \n   * A function called by the Meta LLM server to inform the client of the \n   * completion of the LLM function call execution. \n   * \n   * It embodies the `Try<T, E>` structure, so that contains whether the function call \n   * was successful or not. Also, it contains the return value when suceeded, and the\n   * exception information when failed.\n   *\n   * @param props Information of the execution result\n   */\n  completeFunction(props: IStudioMetaChatFunctionCall.IComplete): Promise<void>;\n  /**\n   * Workflow has been prepared.\n   * \n   * A function called by the Meta LLM server when the workflow creation is ready.\n   * Client can decide whether to save the {@link IStudioWorkflow workflow document} \n   * based on the {@link IStudioWorkflowData.ICreate creation information} received \n   * from the server.\n   * \n   * If client returns a {@link IStudioMetaChatWorkflowConfirm} instance in this \n   * function, the server will create the workflow at the specified \n   * {@link IStudioRepository repository} location. Otherwise the client returns\n   * `null`, the server will not create the workflow.\n   *\n   * @param data Workflow creation information\n   * @param plan Workflow configuration plan including detailed descriptions\n   * @returns Whether to create the workflow document or not\n   */\n  prepareWorkflow(\n    data: IStudioWorkflowData.ICreate,\n    plan: IStudioMetaChatWorkflowPlan,\n  ): Promise<IStudioMetaChatWorkflowConfirm | null>;\n  /**\n   * Workflow has been created/updated.\n   * \n   * A function called by the Meta LLM server when an {@link IStudioWorkflow workflow}\n   * has been newly created or updated by the client had returned a non-null value from\n   * the {@link prepareWorkflow} function.\n   * \n   * Whether the server creates or updates the workflow depends on the return value of\n   * the {@link prepareWorkflow} function. If the client orders a new workflow document,\n   * it would be created by the server. Otherwise the client directed the existing\n   * workflow document, it would be updated.\n   * \n   * The provided parameter object is the detailed information of the workflow\n   * {@link IStudioWorkflow} and its location information with {@link IStudioRepository}, \n   * so that the client can check it and enter the workflow editor or provide \n   * a preview image.\n   *\n   * @param workflow Newly created or updated workflow\n   * @param related Account and repository information related to the workflow\n   */\n  completeWorkflow(\n    workflow: IStudioWorkflow,\n    related: Pick<IStudioMetaChatWorkflowConfirm, \"account\" | \"repository\">,\n  ): Promise<void>;\n  /**\n   * Meta LLM server requests the client to terminate.\n   * \n   * When the Meta LLM session suddenly died due to the bug from LLM \n   * (Large Language Model) like OpenAI, the server requests the client to terminate \n   * the connection, and retry it again a little bit later.\n   *\n   * @param error Error from the LLM module\n   */\n  kill(error?: any): Promise<void>;\n}\nimport { IOpenAiFunction, IOpenAiSchema } from \"@wrtnio/openai-function-schema\";\nimport { Primitive, tags } from \"typia\";\nimport { OmitNever } from \"typia/lib/typings/OmitNever\";\nexport namespace IStudioMetaChatFunctionCall {\n  /**\n   * Selection information of the function to call.\n   * \n   * `IStudioMetaChatFunctionCall.ISelect` is an interface that providing metadata\n   * of the target function to call when the Meta LLM server selects a proper function \n   * to call during the conversation with the user.\n   * \n   * In the context of RPC (Remote Procedure Call), this `IStudioMetaChatFunctionCall`\n   * structure is used in the {@link IStudioMetaChatListener.selectFunction} method.\n   * Also after delivering this information. the server will step below sequence:\n   * \n   * 1. {@link IStudioMetaChatListener.fillArgument} to compose Human side parameters\n   * 2. {@link IStudioMetaChatListener.completeFunction} after function call execution\n   */\n  export interface ISelect {\n    /**\n     * Primary Key.\n     */\n    id: string & tags.Format<\"uuid\">;\n    /**\n     * Metadata of the target function to call.\n     */\n    function: OmitNever<Primitive<IOpenAiFunction>>;\n  }\n  /**\n   * Request of arguments filling of Human side parameter.\n   * \n   * `IStudioMetaChatFunctionCall.IFillArgument` is an interface that providing\n   * the request to client for composing some of the arguments of the target\n   * function that must be filled by Human side, intead of LLM (Large Language Model).\n   * \n   * As a case of the values that must be filled by Human side, there are secret key\n   * and file upload. In the context of {@link IOpenAiSchema}, those typed values\n   * must be filled by Human:\n   * \n   * - {@link IOpenAiSchema.IString[\"x-wrtn-secret-key\"]}\n   * - {@link IOpenAiSchema.IString.contentMediaType}\n   */\n  export interface IFillArgument {\n    /**\n     * Identifier of the target function.\n     * \n     * It is same with the {@link IStudioMetaChatFunctionCall.ISelect.id}.\n     */\n    id: string & tags.Format<\"uuid\">;\n    /**\n     * Index of the parameter to fill.\n     */\n    index: number & tags.Type<\"uint32\">;\n    /**\n     * Schema information that must be composed by Human.\n     */\n    schema: IOpenAiSchema;\n    /**\n     * Metadata of the parameter that can be filled by LLM.\n     * \n     * If this value is `null`, it means that the parameter must be filled only by \n     * Human. Otherwise, LLM (Large Language Model) also can fill the parameter value\n     * by analyzing the client's conversation, and Meta LLM merges it with the \n     * Human composed.\n     */\n    llm: null | {\n      /**\n       * SChema information that can be filled by LLM.\n       */\n      schema: IOpenAiSchema;\n      /**\n       * Actual value filled by LLM.\n       */\n      value: any;\n    };\n  }\n  /**\n   * Result of the function call execution.\n   * \n   * `IStudioMetaChatFunctionCall.IComplete` is an interface that providing the\n   * result of the function call execution.\n   * \n   * In the RPC (Remote Procedure Call) context, this `IStudioMetaChatFunctionCall`\n   * structure is used in the {@link IStudioMetaChatListener.completeFunction} method.\n   */\n  export interface IComplete {\n    /**\n     * Primary Key.\n     * \n     * It is same with the {@link IStudioMetaChatFunctionCall.ISelect.id}.\n     */\n    id: string & tags.Format<\"uuid\">;\n    /**\n     * Arguments list used in the function call.\n     */\n    arguments: any[];\n    /**\n     * Whether the function call was successful or not.\n     */\n    success: boolean;\n    /**\n     * Returned value as a result of the function call.\n     * \n     * If the function call has been failed, this value would be exception instance \n     * thrown by the target function.\n     */\n    value: any;\n    /**\n     * Time of the function call start.\n     */\n    created_at: string & tags.Format<\"date-time\">;\n    /**\n     * Time of the function call completion.\n     * \n     * If this value is `null`, it means that the connection to the target function\n     * (API operation) itself has failed. On the other hand, if the connection has been\n     * succeeded but exception has been thrown during the function call, this time\n     * would be the time when the exception has been thrown.\n     */\n    completed_at: null | (string & tags.Format<\"date-time\">);\n    /**\n     * Status of the response.\n     * \n     * The HTTP protocol response status if the connection has been succeeded.\n     * Otherwise the connection has been failed, this value would be `null`.\n     */\n    status: number | null;\n  }\n}\nFunction call execution through remotely procedure calls in WebSocket protocol.\"Wrtn Studio Pro\" is serving Meta LLM (A.I. Chatbot) with WebSocket Protocol. Also, have implemented interaction logic between client and server as RPC (Remote Procedure Call) paradigm. With the RPC paradigm, client can remote call procedures of server provided like its own function, and server also can remotely call procedures of client provided like its own.\nReferences\nRemote Procedure Call\nFeatures > RPC Components\nLearn from Examples > Remote Function Call\nProviders\nIStudioMetaChatService\nIStudioMetaChatListener\nIn such RPC background, \"Wrtn Studio Pro\" has accomplished the LLM function calling A.I. chatbot like below:\nThe Meta LLM starts by client's IStudioMetaChatService.initialize() remotely method calling, so that the chatting session be published (or restored). After that, the client may sends some conversation text to the server by calling IStudioMetaChatService.talk() method. This is the start of every function call execution step.When Meta LLM server listens the client's chatting text, it analyzes the text and predicts whether the conversation indicates a function call or not. If the conversation is suspicious to requesting some action, Meta LLM server finds proper functions to call. If suceeded to find some functions which can accomplish the user's request, Meta LLM makes a function call execution plan, and explains the plan to the client by calling IStudioMetaChatListener.explainFunctionCall() method. If client accepts the plan, so that returns tue value in the method, the Meta LLM server starts the function call execution process.For each functions to call, at first, Meta LLM server delivers the metadata information of the target function to call to the client by calling IStudioMetaChatListener.selectFunction() method. Also, Meta LLM server requests the client to fill parameter arguments. Such request and response would be done by chatting text through IStudioMetaChatService.talk() and IStudioMetaChatListener.talk() methods. Meta LLM analyzes user replied chatting text, and fill arguments of the target function by itself.By the way, some functions may have special arguments that only Human can compose. Secret key and file uploading cases would be such examples. In that case, Meta LLM requests client to fill the Human side arguments by calling IStudioMetaChatListener.fillArgument() method per each parameter argument. In the method, client manually composes the argument through Inspector component, and returns it. Meta LLM merges the Human composed argument with the LLM composed, and executes the function.After the function call execution, Meta LLM server informs the function call result by calling IStudioMetaChatListener.completeFunction() method. Parameter of the method (IStudioMetaChatFunctionCall.IComplete type) contains everything about the function call result, including whether to suceeded or not, and return value from the target function or thrown exception information. If the returned value is simple, Meta LLM server will describe the result as conversation text. Otherwise, client side Meta LLM application may provide a return value viewer to show the result."}},"/tech-specs/meta/migrate":{"title":"Migrate","data":{"concepts#Concepts":"Convert OpenAPI operations to migration schemas.Before converting OpenAPI operations to LLM function calling schemas, \"Wrtn Studio Pro\" transforms the OpenAPI operations to an intermediate structure. The intermediate structure is called migration schema, and normalizes parameters/reponses of the OpenAPI opertion.In other words, the migration schema is called to a helper schema for RPC (Remote Procedure Call) function conversion from OpenAPI operation. By providing noramlized definitions close to the RPC function, \"Wrtn Studio Pro\" can easily convert to the LLM function calling schema from the OpenAPI document.For example, migration schema forces path parameters to have their own names, and combines query/headers to be a single object. Also, separates the response body to success and exceptional cases, and provides a description comment for the RPC function.\nIMigrateDocument\nIMigrateRoute","document#Document":"/**\n * Document of migration.\n *\n * The `IMigrateDocument` interface is a document of migration from\n * {@link OpenAPI.IDocument OpenAPI document} to RPC (Remote Procedure Call)\n * functions; {@link IMigrateRoute}.\n *\n * As the `IMigrateDocument` and {@link IMigrateRoute} have a lot of special\n * stories, when you're developing OpenAPI generator library, please read\n * their descriptions carefully including the description of properties.\n */\nexport interface IMigrateDocument<\n  Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\n  Operation extends OpenApi.IOperation<Schema> = OpenApi.IOperation<Schema>,\n> {\n  /**\n   * List of routes for migration.\n   */\n  routes: IMigrateRoute<Schema, Operation>[];\n  /**\n   * List of errors occurred during the migration.\n   */\n  errors: IMigrateDocument.IError<Operation>[];\n}\nexport namespace IMigrateDocument {\n  /**\n   * Error of migration in the operation level.\n   */\n  export interface IError<\n    Operation extends\n      OpenApi.IOperation<any> = OpenApi.IOperation<OpenApi.IJsonSchema>,\n  > {\n    /**\n     * Target operation causing the error.\n     */\n    operation: () => Operation;\n    /**\n     * Method of the operation.\n     *\n     * If the {@link OpenApi.IOperation.method} is not one of below type\n     * values, the operation would be ignored in the migration process for\n     * the RPC (Remote Procedure Call) function.\n     */\n    method: \"head\" | \"get\" | \"post\" | \"put\" | \"patch\" | \"delete\";\n    /**\n     * Original path from the OpenAPI document.\n     */\n    path: string;\n    /**\n     * List of error messages (reasons).\n     */\n    messages: string[];\n  }\n}\nMigration document contains only two properties.The first property is routes, a list of route schemas that has been succesfully normalized from the OpenAPI operations. The other property is errors, a list of target operation and its error messages occured in the normalization process.For reference, the normalization error means that the target OpenAPI operation is not suitable for the migration process. Here is the list of reasons why the operation could be failed to normalize in the migration process:\nContent type is not supported. Here is the list of supported content types:\nRequest Body\napplication/json\napplication/x-www-form-urlencoded\nmultipart/form-data\ntext/plain\nResponse Body\napplication/json\napplication/x-www-form-urlencoded\ntext/plain\nHeaders or query parameter cannot be combined as an object\nPath parameters is not separated to atomic values\nNumber of path parameters is not matched with the path","route#Route":"import { OpenApi } from \"./OpenApi\";\n/**\n * Route information for migration.\n *\n * The `IMigrateRoute` is a structure representing a route information for\n * OpenAPI generated RPC (Remote Procedure Call) function composed from the\n * {@link OpenApi.IOperation OpenAPI operation}.\n *\n * As the `IMigrateRoute` has a lot of speical stories, when you're developing\n * OpenAPI generator library, please read its description carefully including\n * the description of its properties.\n */\nexport interface IMigrateRoute<\n  Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\n  Operation extends OpenApi.IOperation<Schema> = OpenApi.IOperation<Schema>,\n> {\n  /**\n   * Method of the route.\n   *\n   * If the {@link OpenApi.IOperation.method} is not one of below type\n   * values, the operation would be ignored in the migration process for\n   * the RPC (Remote Procedure Call) function.\n   */\n  method: \"head\" | \"get\" | \"post\" | \"put\" | \"patch\" | \"delete\";\n  /**\n   * Original path from the OpenAPI document.\n   */\n  path: string;\n  /**\n   * Emended path for OpenAPI generator libraries.\n   *\n   * The difference between {@link path} is:\n   *\n   * 1. Path parameters are replaced with `:param` format.\n   * 2. Empty sub-paths are removed.\n   * 3. Do not starts with `/`.\n   */\n  emendedPath: string;\n  /**\n   * Accessor for the route.\n   *\n   * The `accessor` is a list of string values that are representing how to\n   * access to the OpenAPI generated RPC (Remote Procedure Call) function\n   * through namespace(s).\n   *\n   * The `accessor` is composed with the following rules. At first, namespaces\n   * are composed by static directory names in the {@link path}. Parametric\n   * symbols represented by `:param` or `{param}` cannot be a part of the\n   * namespace.\n   *\n   * Instead, they would be a part of the function name. The function\n   * name is composed with the {@link method HTTP method} and parametric symbols\n   * like `getByParam` or `postByParam`. If there are multiple path parameters,\n   * they would be concatenated by `And` like `getByParam1AndParam2`.\n   *\n   * For refefence, if the {@link operation}'s {@link method} is `delete`, the\n   * function name would be replaced to `erase` instead of `delete`. It is\n   * the reason why the `delete` is a reserved keyword in many programming\n   * languages.\n   *\n   * - Example 1\n   *   - path: `POST /shopping/sellers/sales`\n   *   - accessor: `shopping.sellers.sales.post`\n   * - Example 2\n   *   - endpoint: `GET /shoppings/sellers/sales/:saleId/reviews/:reviewId/comments/:id\n   *   - accessor: `shoppings.sellers.sales.reviews.getBySaleIdAndReviewIdAndCommentId`\n   */\n  accessor: string[];\n  /**\n   * List of path parameters.\n   *\n   * Note that, not a list of every parameters, but only path parameters.\n   */\n  parameters: IMigrateRoute.IParameter<Schema>[];\n  /**\n   * Metadata of headers.\n   *\n   * The `headers` property is a metadata of HTTP request headers for RPC function,\n   * including the parameter variable name and schema.\n   *\n   * Also, its {@link IMigrateRoute.IHeaders.schema} is always object or reference\n   * to object. Even though the original {@link OpenApi.IOperation OpenAPI operation}'s\n   * headers are separated to atomic typed properties, the `headers` property forcibly\n   * combines them into a single object type.\n   *\n   * For reference, if the `headers` property has been converted to an object type\n   * forcibly, its property {@link IMigrateRoute.IHeaders.name name} and\n   * {@link IMigrateRoute.IHeaders.key key} are always \"headers\".\n   */\n  headers: IMigrateRoute.IHeaders<Schema> | null;\n  /**\n   * Metadata of query values.\n   *\n   * The `query` property is a metadata of HTTP request query values for RPC function,\n   * including the parameter variable name and schema.\n   *\n   * Also, its {@link IMigrateRoute.IQuery.schema} is always object or reference\n   * to object. Even though the original {@link OpenApi.IOperation OpenAPI operation}'s\n   * query parameters are separated to atomic typed properties, the `query` property\n   * forcibly combines them into a single object type.\n   *\n   * For reference, if the `query` property has been converted to an object type\n   * forcibly, its property {@link IMigrateRoute.IQuery.name name} and\n   * {@link IMigrateRoute.IQuery.key key} are always \"headers\".\n   */\n  query: IMigrateRoute.IQuery<Schema> | null;\n  /**\n   * Metadata of request body.\n   *\n   * The `body` property is a metadata of HTTP request body for RPC function,\n   * including the parameter variable name, content type, and schema.\n   *\n   * If the `body` property is `null`, it means the operation does not require\n   * the request body data.\n   */\n  body: IMigrateRoute.IBody<Schema> | null;\n  /**\n   * Metadata of response body for success case.\n   *\n   * The `success` property is a metadata of HTTP response body for RPC function,\n   * including content type, and schema when status code is `200` or `201`.\n   *\n   * If the `success` property is `null`, it means the operation does not have\n   * the response body data. In other words, the RPC function would return `void`.\n   */\n  success: IMigrateRoute.IBody<Schema> | null;\n  /**\n   * Metadata of response body for exceptional status cases.\n   *\n   * The `exceptions` property is a metadata of HTTP response body for RPC\n   * function, including content type, and schema when status code is not `200`\n   * or `201`.\n   *\n   * The key of the `exceptions` property is the status code. It may be a\n   * stringified number, but sometimes it could be a string like \"default\",\n   * because the OpenAPI document allows the status code to be a string.\n   */\n  exceptions: Record<string, IMigrateRoute.IException<Schema>>;\n  /**\n   * Description comment for the route function.\n   *\n   * The `comment` is a function returning description comment for the\n   * RPC function of OpenAPI generated. The comment is composed with the\n   * following rules:\n   *\n   * 1. Starts from the {@link OpenApi.IOperation.summary} paragraph.\n   * 2. The next paragraphs are filled with {@link OpenApi.IOperation.description}.\n   * 3. Parameter descriptions are added with `@param` tag.\n   * 4. Security requirements are added with `@security` tag.\n   * 5. Tag names are added with `@tag` tag.\n   * 6. If {@link OpenApi.IOperation.deprecated}, `@deprecated` tag is added.\n   */\n  comment: () => string;\n  /**\n   * Original operation from the OpenAPI document.\n   *\n   * The `operation` is a function returning the original\n   * {@link OpenApi.IOperation} from the {@link OpenAPI} document.\n   */\n  operation: () => Operation;\n}\nexport namespace IMigrateRoute {\n  /**\n   * Metadata of path parameter.\n   */\n  export interface IParameter<\n    Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\n  > {\n    /**\n     * Name of the path parameter.\n     */\n    name: string;\n    /**\n     * Key of the path parameter.\n     */\n    key: string;\n    /**\n     * Metadata of path parameter data type.\n     */\n    schema: Schema;\n    /**\n     * Original parameter info from the OpenAPI document.\n     *\n     * The `parameter` is a function returning the original\n     * {@link OpenApi.IOperation.IParameter} from the {@link OpenAPI} document.\n     */\n    parameter: () => OpenApi.IOperation.IParameter<Schema>;\n  }\n  /**\n   * Metadata of headers.\n   */\n  export interface IHeaders<\n    Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\n  > {\n    /**\n     * Name of the headers parameter.\n     */\n    name: string;\n    /**\n     * Key of the headers parameter.\n     */\n    key: string;\n    /**\n     * Metadata of headers data type.\n     */\n    schema: Schema;\n    title: () => string | undefined;\n    description: () => string | undefined;\n    example: () => any | undefined;\n    examples: () => Record<string, any> | undefined;\n  }\n  /**\n   * Metadata of query values.\n   */\n  export interface IQuery<\n    Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\n  > {\n    name: string;\n    key: string;\n    schema: Schema;\n    title: () => string | undefined;\n    description: () => string | undefined;\n    example: () => any | undefined;\n    examples: () => Record<string, any> | undefined;\n  }\n  /**\n   * Metadata of request/response body.\n   */\n  export interface IBody<\n    Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\n  > {\n    /**\n     * Name of the body parameter.\n     */\n    name: string;\n    /**\n     * Key of the body parameter.\n     */\n    key: string;\n    /**\n     * Content type of the body.\n     */\n    type:\n      | \"text/plain\"\n      | \"application/json\"\n      | \"application/x-www-form-urlencoded\"\n      | \"multipart/form-data\";\n    /**\n     * Metadata of response body data type.\n     */\n    schema: Schema;\n    /**\n     * Description comment for the request/response body.\n     */\n    description: () => string | undefined;\n    /**\n     * Media type of the request/response body.\n     */\n    media: () => OpenApi.IOperation.IMediaType<Schema>;\n    /**\n     * Whether the body is encrypted or not.\n     */\n    \"x-nestia-encrypted\"?: boolean;\n  }\n  /**\n   * Metadata of response body for exceptional status cases.\n   */\n  export interface IException<\n    Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\n  > {\n    /**\n     * Metadata of response body data type.\n     */\n    schema: Schema;\n    /**\n     * Description comment for the exception.\n     */\n    response: () => OpenApi.IOperation.IResponse<Schema>;\n    /**\n     * Media type of the response body.\n     */\n    media: () => OpenApi.IOperation.IMediaType<Schema>;\n  }\n}","description-comment#Description Comment":"When transforming OpenAPI operation to migration schema, description is composed by follwing rules.For reference, the description comment is very important to teach the purpose of the OpenAPI operation to the LLM (Large Language Model), and LLM actually determines which operation to call by the description. Therefore, the description has the highest priority.\nStarts from the summary paragraph of the OpenAPI operation.\nThe next paragraphs are filled with the OpenApi.IOperation.description. By the way, if the first paragraph of description is same with the summary, it would not be duplicated.\nParameters' descriptions are added with @param tag.\nSecurity requirements (OpenApi.IOperation.security) are added with @security tag.\nTag names are added with @tag tag.\nIf OpenApi.IOperation.deprecated, @deprecated tag is added.","path-parameters#Path Parameters":"export interface IMigrateRoute<\n  Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\n  Operation extends OpenApi.IOperation<Schema> = OpenApi.IOperation<Schema>,\n> {\n  /**\n   * List of path parameters.\n   *\n   * Note that, not a list of every parameters, but only path parameters.\n   */\n  parameters: IMigrateRoute.IParameter<Schema>[];\n}\nexport namespace IMigrateRoute {\n  /**\n   * Metadata of path parameter.\n   */\n  export interface IParameter<\n    Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\n  > {\n    /**\n     * Name of the path parameter.\n     */\n    name: string;\n    /**\n     * Key of the path parameter.\n     */\n    key: string;\n    /**\n     * Metadata of path parameter data type.\n     */\n    schema: Schema;\n    /**\n     * Original parameter info from the OpenAPI document.\n     *\n     * The `parameter` is a function returning the original\n     * {@link OpenApi.IOperation.IParameter} from the {@link OpenAPI} document.\n     */\n    parameter: () => OpenApi.IOperation.IParameter<Schema>;\n  }\n}\nexport namespace OpenApi {\n  export namespace IOperation {\n    /**\n     * Parameter of the operation.\n     */\n    export interface IParameter<Schema extends IJsonSchema = IJsonSchema> {\n      /**\n       * Representative name of the parameter.\n       *\n       * In the most case, the `name` is equivalent to parameter variable name.\n       * Therefore, the `name` must be filled with the significant variable name\n       * of the parameter.\n       *\n       * By the way, only when the {@link in} property is `path`, the `name`\n       * can be omitted. In that case, the `name` is automatically deduced from\n       * the URL path's positional template argument analyzing.\n       */\n      name?: string;\n      /**\n       * Location of the parameter.\n       *\n       * The `in` property is a string that determines the location of the parameter.\n       *\n       * - `path`: parameter is part of the path of the URL.\n       * - `query`: parameter is part of the query string.\n       * - `header`: parameter is part of the header.\n       * - `cookie`: parameter is part of the cookie.\n       */\n      in: \"path\" | \"query\" | \"header\" | \"cookie\";\n      /**\n       * Type info of the parameter.\n       */\n      schema: Schema;\n      /**\n       * Whether the parameter is required for execution or not.\n       *\n       * If the parameter is required, the value must be filled. Otherwise,\n       * it is possible to skip the parameter when executing the APi operation.\n       *\n       * For reference, the `required` property must be always `true` when the\n       * {@link in} property is `path`. Otherwise, the `required` property can\n       * be anything of them; `true`, `false` and `undefined`.\n       */\n      required?: boolean;\n      /**\n       * Short title of the parameter.\n       */\n      title?: string;\n      /**\n       * Verbose explanation of the parameter.\n       */\n      description?: string;\n      /**\n       * Example value of the parameter.\n       */\n      example?: any;\n      /**\n       * Collection of example values of the parameter with keys.\n       */\n      examples?: Record<string, IExample>;\n    }\n  }\n}\nNaming emension.Following the OpenAPI specification, it is possible to omit the path parameter name (IOpenApi.IOperation.IParameter.name) in the operation schema. Furthermore, it is possible to configuring the path parameter to be optional (IOpenApi.IOperation.IParameter.required).However, as the migration schema has been designed for conversion to the RPC (Remote Procedure Call) function implementation, the parameter name must be. Also, considerinng the aspects of the RestAPI, path parameter cannot be optional.Considering such aspects, the migration process forces the path parameter to have its own name and to be required. If the OpenApi.IOperation.IParameter.name is not defined, the migration process automatically deduces the name from the URL path's positional template argument analyzing.In the same reason, if path parameter name and actual operation's path is not matched, the migration process will emend the path parameter name by referencing the sequence of the path parameter in the URL path. Also, if path parameter name is out of variable name scope in the programming language, migration process also emends it to be a valid variable name.","headers-and-query#Headers and Query":"export interface IMigrateRoute<\n  Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\n  Operation extends OpenApi.IOperation<Schema> = OpenApi.IOperation<Schema>,\n> {\n  /**\n   * Metadata of headers.\n   *\n   * The `headers` property is a metadata of HTTP request headers for RPC function,\n   * including the parameter variable name and schema.\n   *\n   * Also, its {@link IMigrateRoute.IHeaders.schema} is always object or reference\n   * to object. Even though the original {@link OpenApi.IOperation OpenAPI operation}'s\n   * headers are separated to atomic typed properties, the `headers` property forcibly\n   * combines them into a single object type.\n   *\n   * For reference, if the `headers` property has been converted to an object type\n   * forcibly, its property {@link IMigrateRoute.IHeaders.name name} and\n   * {@link IMigrateRoute.IHeaders.key key} are always \"headers\".\n   */\n  headers: IMigrateRoute.IHeaders<Schema> | null;\n  /**\n   * Metadata of query values.\n   *\n   * The `query` property is a metadata of HTTP request query values for RPC function,\n   * including the parameter variable name and schema.\n   *\n   * Also, its {@link IMigrateRoute.IQuery.schema} is always object or reference\n   * to object. Even though the original {@link OpenApi.IOperation OpenAPI operation}'s\n   * query parameters are separated to atomic typed properties, the `query` property\n   * forcibly combines them into a single object type.\n   *\n   * For reference, if the `query` property has been converted to an object type\n   * forcibly, its property {@link IMigrateRoute.IQuery.name name} and\n   * {@link IMigrateRoute.IQuery.key key} are always \"headers\".\n   */\n  query: IMigrateRoute.IQuery<Schema> | null;\n}\nexport namespace IMigrateRoute {\n  /**\n   * Metadata of headers.\n   */\n  export interface IHeaders<\n    Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\n  > {\n    /**\n     * Name of the headers parameter.\n     */\n    name: string;\n    /**\n     * Key of the headers parameter.\n     */\n    key: string;\n    /**\n     * Metadata of headers data type.\n     */\n    schema: Schema;\n    title: () => string | undefined;\n    description: () => string | undefined;\n    example: () => any | undefined;\n    examples: () => Record<string, any> | undefined;\n  }\n  /**\n   * Metadata of query values.\n   */\n  export interface IQuery<\n    Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\n  > {\n    name: string;\n    key: string;\n    schema: Schema;\n    title: () => string | undefined;\n    description: () => string | undefined;\n    example: () => any | undefined;\n    examples: () => Record<string, any> | undefined;\n  }\n}\nexport namespace OpenApi {\n  export namespace IOperation {\n    /**\n     * Parameter of the operation.\n     */\n    export interface IParameter<Schema extends IJsonSchema = IJsonSchema> {\n      /**\n       * Representative name of the parameter.\n       *\n       * In the most case, the `name` is equivalent to parameter variable name.\n       * Therefore, the `name` must be filled with the significant variable name\n       * of the parameter.\n       *\n       * By the way, only when the {@link in} property is `path`, the `name`\n       * can be omitted. In that case, the `name` is automatically deduced from\n       * the URL path's positional template argument analyzing.\n       */\n      name?: string;\n      /**\n       * Location of the parameter.\n       *\n       * The `in` property is a string that determines the location of the parameter.\n       *\n       * - `path`: parameter is part of the path of the URL.\n       * - `query`: parameter is part of the query string.\n       * - `header`: parameter is part of the header.\n       * - `cookie`: parameter is part of the cookie.\n       */\n      in: \"path\" | \"query\" | \"header\" | \"cookie\";\n      /**\n       * Type info of the parameter.\n       */\n      schema: Schema;\n      /**\n       * Whether the parameter is required for execution or not.\n       *\n       * If the parameter is required, the value must be filled. Otherwise,\n       * it is possible to skip the parameter when executing the APi operation.\n       *\n       * For reference, the `required` property must be always `true` when the\n       * {@link in} property is `path`. Otherwise, the `required` property can\n       * be anything of them; `true`, `false` and `undefined`.\n       */\n      required?: boolean;\n      /**\n       * Short title of the parameter.\n       */\n      title?: string;\n      /**\n       * Verbose explanation of the parameter.\n       */\n      description?: string;\n      /**\n       * Example value of the parameter.\n       */\n      example?: any;\n      /**\n       * Collection of example values of the parameter with keys.\n       */\n      examples?: Record<string, IExample>;\n    }\n  }\n}\nTo be a single object.Considering the HTTP specification of headers and query parameters, they are always a key-value paired object. However, in the OpenAPI specification, it is possible to define headers and query parameters as separated parameters with their property names.In the migration process, the headers and query parameters are forcibly combined to be a single object. Their object casted name is always \"headers\" and \"query\" respectively, and archived into the IMigrateRoute.headers and IMigrateRoute.query properties.If no headers or query parameters in the OpenAPI operation, these properties would be null.","requestresponse-body#Request/Response Body":"export interface IMigrateRoute<\n  Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\n  Operation extends OpenApi.IOperation<Schema> = OpenApi.IOperation<Schema>,\n> {\n  /**\n   * Metadata of request body.\n   *\n   * The `body` property is a metadata of HTTP request body for RPC function,\n   * including the parameter variable name, content type, and schema.\n   *\n   * If the `body` property is `null`, it means the operation does not require\n   * the request body data.\n   */\n  body: IMigrateRoute.IBody<Schema> | null;\n  /**\n   * Metadata of response body for success case.\n   *\n   * The `success` property is a metadata of HTTP response body for RPC function,\n   * including content type, and schema when status code is `200` or `201`.\n   *\n   * If the `success` property is `null`, it means the operation does not have\n   * the response body data. In other words, the RPC function would return `void`.\n   */\n  success: IMigrateRoute.IBody<Schema> | null;\n  /**\n   * Metadata of response body for exceptional status cases.\n   *\n   * The `exceptions` property is a metadata of HTTP response body for RPC\n   * function, including content type, and schema when status code is not `200`\n   * or `201`.\n   *\n   * The key of the `exceptions` property is the status code. It may be a\n   * stringified number, but sometimes it could be a string like \"default\",\n   * because the OpenAPI document allows the status code to be a string.\n   */\n  exceptions: Record<string, IMigrateRoute.IException<Schema>>;\n}\nexport namespace IMigrateRoute {\n  /**\n   * Metadata of request/response body.\n   */\n  export interface IBody<\n    Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\n  > {\n    /**\n     * Name of the body parameter.\n     */\n    name: string;\n    /**\n     * Key of the body parameter.\n     */\n    key: string;\n    /**\n     * Content type of the body.\n     */\n    type:\n      | \"text/plain\"\n      | \"application/json\"\n      | \"application/x-www-form-urlencoded\"\n      | \"multipart/form-data\";\n    /**\n     * Metadata of response body data type.\n     */\n    schema: Schema;\n    /**\n     * Description comment for the request/response body.\n     */\n    description: () => string | undefined;\n    /**\n     * Media type of the request/response body.\n     */\n    media: () => OpenApi.IOperation.IMediaType<Schema>;\n    /**\n     * Whether the body is encrypted or not.\n     */\n    \"x-nestia-encrypted\"?: boolean;\n  }\n  /**\n   * Metadata of response body for exceptional status cases.\n   */\n  export interface IException<\n    Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\n  > {\n    /**\n     * Metadata of response body data type.\n     */\n    schema: Schema;\n    /**\n     * Description comment for the exception.\n     */\n    response: () => OpenApi.IOperation.IResponse<Schema>;\n    /**\n     * Media type of the response body.\n     */\n    media: () => OpenApi.IOperation.IMediaType<Schema>;\n  }\n}\nexport namespace OpenApi {\n  export interface IOperation<Schema extends IJsonSchema = IJsonSchema> {\n    /**\n     * The request body applicable for this operation.\n     */\n    requestBody?: IOperation.IRequestBody<Schema>;\n    /**\n     * The list of possible responses as they are returned from executing this\n     * operation. Its key is the HTTP status code, and the value is the metadata of\n     * the response in the HTTP status code.\n     */\n    responses?: Record<string, IOperation.IResponse<Schema>>;\n  }\n  export namespace IOperation {\n    /**\n     * Request body of the operation.\n     */\n    export interface IRequestBody<Schema extends IJsonSchema = IJsonSchema> {\n      content?: IContent<Schema>;\n      description?: string;\n      required?: boolean;\n      \"x-nestia-encrypted\"?: boolean;\n    }\n    /**\n     * Response of the operation.\n     */\n    export interface IResponse<Schema extends IJsonSchema = IJsonSchema> {\n      headers?: Record<string, IOperation.IParameter<Schema>>;\n      content?: IContent<Schema>;\n      description?: string;\n      \"x-nestia-encrypted\"?: boolean;\n    }\n    /**\n     * List of content types supported in request/response body.\n     */\n    export interface IContent<Schema extends IJsonSchema = IJsonSchema>\n      extends Partial<Record<ContentType, IMediaType<Schema>>> {}\n    /**\n     * Media type of a request/response body.\n     */\n    export interface IMediaType<Schema extends IJsonSchema = IJsonSchema> {\n      schema?: Schema;\n      example?: any;\n      examples?: Record<string, IExample>;\n    }\n    /**\n     * List of supported content media types.\n     */\n    export type ContentType =\n      | \"text/plain\"\n      | \"application/json\"\n      | \"application/x-www-form-url-encoded\"\n      | \"multipart/form-data\"\n      | \"*/*\"\n      | (string & {});\n  }\n}\nTo normalize the OpenAPI operation to be function like structure, the migration process separates the response body to success and exceptional cases. Also, remains only one representative content type for the request and response body.The distinction between the successive return type and exception throwing comes from its status code. For the \"POST\" HTTP method, \"201\" status code directs the return type, and the other status codes mean failures. For other HTTP methods, 200 status code means the success.If your HTTP operation does not follow the standard status code specification, I'm sorry but there is no way. Justturn back with the standard specification following.","accessor#Accessor":"export interface IMigrateRoute<\n  Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\n  Operation extends OpenApi.IOperation<Schema> = OpenApi.IOperation<Schema>,\n> {\n  /**\n   * Accessor for the route.\n   *\n   * The `accessor` is a list of string values that are representing how to\n   * access to the OpenAPI generated RPC (Remote Procedure Call) function\n   * through namespace(s).\n   *\n   * The `accessor` is composed with the following rules. At first, namespaces\n   * are composed by static directory names in the {@link path}. Parametric\n   * symbols represented by `:param` or `{param}` cannot be a part of the\n   * namespace.\n   *\n   * Instead, they would be a part of the function name. The function\n   * name is composed with the {@link method HTTP method} and parametric symbols\n   * like `getByParam` or `postByParam`. If there are multiple path parameters,\n   * they would be concatenated by `And` like `getByParam1AndParam2`.\n   *\n   * For refefence, if the {@link operation}'s {@link method} is `delete`, the\n   * function name would be replaced to `erase` instead of `delete`. It is\n   * the reason why the `delete` is a reserved keyword in many programming\n   * languages.\n   *\n   * - Example 1\n   *   - path: `POST /shopping/sellers/sales`\n   *   - accessor: `shopping.sellers.sales.post`\n   * - Example 2\n   *   - endpoint: `GET /shoppings/sellers/sales/:saleId/reviews/:reviewId/comments/:id\n   *   - accessor: `shoppings.sellers.sales.reviews.getBySaleIdAndReviewIdAndCommentId`\n   */\n  accessor: string[];\n}\nNamespace composition for RPC function conversion.IMigrateRoute.accessor is a list of string values that are representing how to access to the OpenAPI generated RPC (Remote Procedure Call) function through namespace(s). The namespace is composed by static directory names in the API path. If the API path contains parametric symbols like :param or {param}, they would be excluded from the namespace composition.By the way, as IMigrateRoute has been desinged to help conversion from OpenAPI operation to RPC (Remote Procedure Call) function  and the accessor property represents namespace of the RPC function, every string values in the accessor array are valid variable name in the programming language. If the OpenAPI defined path parameter names are not suitable for the variable name, the migration process replaces the parameter names to be a valid variable name."}},"/tech-specs/meta/preface":{"title":"Preface","data":{"ai-chatbot#A.I. Chatbot":"\"Wrtn Studio Pro\" provides an A.I. chatbot service called \"Meta LLM\".The \"Meta LLM\" utilizes LLM (Large Language Model) function calling, and the functions come from the API marketplace sales which is following the OpenAPI specification. Also, when user wants to automate his/her chatting scenario as an automated program, \"Wrtn Studio Pro\" builds it a program function through the Workflow Compiler with SWL language.By the way, LLM function calling schema appears similar to the OpenAPI specification at first glance, but in reality the specifications are quite different. In such reason, \"Wrtn Studio Pro\" has a process of converting OpenAPI to LLM function calling schema, and at this time, it goes through an intermediate conversion process called Migration Schema.Also, \"Wrtn Studio Pro\" has adopted WebSocket protocol when developing the A.I. chatbot service. If explain the WebSocket protocol related story more detaily, \"Wrtn Studio Pro\" has adopted the RPC (Remote Procedure Call) paradigm. It is a structure in which the client and server participating in the chatbot remotely call the functions provided by each other.At last, when performing function call execution in the \"Meta LLM\", \"Wrtn Studio Pro\" separates the parameter arguments composition to both Humand and LLM sides. It's because some arguments must be composed by Human like file uploading or secret key identification.\nLLM Function CallingLLM selects proper function and fill arguments.In nowadays, most LLM (Large Language Model) like OpenAI are supporting \"function calling\" feature. The \"function calling\" means that LLM automatically selects a proper function and compose parameter values from the user's chatting text.https://platform.openai.com/docs/guides/function-calling","migration-schema#Migration Schema":"Intermediate structure for LLM function calling schema conversion.LLM function calling schema is different with OpenAPi specification. Therefore, \"Wrtn Studio Pro\" must convert the OpenAPI spefification to the LLM function calling schema. However, the conversion process is not direct, but through the intermediate structure called \"Migration Schema\".Purpose of the Migration Schema is to normalize parameters and responses of the OpenAPI operation. By providing the normalized definitions close to the RPC (Remote Procedure Call) function, \"Wrtn Studio Pro\" can safely convert to the LLM function calling schema from the OpenAPI document.\nIMigrateDocument\nIMigrateRoute","llm-schema#LLM Schema":"\"Wrtn Studio Pro\" has defined full specification of the LLM function calling schema.It has been converted from the OpenAPI specification bypass the migration process. The OpenAI function calling schema forms a RPC (Remote Procedure Call) structure that can be directly executed by the Meta LLM.Its type schema information is similar with OpenAPI v3.0 specification, but reference type does not exist. Therefore, if there's a recursive referrence type exists in an OpenAPI operation, the operation cannot be converted to the LLM function calling schema.Also, IOpenAiFunction's parameters are separated to two parts; Human and LLM. The Human part is composed by the user's input, and the LLM part is composed by the Meta LLM's output. The reason of such separation is, some parameter values must be composed by Human like file uploading or secret key identification.\nIOpenAiDocument\nIOpenAiFunction\nIOpenAiSchema","websocket-rpc#WebSocket RPC":"WebSocket protocol with RPC paradigm.\"Wrnt Studio Pro\" has adopted WebSocket protocol for the A.I. chatbot service. Also, accepting the WebSocket protocol, \"Wrtn Studio Pro\" is following the RPC (Remote Procedure Call) paradigm. By the RPC paradigm, the client and server participating in the A.I. chatbot are possible to remotely call the functions provided by each other.In the business logic level, the Meta LLM WebSocket server is providing IStudioMetaChatService interface to the client, so that client can remotely call and get return values from the IStudioMetaChatService instance composed by the server. Also, the client is providing IStudioMetaChatListener instance and many LLM function call executions are performed with it.\nRPC (Remote Procedure Call)\nIStudioMetaChatService\nIStudioMetaChatListener","function-call-execution#Function Call Execution":"Function call execution process.The function call execution is processed by utilizing every skills listed up to now, including WebSocket protocol with RPC (Remote Procedure Call) paradigm and function call arguments filling by both Human and LLM (Large Language Model) sides.When the Meta LLM service has been started and it has delivered function calling schemas to the LLM (Large Language Model), the conversation with Human and LLM begins and LLM sometimes selects a function to call, and then the function call execution story begins.\nUser talks something by chatting text.\nLLM analyzes the user text content.\nLLM selects a function, and server informs it to the client.\nLLM requests Human to type the arguments by chatting text\nUser fills the arguments by chatting text.\nServer requests clients to fill the Human side arguments.\nHuman fills the arguments by UI component (inspector).\nServer executes the function and informs the result."}},"/tech-specs/meta/schema":{"title":"Schema","data":{"summary#Summary":"Full specification of the LLM function calling schema.You know what? In nowadays, most LLM (Large Language Model) like OpenAI are supporting \"function calling\" feature, and the \"function calling\" means that LLM automatically selects a proper function and compose parameter values from the user's chatting text.\"Wrtn Studio Pro\" has defined full specification of such LLM function calling schema, which is converted from the OpenAPI specification bypass the migration process. The function calling schema embodies an RPC (Remote Procedure Call) structure which can be directly executed by the Meta LLM, and contains metadata information for the function call such as function name description.\nOpenAI function calling guide: https://platform.openai.com/docs/guides/function-calling\nSchema definitions:\nIOpenAiDocument\nIOpenAiFunction\nIOpenAiSchema","document#Document":"/**\n * Document of OpenAI function call metadata.\n *\n * `IOpenAiDocument` is a data structure representing content of\n * {@link IOpenAiDocument.functions OpenAI function call metadata}, composed by\n * {@link OpenAiComposer} from the {@link ISwagger} document, with\n * {@link IOpenAiDocument.errors} and adjusted {@link IOpenAiDocument.options}.\n *\n * The different between `IOpenAiDocument` and its origin source {@link ISwagger}\n * is, `IOpenAiDocument` has converted every {@link ISwaggerOperation API endpoints}\n * to {@link IOpenAiFunction function metadata}. You can execute the function call\n * with OpenAI constructed arguments by using the {@link OpenAiFetcher.execute}\n * function with the function metadata.\n *\n * Also, every type schema informations are casted from {@link ISwaggerSchema} to\n * {@link IOpenAiSchema} to escape {@link ISwaggerSchema.IReference reference types},\n * and downgrade the version of the JSON schema to OpenAPI 3.0. It's because\n * OpenAI function call feature cannot understand both reference types and\n * OpenAPI 3.1 specification.\n *\n * Additionally, if you've composed `IOpenAiDocument` with\n * {@link IOpenAiDocument.IOptions.keyword} configuration (as `true`), number of\n * {@link IOpenAiFunction.parameters} are always 1 and the first parameter's type is\n * always {@link IOpenAiSchema.IObject}. The properties' rule is:\n *\n * - `pathParameters`: Path parameters of {@link ISwaggerMigrateRoute.parameters}\n * - `query`: Query parameter of {@link ISwaggerMigrateRoute.query}\n * - `body`: Body parameter of {@link ISwaggerMigrateRoute.body}\n *\n * ```typescript\n * {\n *   ...pathParameters,\n *   query,\n *   body,\n * }\n * ```\n *\n * Otherwise, the parameters would be multiple, and the sequence of the parameters\n * are following below rules:\n *\n * ```typescript\n * [\n *   ...pathParameters,\n *   ...(query ? [query] : []),\n *   ...(body ? [body] : []),\n * ]\n * ```\n */\nexport interface IOpenAiDocument {\n  /**\n   * Version of OpenAPI.\n   *\n   * OpenAI function call schemas are based on OpenAPI 3.0.3.\n   */\n  openapi: \"3.0.3\";\n  /**\n   * List of function metadata.\n   *\n   * List of function metadata that can be used for the OpenAI function call.\n   *\n   * When you want to execute the function with OpenAI constructed arguments,\n   * you can do it through {@link OpenAiFetcher.execute} function.\n   */\n  functions: IOpenAiFunction[];\n  /**\n   * List of errors occurred during the composition.\n   */\n  errors: IOpenAiDocument.IError[];\n  /**\n   * Options for the document.\n   *\n   * Adjusted options when composing the document through {@link OpenAiComposer}.\n   */\n  options: IOpenAiDocument.IOptions;\n}\nexport namespace IOpenAiDocument {\n  /**\n   * Error occurred in the composition.\n   */\n  export interface IError {\n    /**\n     * HTTP method of the endpoint.\n     */\n    method: \"get\" | \"post\" | \"put\" | \"patch\" | \"delete\" | \"head\";\n    /**\n     * Path of the endpoint.\n     */\n    path: string;\n    /**\n     * Error messsages.\n     */\n    messages: string[];\n    /**\n     * Get the Swagger operation metadata.\n     *\n     * Get the Swagger operation metadata, of the source.\n     */\n    operation: () => ISwaggerOperation;\n    /**\n     * Get the migration route metadata.\n     *\n     * Get the migration route metadata, of the source.\n     *\n     * If the property returns `undefined`, it means that the error has been\n     * occured in the migration level, not of OpenAI document composition.\n     *\n     * @returns Migration route metadata.\n     */\n    route: () => ISwaggerMigrateRoute | undefined;\n  }\n  /**\n   * Options for composing the OpenAI document.\n   */\n  export interface IOptions {\n    /**\n     * Whether the parameters are keyworded or not.\n     *\n     * If this property value is `true`, length of the\n     * {@link IOpenAiDocument.IFunction.parameters} is always 1, and type of the\n     * pararameter is always {@link IOpenAiSchema.IObject} type. Also, its\n     * properties are following below rules:\n     *\n     * - `pathParameters`: Path parameters of {@link ISwaggerMigrateRoute.parameters}\n     * - `query`: Query parameter of {@link ISwaggerMigrateRoute.query}\n     * - `body`: Body parameter of {@link ISwaggerMigrateRoute.body}\n     *\n     * ```typescript\n     * {\n     *   ...pathParameters,\n     *   query,\n     *   body,\n     * }\n     * ```\n     *\n     * Otherwise (this property value is `false`), length of the\n     * {@link IOpenAiDocument.IFunction.parameters} is variable, and sequence of the\n     * parameters are following below rules.\n     *\n     * ```typescript\n     * [\n     *   ...pathParameters,\n     *   ...(query ? [query] : []),\n     *   ...(body ? [body] : []),\n     * ]\n     * ```\n     *\n     * @default false\n     */\n    keyword: boolean;\n    /**\n     * Separator function for the parameters.\n     *\n     * When composing parameter arguments through OpenAI function call,\n     * there can be a case that some parameters must be composed by human, or\n     * LLM cannot understand the parameter. For example, if the parameter type\n     * has configured {@link IOpenAiSchema.IString[\"x-wrtn-secret-key\"]}, the\n     * secret key value must be composed by human, not by LLM (Large Language Model).\n     *\n     * In that case, if you configure this property with a function that\n     * predicating whether the schema value must be composed by human or not,\n     * the parameters would be separated into two parts.\n     *\n     * - {@link IOpenAiFunction.separated.llm}\n     * - {@link IOpenAiFunction.separated.human}\n     *\n     * When writing the function, note that returning value `true` means to be\n     * a human composing the value, and `false` means to LLM composing the value.\n     * Also, when predicating the schema, it would better to utilize the\n     * {@link OpenAiTypeChecker} features.\n     *\n     * @param schema Schema to be separated.\n     * @returns Whether the schema value must be composed by human or not.\n     * @default null\n     */\n    separate: null | ((schema: IOpenAiSchema) => boolean);\n  }\n}\nDocument of OpenAI function call metadata.IOpenAiDocument is a data structure collecting the OpenAI function calling schemas, and stores the options that has been adjusted for the OpenAPI document to OpenAI document conversion. Also, it contains error messages occured during the composition.For reference, the conversion error occured only when the target API operation (OpenApi.IOperation) has a recursive type. LLM function calling schema is utilizing JSON schema of OpenAPI v3.0 specification, but it does not support the reference type ($ref). Therefore, if recursive type comes, no way to express it, so that the error occurs and stored to the IOpenAiDocument.errors array.About the options, there're two configurations; keyword and separate.The keyword means that gathering every parameters into only one single object with property key name/valur pairs. It has been designed for some Large Language Models which are performing the function calling much better than the multiple parameters case.The other option separate is for separating the parameters to two parts; one is for LLM composing, and the other is for Human composing. It's useful when some parameters must be composed by human, like file uploading or secret key value cases.","function#Function":"export interface IOpenAiFunction {\n  method: \"get\" | \"post\" | \"patch\" | \"put\" | \"delete\";\n  path: string;\n  name: string;\n  strict: true;\n  parameters: IOpenAiSchema[];\n  separated?: IOpenAiFunction.ISeparated;\n  output?: IOpenAiSchema | undefined;\n  description?: string | undefined;\n  operation: () => ISwaggerOperation;\n  route: () => ISwaggerMigrateRoute;\n}\nexport namespace IOpenAiFunction {\n  export interface ISeparated {\n    llm: ISeparatedParameter[];\n    human: ISeparatedParameter[];\n  }\n  export interface ISeparatedParameter {\n    index: number;\n    schema: IOpenAiSchema;\n  }\n}\nFunction schema for LLM function call.IOpenAiFunction is a data structure representing a function, which is provided by and converted from the Restful API (OpenApi.IOperation), and be used for the LLM (Large Language Model) function calling. It's a typical RPC (Remote Procedure Call) function structure that containing the function name, parameters and return types.About the type information, LLM function calling schema has daopted the JSON schema of OpenAPI v3.0 specification. However, its detailed specification is a little bit different with the original JSON schema. The difference is between regular JSON schema and of LLMis, LLM excludes the reference type ($ref).Therefore, if there's a function (Restful API operation) which has recursive type, it can't be used in the LLM (Large Language Model) function calling. AS the target OpenApi.IOperation instance cannot be converted to the IOpenAiFunction type, it would be just enrolled to the IOpenAiDocument.errors array instead.","identifier#Identifier":"export interface IOpenAiFunction {\n  /**\n   * HTTP method of the endpoint.\n   */\n  method: \"get\" | \"post\" | \"patch\" | \"put\" | \"delete\";\n  /**\n   * Path of the endpoint.\n   */\n  path: string;\n  /**\n   * Representative name of the function.\n   *\n   * The `name` is a repsentative name identifying the function in the\n   * {@link IOpenAiDocument}. The `name` value is just composed by joining the\n   * {@link IMigrateRoute.accessor} by underscore `_` character.\n   *\n   * Here is the composition rule of the  {@link IMigrateRoute.accessor}:\n   *\n   * > The `accessor` is composed with the following rules. At first, namespaces\n   * > are composed by static directory names in the {@link path}. Parametric\n   * > symbols represented by `:param` or `{param}` cannot be a part of the\n   * > namespace.\n   * >\n   * > Instead, they would be a part of the function name. The function\n   * > name is composed with the {@link method HTTP method} and parametric symbols\n   * > like `getByParam` or `postByParam`. If there are multiple path parameters,\n   * > they would be concatenated by `And` like `getByParam1AndParam2`.\n   * >\n   * > For refefence, if the {@link operation}'s {@link method} is `delete`, the\n   * > function name would be replaced to `erase` instead of `delete`. It is\n   * > the reason why the `delete` is a reserved keyword in many programming\n   * > languages.\n   * >\n   * > - Example 1\n   * >   - path: `POST /shopping/sellers/sales`\n   * >   - accessor: `shopping.sellers.sales.post`\n   * > - Example 2\n   * >   - endpoint: `GET /shoppings/sellers/sales/:saleId/reviews/:reviewId/comments/:id\n   * >   - accessor: `shoppings.sellers.sales.reviews.getBySaleIdAndReviewIdAndCommentId`\n   */\n  name: string;\n  /**\n   * Description of the function.\n   *\n   * Composed by such rule:\n   *\n   * 1. Starts from the {@link OpenApi.IOperation.summary} paragraph.\n   * 2. The next paragraphs are filled with the {@link OpenApi.IOperation.description}.\n   *    By the way, if the first paragraph of {@link OpenApi.IOperation.description} is same\n   *    with the {@link OpenApi.IOperation.summary}, it would not be duplicated.\n   * 3. Parameters' descriptions are added with `@param` tag.\n   * 4. {@link OpenApi.IOperation.security Security requirements} are added with `@security` tag.\n   * 5. Tag names are added with `@tag` tag.\n   * 6. If {@link OpenApi.IOperation.deprecated}, `@deprecated` tag is added.\n   */\n  description?: string;\n  /**\n   * Get the Swagger operation metadata.\n   *\n   * Get the Swagger operation metadata, of the source.\n   *\n   * @returns Swagger operation metadata.\n   */\n  operation: () => ISwaggerOperation;\n  /**\n   * Get the migration route metadata.\n   *\n   * Get the migration route metadata, of the source.\n   *\n   * @returns Migration route metadata.\n   */\n  route: () => ISwaggerMigrateRoute;\n}\nexport interface IMigrateRoute<\n  Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\n  Operation extends OpenApi.IOperation<Schema> = OpenApi.IOperation<Schema>,\n> {\n  /**\n   * Method of the route.\n   *\n   * If the {@link OpenApi.IOperation.method} is not one of below type\n   * values, the operation would be ignored in the migration process for\n   * the RPC (Remote Procedure Call) function.\n   */\n  method: \"head\" | \"get\" | \"post\" | \"put\" | \"patch\" | \"delete\";\n  /**\n   * Original path from the OpenAPI document.\n   */\n  path: string;\n  /**\n   * Accessor for the route.\n   *\n   * The `accessor` is a list of string values that are representing how to\n   * access to the OpenAPI generated RPC (Remote Procedure Call) function\n   * through namespace(s).\n   *\n   * The `accessor` is composed with the following rules. At first, namespaces\n   * are composed by static directory names in the {@link path}. Parametric\n   * symbols represented by `:param` or `{param}` cannot be a part of the\n   * namespace.\n   *\n   * Instead, they would be a part of the function name. The function\n   * name is composed with the {@link method HTTP method} and parametric symbols\n   * like `getByParam` or `postByParam`. If there are multiple path parameters,\n   * they would be concatenated by `And` like `getByParam1AndParam2`.\n   *\n   * For refefence, if the {@link operation}'s {@link method} is `delete`, the\n   * function name would be replaced to `erase` instead of `delete`. It is\n   * the reason why the `delete` is a reserved keyword in many programming\n   * languages.\n   *\n   * - Example 1\n   *   - path: `POST /shopping/sellers/sales`\n   *   - accessor: `shopping.sellers.sales.post`\n   * - Example 2\n   *   - endpoint: `GET /shoppings/sellers/sales/:saleId/reviews/:reviewId/comments/:id\n   *   - accessor: `shoppings.sellers.sales.reviews.getBySaleIdAndReviewIdAndCommentId`\n   */\n  accessor: string[];\n  /**\n   * Description comment for the route function.\n   *\n   * The `comment` is a function returning description comment for the\n   * RPC function of OpenAPI generated. The comment is composed with the\n   * following rules:\n   *\n   * 1. Starts from the {@link OpenApi.IOperation.summary} paragraph.\n   * 2. The next paragraphs are filled with {@link OpenApi.IOperation.description}.\n   * 3. Parameter descriptions are added with `@param` tag.\n   * 4. Security requirements are added with `@security` tag.\n   * 5. Tag names are added with `@tag` tag.\n   * 6. If {@link OpenApi.IOperation.deprecated}, `@deprecated` tag is added.\n   */\n  comment: () => string;\n  /**\n   * Original operation from the OpenAPI document.\n   *\n   * The `operation` is a function returning the original\n   * {@link OpenApi.IOperation} from the {@link OpenAPI} document.\n   */\n  operation: () => Operation;\n}\nexport namespace OpenApi {\n  export interface IOperation<Schema extends IJsonSchema = IJsonSchema> {\n    /**\n     * A short summary of what the operation does.\n     */\n    summary?: string;\n    /**\n     * A verbose explanation of the operation behavior.\n     */\n    description?: string;\n    /**\n     * List of parameters that are applicable for this operation.\n     */\n    parameters?: IOperation.IParameter<Schema>[];\n    /**\n     * The request body applicable for this operation.\n     */\n    requestBody?: IOperation.IRequestBody<Schema>;\n    /**\n     * List of securities and their scopes that are required for execution.\n     *\n     * When this property be configured, the Restful API operation requires\n     * the matched security value for exection. Its key means security key\n     * matched with {@link OpenApi.IDocument.security}.\n     *\n     * The value means scopes required for the security key when the security\n     * type is {@link OpenApi.ISecurityScheme.IOAuth2}. Otherwise the target\n     * security type is not {@link OpenApi.ISecurityScheme.IOAuth2}, the value\n     * would be empty array.\n     */\n    security?: Record<string, string[]>[];\n    /**\n     * Tags for API documentation control.\n     */\n    tags?: string[];\n  }\n}\nIOpenAiFunction has four identical properties; method, path, name and description.The method and path properties are used to identify the target API operation and bypassed migration schema. The other property name is used to identify the function in the document, and description describes the function's purpose so that helps the LLM to select proper function for the user's chatting text.In detaily, the name property is composed by below rule:\nRule\nSplit OpenApi.IOperation.path by / character\nErase template arguments from the splitted path\nJoin the splitted and filtered text with _ character\nAttach method name at the last of the joined text\nAttach template arguments with By prefix pascalized texts at last\nExample 1\nendpoint: POST /shopping/sellers/sales\nname: shopping_sellers_sales_post\nExample 2\nendpoint: GET /shoppings/sellers/sales/:saleId/reviews/:reviewId/comments/:id\nname: \nAlso, description is composed by such rule:\nStarts from the summary paragraph of the OpenAPI operation.\nThe next paragraphs are filled with the OpenApi.IOperation.description. By the way, if the first paragraph of description is same with the summary, it would not be duplicated.\nParameters' descriptions are added with @param tag.\nSecurity requirements (OpenApi.IOperation.security) are added with @security tag.\nTag names are added with @tag tag.\nIf OpenApi.IOperation.deprecated, @deprecated tag is added.","parameters#Parameters":"export interface IOpenAiFunction {\n  /**\n   * List of parameter schemas.\n   *\n   * If you've configured {@link IOpenAiDocument.IOptions.keyword} (as `true`),\n   * number of {@link IOpenAiFunction.parameters} are always 1 and the first parameter's\n   * type is always {@link IOpenAiSchema.IObject}. The properties' rule is:\n   *\n   * - `pathParameters`: Path parameters of {@link IMigrateRoute.parameters}\n   * - `query`: Query parameter of {@link IMigrateRoute.query}\n   * - `body`: Body parameter of {@link IMigrateRoute.body}\n   *\n   * ```typescript\n   * {\n   *   ...pathParameters,\n   *   query,\n   *   body,\n   * }\n   * ```\n   *\n   * Otherwise, the parameters would be multiple, and the sequence of the parameters\n   * are following below rules:\n   *\n   * ```typescript\n   * [\n   *   ...pathParameters,\n   *   ...(query ? [query] : []),\n   *   ...(body ? [body] : []),\n   * ]\n   * ```\n   */\n  parameters: IOpenAiSchema[];\n}\nexport interface IMigrateRoute<\n  Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\n  Operation extends OpenApi.IOperation<Schema> = OpenApi.IOperation<Schema>,\n> {\n  /**\n   * List of path parameters.\n   *\n   * Note that, not a list of every parameters, but only path parameters.\n   */\n  parameters: IMigrateRoute.IParameter<Schema>[];\n  /**\n   * Metadata of query values.\n   *\n   * The `query` property is a metadata of HTTP request query values for RPC function,\n   * including the parameter variable name and schema.\n   *\n   * Also, its {@link IMigrateRoute.IQuery.schema} is always object or reference\n   * to object. Even though the original {@link OpenApi.IOperation OpenAPI operation}'s\n   * query parameters are separated to atomic typed properties, the `query` property\n   * forcibly combines them into a single object type.\n   *\n   * For reference, if the `query` property has been converted to an object type\n   * forcibly, its property {@link IMigrateRoute.IQuery.name name} and\n   * {@link IMigrateRoute.IQuery.key key} are always \"headers\".\n   */\n  query: IMigrateRoute.IQuery<Schema> | null;\n  /**\n   * Metadata of request body.\n   *\n   * The `body` property is a metadata of HTTP request body for RPC function,\n   * including the parameter variable name, content type, and schema.\n   *\n   * If the `body` property is `null`, it means the operation does not require\n   * the request body data.\n   */\n  body: IMigrateRoute.IBody<Schema> | null;\n}\nexport namespace IMigrateRoute {\n  /**\n   * Metadata of path parameter.\n   */\n  export interface IParameter<\n    Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\n  > {\n    /**\n     * Name of the path parameter.\n     */\n    name: string;\n    /**\n     * Key of the path parameter.\n     */\n    key: string;\n    /**\n     * Metadata of path parameter data type.\n     */\n    schema: Schema;\n    /**\n     * Original parameter info from the OpenAPI document.\n     *\n     * The `parameter` is a function returning the original\n     * {@link OpenApi.IOperation.IParameter} from the {@link OpenAPI} document.\n     */\n    parameter: () => OpenApi.IOperation.IParameter<Schema>;\n  }\n  /**\n   * Metadata of query values.\n   */\n  export interface IQuery<\n    Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\n  > {\n    name: string;\n    key: string;\n    schema: Schema;\n    title: () => string | undefined;\n    description: () => string | undefined;\n    example: () => any | undefined;\n    examples: () => Record<string, any> | undefined;\n  }\n  /**\n   * Metadata of request/response body.\n   */\n  export interface IBody<\n    Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\n  > {\n    /**\n     * Name of the body parameter.\n     */\n    name: string;\n    /**\n     * Key of the body parameter.\n     */\n    key: string;\n    /**\n     * Content type of the body.\n     */\n    type:\n      | \"text/plain\"\n      | \"application/json\"\n      | \"application/x-www-form-urlencoded\"\n      | \"multipart/form-data\";\n    /**\n     * Metadata of response body data type.\n     */\n    schema: Schema;\n    /**\n     * Description comment for the request/response body.\n     */\n    description: () => string | undefined;\n    /**\n     * Media type of the request/response body.\n     */\n    media: () => OpenApi.IOperation.IMediaType<Schema>;\n    /**\n     * Whether the body is encrypted or not.\n     */\n    \"x-nestia-encrypted\"?: boolean;\n  }\n}\nexport namespace OpenApi {\n  export interface IOperation<Schema extends IJsonSchema = IJsonSchema> {\n    /**\n     * List of parameters that are applicable for this operation.\n     */\n    parameters?: IOperation.IParameter<Schema>[];\n    /**\n     * The request body applicable for this operation.\n     */\n    requestBody?: IOperation.IRequestBody<Schema>;\n  }\n  export namespace IOperation {\n    /**\n     * Parameter of the operation.\n     */\n    export interface IParameter<Schema extends IJsonSchema = IJsonSchema> {\n      /**\n       * Representative name of the parameter.\n       *\n       * In the most case, the `name` is equivalent to parameter variable name.\n       * Therefore, the `name` must be filled with the significant variable name\n       * of the parameter.\n       *\n       * By the way, only when the {@link in} property is `path`, the `name`\n       * can be omitted. In that case, the `name` is automatically deduced from\n       * the URL path's positional template argument analyzing.\n       */\n      name?: string;\n      /**\n       * Location of the parameter.\n       *\n       * The `in` property is a string that determines the location of the parameter.\n       *\n       * - `path`: parameter is part of the path of the URL.\n       * - `query`: parameter is part of the query string.\n       * - `header`: parameter is part of the header.\n       * - `cookie`: parameter is part of the cookie.\n       */\n      in: \"path\" | \"query\" | \"header\" | \"cookie\";\n      /**\n       * Type info of the parameter.\n       */\n      schema: Schema;\n      /**\n       * Whether the parameter is required for execution or not.\n       *\n       * If the parameter is required, the value must be filled. Otherwise,\n       * it is possible to skip the parameter when executing the APi operation.\n       *\n       * For reference, the `required` property must be always `true` when the\n       * {@link in} property is `path`. Otherwise, the `required` property can\n       * be anything of them; `true`, `false` and `undefined`.\n       */\n      required?: boolean;\n      /**\n       * Short title of the parameter.\n       */\n      title?: string;\n      /**\n       * Verbose explanation of the parameter.\n       */\n      description?: string;\n      /**\n       * Example value of the parameter.\n       */\n      example?: any;\n      /**\n       * Collection of example values of the parameter with keys.\n       */\n      examples?: Record<string, IExample>;\n    }\n    /**\n     * Request body of the operation.\n     */\n    export interface IRequestBody<Schema extends IJsonSchema = IJsonSchema> {\n      content?: IContent<Schema>;\n      description?: string;\n      required?: boolean;\n      \"x-nestia-encrypted\"?: boolean;\n    }\n    /**\n     * List of content types supported in request/response body.\n     */\n    export interface IContent<Schema extends IJsonSchema = IJsonSchema>\n      extends Partial<Record<ContentType, IMediaType<Schema>>> {}\n    /**\n     * Media type of a request/response body.\n     */\n    export interface IMediaType<Schema extends IJsonSchema = IJsonSchema> {\n      schema?: Schema;\n      example?: any;\n      examples?: Record<string, IExample>;\n    }\n    /**\n     * List of supported content media types.\n     */\n    export type ContentType =\n      | \"text/plain\"\n      | \"application/json\"\n      | \"application/x-www-form-url-encoded\"\n      | \"multipart/form-data\"\n      | \"*/*\"\n      | (string & {});\n  }\n}\nParameters of the function.IOpenAiFunction.parameters are composed with path, query and request body parameters, directly referencing the IOpenAISchema. About the query parameters, it is always combined into one single object with key/value paired properties. In other words, the parameters of the LLM function calling schema is composed by listing up IMigrateRoute.parameters, IMigrateRoute.query and IMigrateRoute.body properties as an array.By the way, such composition rule is valid only when the IOpenAiDocument.IOptions.keyword property has not been configured as true. If the keyword property is true, number of the parameters are always 1 by gathering every parameters into only one object with key/value paired properties.If express such composition rule with TypeScript, it would be like below:\n// KEYWORD: FALSE\n[\n  ...pathParameters,\n  ...(query ? [query] : []),\n  ...(body ? [body] : []),\n]\n// KEYWORD: TRUE\n{\n  ...pathParameters,\n  query,\n  body,\n}","output#Output":"export interface IOpenAiFunction {\n  /**\n   * Expected return type.\n   *\n   * If the function returns nothing (`void`), then the output is `undefined`.\n   */\n  output?: IOpenAiSchema | undefined;\n}\nexport interface IMigrateRoute<\n  Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\n  Operation extends OpenApi.IOperation<Schema> = OpenApi.IOperation<Schema>,\n> {\n  /**\n   * Metadata of response body for success case.\n   *\n   * The `success` property is a metadata of HTTP response body for RPC function,\n   * including content type, and schema when status code is `200` or `201`.\n   *\n   * If the `success` property is `null`, it means the operation does not have\n   * the response body data. In other words, the RPC function would return `void`.\n   */\n  success: IMigrateRoute.IBody<Schema> | null;\n  /**\n   * Metadata of response body for exceptional status cases.\n   *\n   * The `exceptions` property is a metadata of HTTP response body for RPC\n   * function, including content type, and schema when status code is not `200`\n   * or `201`.\n   *\n   * The key of the `exceptions` property is the status code. It may be a\n   * stringified number, but sometimes it could be a string like \"default\",\n   * because the OpenAPI document allows the status code to be a string.\n   */\n  exceptions: Record<string, IMigrateRoute.IException<Schema>>;\n}\nexport namespace IMigrateRoute {\n  /**\n   * Metadata of request/response body.\n   */\n  export interface IBody<\n    Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\n  > {\n    /**\n     * Name of the body parameter.\n     */\n    name: string;\n    /**\n     * Key of the body parameter.\n     */\n    key: string;\n    /**\n     * Content type of the body.\n     */\n    type:\n      | \"text/plain\"\n      | \"application/json\"\n      | \"application/x-www-form-urlencoded\"\n      | \"multipart/form-data\";\n    /**\n     * Metadata of response body data type.\n     */\n    schema: Schema;\n    /**\n     * Description comment for the request/response body.\n     */\n    description: () => string | undefined;\n    /**\n     * Media type of the request/response body.\n     */\n    media: () => OpenApi.IOperation.IMediaType<Schema>;\n    /**\n     * Whether the body is encrypted or not.\n     */\n    \"x-nestia-encrypted\"?: boolean;\n  }\n  /**\n   * Metadata of response body for exceptional status cases.\n   */\n  export interface IException<\n    Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\n  > {\n    /**\n     * Metadata of response body data type.\n     */\n    schema: Schema;\n    /**\n     * Description comment for the exception.\n     */\n    response: () => OpenApi.IOperation.IResponse<Schema>;\n    /**\n     * Media type of the response body.\n     */\n    media: () => OpenApi.IOperation.IMediaType<Schema>;\n  }\n}\nexport namespace OpenApi {\n  export interface IOperation<Schema extends IJsonSchema = IJsonSchema> {\n    /**\n     * The list of possible responses as they are returned from executing this\n     * operation. Its key is the HTTP status code, and the value is the metadata of\n     * the response in the HTTP status code.\n     */\n    responses?: Record<string, IOperation.IResponse<Schema>>;\n  }\n  export namespace IOperation {\n    /**\n     * Response of the operation.\n     */\n    export interface IResponse<Schema extends IJsonSchema = IJsonSchema> {\n      headers?: Record<string, IOperation.IParameter<Schema>>;\n      content?: IContent<Schema>;\n      description?: string;\n      \"x-nestia-encrypted\"?: boolean;\n    }\n    /**\n     * List of content types supported in request/response body.\n     */\n    export interface IContent<Schema extends IJsonSchema = IJsonSchema>\n      extends Partial<Record<ContentType, IMediaType<Schema>>> {}\n    /**\n     * Media type of a request/response body.\n     */\n    export interface IMediaType<Schema extends IJsonSchema = IJsonSchema> {\n      schema?: Schema;\n      example?: any;\n      examples?: Record<string, IExample>;\n    }\n    /**\n     * List of supported content media types.\n     */\n    export type ContentType =\n      | \"text/plain\"\n      | \"application/json\"\n      | \"application/x-www-form-url-encoded\"\n      | \"multipart/form-data\"\n      | \"*/*\"\n      | (string & {});\n  }\n}\nIOpenAiFunction.output means a return type of the function.When converting an OpenAPI operation to a LLM function schema bypass migration process, only the success case of 200 status code (or 201 when POST method) is considered. Also, about the content type, only the first one is remained. The schema information registered in the IOpenAiFunction.output comes from such process.However, looking at the intermediate structure IMigrateRoute, you can find that the bypass route is storing not only the IMigrateRoute.success typed response body, but also the exceptional status cases in the IMigrateRoute.exceptions property. Unfortunately, current LLM function calling does not consider the exceptional cases represented by Try<T, E>, the other status codes are not available.","separation#Separation":"export interface IOpenAiFunction {\n  /**\n   * Collection of separated parameters.\n   *\n   * Filled only when {@link IOpenAiDocument.IOptions.separate} has been configured.\n   */\n  separated?: IOpenAiFunction.ISeparated;\n  /**\n   * List of parameter schemas.\n   *\n   * If you've configured {@link IOpenAiDocument.IOptions.keyword} (as `true`),\n   * number of {@link IOpenAiFunction.parameters} are always 1 and the first parameter's\n   * type is always {@link IOpenAiSchema.IObject}. The properties' rule is:\n   *\n   * - `pathParameters`: Path parameters of {@link IMigrateRoute.parameters}\n   * - `query`: Query parameter of {@link IMigrateRoute.query}\n   * - `body`: Body parameter of {@link IMigrateRoute.body}\n   *\n   * ```typescript\n   * {\n   *   ...pathParameters,\n   *   query,\n   *   body,\n   * }\n   * ```\n   *\n   * Otherwise, the parameters would be multiple, and the sequence of the parameters\n   * are following below rules:\n   *\n   * ```typescript\n   * [\n   *   ...pathParameters,\n   *   ...(query ? [query] : []),\n   *   ...(body ? [body] : []),\n   * ]\n   * ```\n   */\n  parameters: IOpenAiSchema[];\n}\nexport namespace IOpenAiFunction {\n  /**\n   * Collection of separated parameters.\n   */\n  export interface ISeparated {\n    /**\n     * Parameters that would be composed by the OpenAI.\n     */\n    llm: ISeparatedParameter[];\n    /**\n     * Parameters that would be composed by the human.\n     */\n    human: ISeparatedParameter[];\n  }\n  /**\n   * Separated parameter.\n   */\n  export interface ISeparatedParameter {\n    /**\n     * Index of the parameter.\n     */\n    index: number;\n    /**\n     * Type schema info of the parameter.\n     */\n    schema: IOpenAiSchema;\n  }\n}\nexport namespace IOpenAiDocument {\n  export interface IOptions {\n    /**\n     * Separator function for the parameters.\n     *\n     * When composing parameter arguments through OpenAI function call,\n     * there can be a case that some parameters must be composed by human, or\n     * LLM cannot understand the parameter. For example, if the parameter type\n     * has configured {@link IOpenAiSchema.IString[\"x-wrtn-secret-key\"]}, the\n     * secret key value must be composed by human, not by LLM (Large Language Model).\n     *\n     * In that case, if you configure this property with a function that\n     * predicating whether the schema value must be composed by human or not,\n     * the parameters would be separated into two parts.\n     *\n     * - {@link IOpenAiFunction.separated.llm}\n     * - {@link IOpenAiFunction.separated.human}\n     *\n     * When writing the function, note that returning value `true` means to be\n     * a human composing the value, and `false` means to LLM composing the value.\n     * Also, when predicating the schema, it would better to utilize the\n     * {@link OpenAiTypeChecker} features.\n     *\n     * @param schema Schema to be separated.\n     * @returns Whether the schema value must be composed by human or not.\n     * @default null\n     */\n    separate: null | ((schema: IOpenAiSchema) => boolean);\n    /**\n     * Whether the parameters are keyworded or not.\n     *\n     * If this property value is `true`, length of the\n     * {@link IOpenAiDocument.IFunction.parameters} is always 1, and type of the\n     * pararameter is always {@link IOpenAiSchema.IObject} type. Also, its\n     * properties are following below rules:\n     *\n     * - `pathParameters`: Path parameters of {@link ISwaggerMigrateRoute.parameters}\n     * - `query`: Query parameter of {@link ISwaggerMigrateRoute.query}\n     * - `body`: Body parameter of {@link ISwaggerMigrateRoute.body}\n     *\n     * ```typescript\n     * {\n     *   ...pathParameters,\n     *   query,\n     *   body,\n     * }\n     * ```\n     *\n     * Otherwise (this property value is `false`), length of the\n     * {@link IOpenAiDocument.IFunction.parameters} is variable, and sequence of the\n     * parameters are following below rules.\n     *\n     * ```typescript\n     * [\n     *   ...pathParameters,\n     *   ...(query ? [query] : []),\n     *   ...(body ? [body] : []),\n     * ]\n     * ```\n     *\n     * @default false\n     */\n    keyword: boolean;\n  }\n}\nSeparation of parameters to both LLM and Human sides.If configure IOpenAiDocument.IOptions.separate function when converting OpenAPI document to LLM function calling schemas, IOpenAiFunction.separated is activated with two separated parameters; LLM side and Human side. If the configured function returns true, the target schema becomes of Human side, otherwise LLM side.Such separation is useful when some parameter value must be composed by Human, not by LLM. For example, if there's a type indicating the secret key value or file uploading, the value must be constructed by Human, not by LLM automatically composing from the chatting text.For reference, even if configured IOpenAiDocument.IOptions.keyword as true, the separation works properly. Here is the example of the separation function to the keyworded parameter, and its result. As you can see, the separate function checks every nested schemas, and re-construct the parameters into two separated parts.\nconst separator: IOpenAiDocument.IOptions[\"separate\"] = schema =>\n  schema.type === \"string\" && (\n    || schema[\"x-wrtn-secret-key\"] === true\n    || schema.contentMediaType !== undefined\n  );\nconst parameters: IOpenAiFunction.ISchema[] = [\n  {\n    type: \"object\",\n    properties: {\n      file: {\n        type: \"string\",\n        contentMediaType: \"image/png\",\n      },\n      title: { type: \"string\" },\n      notes: {\n        type: \"array\",\n        items: { type: \"string\" },\n      },\n    },\n  },\n];\nconst separated: IOpenAiFunction.ISeparated = {\n  llm: [\n    {\n      index: 0,\n      schema: {\n        type: \"object\",\n        properties: {\n          title: { type: \"string\" },\n          notes: {\n            type: \"array\",\n            items: { type: \"string\" },\n          },\n        },\n      },\n    },\n  ],\n  human: [\n    {\n      index: 0,\n      schema: {\n        type: \"object\",\n        properties: {\n          file: {\n            type: \"string\",\n            contentMediaType: \"image/png\",\n          },\n        },\n      },\n    },\n  ],\n};","schema#Schema":"export type IOpenAiSchema =\n  | IOpenAiSchema.IBoolean\n  | IOpenAiSchema.IInteger\n  | IOpenAiSchema.INumber\n  | IOpenAiSchema.IString\n  | IOpenAiSchema.IArray\n  | IOpenAiSchema.IObject\n  | IOpenAiSchema.IUnknown\n  | IOpenAiSchema.INullOnly\n  | IOpenAiSchema.IOneOf;\nexport namespace IOpenAiSchema {\n  export interface IBoolean extends __ISignificant<\"boolean\"> {\n    default?: boolean;\n    enum?: boolean[];\n  }\n  export interface IInteger extends __ISignificant<\"integer\"> {\n    /** @type int64 */ default?: number;\n    /** @type int64 */ enum?: number[];\n    /** @type int64 */ minimum?: number;\n    /** @type int64 */ maximum?: number;\n    exclusiveMinimum?: boolean;\n    exclusiveMaximum?: boolean;\n    /**\n     * @type uint64\n     * @exclusiveMinimum 0\n     */\n    multipleOf?: number;\n  }\n  export interface INumber extends __ISignificant<\"number\"> {\n    default?: number;\n    enum?: number[];\n    minimum?: number;\n    maximum?: number;\n    exclusiveMinimum?: boolean;\n    exclusiveMaximum?: boolean;\n    /** @exclusiveMinimum 0 */ multipleOf?: number;\n  }\n  export interface IString extends __ISignificant<\"string\"> {\n    default?: string;\n    enum?: string[];\n    format?:\n      | \"binary\"\n      | \"byte\"\n      | \"password\"\n      | \"regex\"\n      | \"uuid\"\n      | \"email\"\n      | \"hostname\"\n      | \"idn-email\"\n      | \"idn-hostname\"\n      | \"iri\"\n      | \"iri-reference\"\n      | \"ipv4\"\n      | \"ipv6\"\n      | \"uri\"\n      | \"uri-reference\"\n      | \"uri-template\"\n      | \"url\"\n      | \"date-time\"\n      | \"date\"\n      | \"time\"\n      | \"duration\"\n      | \"json-pointer\"\n      | \"relative-json-pointer\"\n      | (string & {});\n    pattern?: string;\n    /** @type uint64 */ minLength?: number;\n    /** @type uint64 */ maxLength?: number;\n    contentMediaType?: string;\n    \"x-wrtn-secret-key\"?: string;\n    \"x-wrtn-secret-scopes\"?: string[];\n  }\n  export interface IArray extends __ISignificant<\"array\"> {\n    items: IOpenAiSchema;\n    uniqueItems?: boolean;\n    minItems?: number;\n    maxItems?: number;\n  }\n  export interface IObject extends __ISignificant<\"object\"> {\n    properties?: Record<string, IOpenAiSchema>;\n    required?: string[];\n    additionalProperties?: boolean | IOpenAiSchema;\n  }\n  export interface IUnknown extends __IAttribute {\n    type?: undefined;\n  }\n  export interface INullOnly extends __IAttribute {\n    type: \"null\";\n  }\n  export interface IOneOf extends __IAttribute {\n    oneOf: IOpenAiSchema[];\n  }\n  export interface __ISignificant<Type extends string> extends __IAttribute {\n    type: Type;\n    nullable?: boolean;\n  }\n  export interface __IAttribute {\n    title?: string;\n    description?: string;\n    deprecated?: boolean;\n    \"x-wrtn-placeholder\"?: string;\n    \"x-wrtn-prerequisite\"?: {\n      method: \"get\" | \"post\" | \"patch\" | \"put\" | \"delete\";\n      path: string;\n      jmesPath: string;\n    };\n  }\n}\nexport namespace OpenApiV3 {\n  export type IJsonSchema =\n    | IJsonSchema.IBoolean\n    | IJsonSchema.IInteger\n    | IJsonSchema.INumber\n    | IJsonSchema.IString\n    | IJsonSchema.IArray\n    | IJsonSchema.IObject\n    | IJsonSchema.IReference\n    | IJsonSchema.IUnknown\n    | IJsonSchema.INullOnly\n    | IJsonSchema.IAllOf\n    | IJsonSchema.IAnyOf\n    | IJsonSchema.IOneOf;\n  export namespace IJsonSchema {\n    export interface IBoolean extends __ISignificant<\"boolean\"> {\n      default?: boolean | null;\n      enum?: Array<boolean | null>;\n    }\n    export interface IInteger extends __ISignificant<\"integer\"> {\n      /** @type int64 */ default?: number | null;\n      /** @type int64 */ enum?: Array<number | null>;\n      /** @type int64 */ minimum?: number;\n      /** @type int64 */ maximum?: number;\n      exclusiveMinimum?: boolean;\n      exclusiveMaximum?: boolean;\n      /**\n       * @type uint64\n       * @exclusiveMinimum 0\n       */\n      multipleOf?: number;\n    }\n    export interface INumber extends __ISignificant<\"number\"> {\n      default?: number | null;\n      enum?: Array<number | null>;\n      minimum?: number;\n      maximum?: number;\n      exclusiveMinimum?: boolean;\n      exclusiveMaximum?: boolean;\n      /** @exclusiveMinimum 0 */ multipleOf?: number;\n    }\n    export interface IString extends __ISignificant<\"string\"> {\n      default?: string | null;\n      enum?: Array<string | null>;\n      format?:\n        | \"binary\"\n        | \"byte\"\n        | \"password\"\n        | \"regex\"\n        | \"uuid\"\n        | \"email\"\n        | \"hostname\"\n        | \"idn-email\"\n        | \"idn-hostname\"\n        | \"iri\"\n        | \"iri-reference\"\n        | \"ipv4\"\n        | \"ipv6\"\n        | \"uri\"\n        | \"uri-reference\"\n        | \"uri-template\"\n        | \"url\"\n        | \"date-time\"\n        | \"date\"\n        | \"time\"\n        | \"duration\"\n        | \"json-pointer\"\n        | \"relative-json-pointer\"\n        | (string & {});\n      pattern?: string;\n      /** @type uint64 */ minLength?: number;\n      /** @type uint64 */ maxLength?: number;\n    }\n    export interface IArray extends __ISignificant<\"array\"> {\n      items: IJsonSchema;\n      uniqueItems?: boolean;\n      /** @type uint64 */ minItems?: number;\n      /** @type uint64 */ maxItems?: number;\n    }\n    export interface IObject extends __ISignificant<\"object\"> {\n      properties?: Record<string, IJsonSchema>;\n      required?: string[];\n      additionalProperties?: boolean | IJsonSchema;\n      maxProperties?: number;\n      minProperties?: number;\n    }\n    export interface IReference<Key = string> extends __IAttribute {\n      $ref: Key;\n    }\n    export interface IUnknown extends __IAttribute {\n      type?: undefined;\n    }\n    export interface INullOnly extends __IAttribute {\n      type: \"null\";\n    }\n    export interface IAllOf extends __IAttribute {\n      allOf: IJsonSchema[];\n    }\n    export interface IAnyOf extends __IAttribute {\n      anyOf: IJsonSchema[];\n    }\n    export interface IOneOf extends __IAttribute {\n      oneOf: IJsonSchema[];\n      discriminator?: IOneOf.IDiscriminator;\n    }\n    export namespace IOneOf {\n      export interface IDiscriminator {\n        propertyName: string;\n        mapping?: Record<string, string>;\n      }\n    }\n    export interface __ISignificant<Type extends string> extends __IAttribute {\n      type: Type;\n      nullable?: boolean;\n    }\n    export interface __IAttribute {\n      title?: string;\n      description?: string;\n      deprecated?: boolean;\n    }\n  }\n}\nexport namespace OpenApi {\n  export type IJsonSchema =\n    | IJsonSchema.IConstant\n    | IJsonSchema.IBoolean\n    | IJsonSchema.IInteger\n    | IJsonSchema.INumber\n    | IJsonSchema.IString\n    | IJsonSchema.IArray\n    | IJsonSchema.ITuple\n    | IJsonSchema.IObject\n    | IJsonSchema.IReference\n    | IJsonSchema.IOneOf\n    | IJsonSchema.INull\n    | IJsonSchema.IUnknown;\n  export namespace IJsonSchema {\n    export interface IConstant extends __IAttribute {\n      const: boolean | number | string;\n    }\n    export interface IBoolean extends __ISignificant<\"boolean\"> {\n      default?: boolean;\n    }\n    export interface IInteger extends __ISignificant<\"integer\"> {\n      /** @type int64 */ default?: number;\n      /** @type int64 */ minimum?: number;\n      /** @type int64 */ maximum?: number;\n      exclusiveMinimum?: boolean;\n      exclusiveMaximum?: boolean;\n      /**\n       * @type uint64\n       * @exclusiveMinimum 0\n       */\n      multipleOf?: number;\n    }\n    export interface INumber extends __ISignificant<\"number\"> {\n      default?: number;\n      minimum?: number;\n      maximum?: number;\n      exclusiveMinimum?: boolean;\n      exclusiveMaximum?: boolean;\n      /** @exclusiveMinimum 0 */ multipleOf?: number;\n    }\n    export interface IString extends __ISignificant<\"string\"> {\n      default?: string;\n      format?:\n        | \"binary\"\n        | \"byte\"\n        | \"password\"\n        | \"regex\"\n        | \"uuid\"\n        | \"email\"\n        | \"hostname\"\n        | \"idn-email\"\n        | \"idn-hostname\"\n        | \"iri\"\n        | \"iri-reference\"\n        | \"ipv4\"\n        | \"ipv6\"\n        | \"uri\"\n        | \"uri-reference\"\n        | \"uri-template\"\n        | \"url\"\n        | \"date-time\"\n        | \"date\"\n        | \"time\"\n        | \"duration\"\n        | \"json-pointer\"\n        | \"relative-json-pointer\"\n        | (string & {});\n      pattern?: string;\n      contentMediaType?: string;\n      /** @type uint64 */ minLength?: number;\n      /** @type uint64 */ maxLength?: number;\n    }\n    export interface IArray<Schema extends IJsonSchema = IJsonSchema>\n      extends __ISignificant<\"array\"> {\n      items: Schema;\n      uniqueItems?: boolean;\n      /** @type uint64 */ minItems?: number;\n      /** @type uint64 */ maxItems?: number;\n    }\n    export interface ITuple<Schema extends IJsonSchema = IJsonSchema>\n      extends __ISignificant<\"array\"> {\n      prefixItems: Schema[];\n      additionalItems?: boolean | Schema;\n      uniqueItems?: boolean;\n      /** @type uint64 */ minItems?: number;\n      /** @type uint64 */ maxItems?: number;\n    }\n    export interface IObject<Schema extends IJsonSchema = IJsonSchema>\n      extends __ISignificant<\"object\"> {\n      properties?: Record<string, Schema>;\n      additionalProperties?: boolean | Schema;\n      required?: string[];\n    }\n    export interface IReference<Key = string> extends __IAttribute {\n      $ref: Key;\n    }\n    export interface IOneOf<Schema extends IJsonSchema = IJsonSchema>\n      extends __IAttribute {\n      oneOf: Exclude<Schema, IJsonSchema.IOneOf>[];\n      discriminator?: IOneOf.IDiscriminator;\n    }\n    export namespace IOneOf {\n      export interface IDiscriminator {\n        propertyName: string;\n        mapping?: Record<string, string>;\n      }\n    }\n    export interface INull extends __ISignificant<\"null\"> {\n      default?: null;\n    }\n    export interface IUnknown extends __IAttribute {\n      type?: undefined;\n    }\n    export interface __ISignificant<Type extends string> extends __IAttribute {\n      type: Type;\n    }\n    export interface __IAttribute {\n      title?: string;\n      description?: string;\n      deprecated?: boolean;\n    }\n  }\n}\nSchema types for the LLM function call.The LLM (Large Language Model) function calling schema is utilizing a specific type schema that is similar to the JSON schema of the OpenAPI v3.0 specification. Only different with the OpenAPI v3.0 JSON schema is, of LLM does not support the IJsonSchema.IReference type.Therefore, looking above type schema definitions of LLM function calling and OpenAPI specifications, you can find that the LLM's type schema type does not contain the reference type in the union IOpenAiSchema type. The other things are same with original JSON schema.Also, if you compare this section with OpenAPI > Json Schema chapter, you may understand the LLM's type system more clearly and easily.","common-properties#Common Properties":"export namespace IOpenAiSchema {\n  /**\n   * Common attributes that can be applied to all types.\n   */\n  export interface __IAttribute {\n    /**\n     * Title of the schema.\n     */\n    title?: string;\n    /**\n     * Detailed description of the schema.\n     */\n    description?: string;\n    /**\n     * Whether the type is deprecated or not.\n     */\n    deprecated?: boolean;\n    /**\n     * Placeholder value for frontend application.\n     *\n     * Placeholder means the value to be shown in the input field as a hint.\n     * For example, when an email input field exists, the placeholder value\n     * would be \"Insert your email address here\".\n     */\n    \"x-wrtn-placeholder\"?: string;\n    /**\n     * Prerequisite API endpoint for the schema.\n     *\n     * `x-wrtn-prerequisite` is a property representing the prerequisite API\n     * interaction. It means that, the endpoint API should be called before\n     * calling the target API, for composing some argument value.\n     *\n     * @reference https://github.com/wrtnio/decorators/blob/main/src/Prerequisite.ts\n     */\n    \"x-wrtn-prerequisite\"?: {\n      /**\n       * HTTP method to call the endpoint.\n       */\n      method: \"get\" | \"post\" | \"patch\" | \"put\" | \"delete\";\n      /**\n       * Path of the endpoint.\n       */\n      path: string;\n      /**\n       * Function returning transformed values using JMESPath expression.\n       *\n       * `Prerequisite.Props.jmesPath` is a string typed property that extracts desired values\n       * from the prerequisite API response using a JMESPath expression. This property simplifies\n       * and replaces the `label`, `value`, and `array` properties.\n       *\n       * JMESPath expressions are used to extract the desired data based on the API response.\n       * The expression must always be a valid JMESPath syntax.\n       *\n       * - Type: `jmesPath: string`\n       * - Example: `\"members[*].data.title\"`\n       * - Usage: `jmespath.search(response, jmesPath)`\n       *\n       * Note: The `label`, `value`, and `array` properties are no longer in use.\n       */\n      jmesPath: string;\n    };\n  }\n}\nEvery type schemas in the LLM function call has five properties.The first title is the representative name of the schema, and the meaning \"representative\" is powerful due to LLM (Large Language Model) is affected by the title value when understanding the schema information.The other description is the detailed explanation of the schema. In the LLM side, it is used for understanding the schema more deeply than title. Also, LLM utilizes the description value to the writing a chatting text that requesting Human to write the function calling arguments by the chatting text.The next deprecated is used to mark the schema as deprecated. If the target schema is optional and marked as deprecated, the LLM tends to avoid the target schema's value composition. However, if the schema is essential for function calling, it would be ignored.At last, there're plugin properties x-wrtn-placeholder and x-wrtn-prerequisite. It is not a spec for LLM function calling, but for the Workflow editor side. If you want to know more about these plugin properties, please refer to the OpenAPI > Plugin Properties chapter.","boolean#Boolean":"export namespace IOpenAiSchema {\n  /**\n   * Boolean type schema info.\n   */\n  export interface IBoolean extends __IAttribute {\n    /**\n     * Discriminator value of the type.\n     */\n    type: \"boolean\";\n    /**\n     * Enumeration values.\n     */\n    enum?: boolean[];\n    /**\n     * Whether to allow `null` value or not.\n     */\n    nullable?: boolean;\n    /**\n     * Default value.\n     */\n    default?: boolean;\n  }\n}\nexport namespace OpenApiV3_0 {\n  export namespace IJsonSchema {\n    export interface IBoolean extends __IAttribute {\n      type: \"boolean\";\n      enum?: Array<boolean | null>;\n      nullable?: boolean;\n      default?: boolean;\n    }\n  }\n}\nexport namespace OpenApi {\n  export namespace IJsonSchema {\n    export interface IBoolean extends __IAttribute {\n      type: \"boolean\";\n      default?: boolean;\n    }\n    export interface IConstant extends __IAttribute {\n      const: boolean | number | string;\n    }\n    export interface INull extends __IAttribute {\n      type: \"null\";\n      default?: null;\n    }\n  }\n}\nIn the LLM function calling, the boolean type is expressed as above.Also, if the target type of the schema is not a general boolean type, but a specific literal type like true or false, it would be expressed as enum property. Also, if the target type of the schema is nullable, the nullable property would be activated.At last, the default property is used to represent the default value of the schema. If the schema is optional and marked as default, the LLM tends to compose the default value to the function calling arguments.\n💻 Playground Link\nimport typia, { tags } from \"typia\";\nconsole.log(\n  typia.json.application<\n    [\n      boolean,\n      false,\n      boolean | null,\n      boolean & tags.Default<false>\n    ], \n    \"3.0\"\n  >(),\n);\n  // { type: \"boolean\" },\n  // {\n  //   type: \"boolean\",\n  //   enum: [false],\n  // },\n  // {\n  //   type: \"boolean\",\n  //   nullable: true,\n  // },\n  // {\n  //   type: \"boolean\",\n  //   default: false,\n  // }","integer#Integer":"export namespace IOpenAiSchema {\n  /**\n   * Integer type schema info.\n   */\n  export interface IInteger extends __IAttribute {\n    /**\n     * Discriminator value of the type.\n     */\n    type: \"integer\";\n    /**\n     * Enumeration values.\n     *\n     * @type int64\n     */\n    enum?: number[];\n    /**\n     * Whether to allow `null` value or not.\n     */\n    nullable?: boolean;\n    /**\n     * Default value.\n     *\n     * @type int64\n     */\n    default?: number;\n    /**\n     * Minimum value restriction.\n     *\n     * @type int64\n     */\n    minimum?: number;\n    /**\n     * Maximum value restriction.\n     *\n     * @type int64\n     */\n    maximum?: number;\n    /**\n     * Exclusive minimum value restriction.\n     *\n     * For reference, even though your Swagger (or OpenAPI) document has\n     * defined the `exclusiveMinimum` value as `number`, {@link OpenAiComposer}\n     * forcibly converts it to `boolean` type, and assign the numeric value to\n     * the {@link minimum} property.\n     */\n    exclusiveMinimum?: boolean;\n    /**\n     * Exclusive maximum value restriction.\n     *\n     * For reference, even though your Swagger (or OpenAPI) document has\n     * defined the `exclusiveMaximum` value as `number`, {@link OpenAiComposer}\n     * forcibly converts it to `boolean` type, and assign the numeric value to\n     * the {@link maximum} property.\n     */\n    exclusiveMaximum?: boolean;\n    /**\n     * Multiple of value restriction.\n     *\n     * @type uint64\n     * @exclusiveMinimum 0\n     */\n    multipleOf?: number;\n  }\n}\nexport namespace OpenApiV3_0 {\n  export namespace IJsonSchema {\n    export interface IInteger extends __IAttribute {\n      type: \"integer\";\n      nullable?: boolean;\n      /** @type int64 */ enum?: Array<number | null>;\n      /** @type int64 */ default?: number | null;\n      /** @type int64 */ minimum?: number;\n      /** @type int64 */ maximum?: number;\n      exclusiveMinimum?: boolean;\n      exclusiveMaximum?: boolean;\n      /**\n       * @type uint64\n       * @exclusiveMinimum 0\n       */\n      multipleOf?: number;\n    }\n  }\n}\nexport namespace OpenApi {\n  export namespace IJsonSchema {\n    export interface IInteger extends __IAttribute {\n      type: \"integer\";\n      /** @type int64 */ default?: number;\n      /** @type int64 */ minimum?: number;\n      /** @type int64 */ maximum?: number;\n      exclusiveMinimum?: boolean;\n      exclusiveMaximum?: boolean;\n      /**\n       * @type uint64\n       * @exclusiveMinimum 0\n       */\n      multipleOf?: number;\n    }\n    export interface IConstant extends __IAttribute {\n      const: boolean | number | string;\n    }\n    export interface INull extends __IAttribute {\n      type: \"null\";\n      default?: null;\n    }\n  }\n}\nIn the LLM function calling, the integer type is expressed as above.Unlike above boolean type is, the integer type has additional restriction properties.At first, multipleOf means the value must be multiple of the assigned value. Therefore, if you assign an integer value to the multipleOf restricted type, your integer value must be possible to divid by the multipleOf value without any remainder.The other, minimum and maximum are the range restriction properties, and exclusiveMinimum and exclusiveMaximum are helper properties describing whether the minimum and maximum restrictions are prohibiting equal value or not. As default value of exclusiveMinimum and exclusiveMaximum are false, if only minimum or maximum is assigned, the value is allowed to be equal to the minimum or maximum value.\n💻 Playground Link\nimport typia, { tags } from \"typia\";\nconsole.log(\n  typia.json.application<[\n    number & tags.Type<\"uint32\"> & tags.Minimum<100>,\n  ]>(),\n  typia.createIs<number & tags.Type<\"uint32\"> & tags.Minimum<100>>(),\n);\n// {\n//   type: \"integer\",\n//   minimum: 100,\n// }\n//-----------------------\n// (input) => {\n//   return (\n//     \"number\" === typeof input &&\n//     Math.floor(input) === input &&\n//     -2147483648 <= input &&\n//     100 <= input\n//   );\n// }","number#Number":"export namespace IOpenAiSchema {\n  /**\n   * Number type schema info.\n   */\n  export interface INumber extends __IAttribute {\n    /**\n     * Discriminator value of the type.\n     */\n    type: \"number\";\n    /**\n     * Enumeration values.\n     */\n    enum?: number[];\n    /**\n     * Whether to allow `null` value or not.\n     */\n    nullable?: boolean;\n    /**\n     * Default value.\n     */\n    default?: number;\n    /**\n     * Minimum value restriction.\n     */\n    minimum?: number;\n    /**\n     * Maximum value restriction.\n     */\n    maximum?: number;\n    /**\n     * Exclusive minimum value restriction.\n     *\n     * For reference, even though your Swagger (or OpenAPI) document has\n     * defined the `exclusiveMinimum` value as `number`, {@link OpenAiComposer}\n     * forcibly converts it to `boolean` type, and assign the numeric value to\n     * the {@link minimum} property.\n     */\n    exclusiveMinimum?: boolean;\n    /**\n     * Exclusive maximum value restriction.\n     *\n     * For reference, even though your Swagger (or OpenAPI) document has\n     * defined the `exclusiveMaximum` value as `number`, {@link OpenAiComposer}\n     * forcibly converts it to `boolean` type, and assign the numeric value to\n     * the {@link maximum} property.\n     */\n    exclusiveMaximum?: boolean;\n    /**\n     * Multiple of value restriction.\n     *\n     * @exclusiveMinimum 0\n     */\n    multipleOf?: number;\n  }\n}\nexport namespace OpenApiV3_0 {\n  export namespace IJsonSchema {\n    export interface INumber extends __IAttribute {\n      type: \"number\";\n      enum?: Array<number | null>;\n      nullable?: boolean;\n      default?: number | null;\n      minimum?: number;\n      maximum?: number;\n      exclusiveMinimum?: boolean;\n      exclusiveMaximum?: boolean;\n      /** @exclusiveMinimum 0 */ multipleOf?: number;\n    }\n  }\n}\nexport namespace OpenApi {\n  export namespace IJsonSchema {\n    export interface INumber extends __IAttribute {\n      type: \"number\";\n      default?: number;\n      minimum?: number;\n      maximum?: number;\n      exclusiveMinimum?: boolean;\n      exclusiveMaximum?: boolean;\n      /** @exclusiveMinimum 0 */ multipleOf?: number;\n    }\n    export interface IConstant extends __IAttribute {\n      const: boolean | number | string;\n    }\n    export interface INull extends __IAttribute {\n      type: \"null\";\n      default?: null;\n    }\n  }\n}\nIn the LLM function calling, the number type is expressed as above.Only one thing different with number and integer type is, whether to allow the decimal point or not. The number type allows the decimal point, but the integer type does not allow the decimal point. Therefore, member properties of number type are exactly same with integer type.\nDescription in the integer type is also applied to the number type.\nAt first, multipleOf means the value must be multiple of the assigned value. Therefore, if you assign an integer value to the multipleOf restricted type, your integer value must be possible to divid by the multipleOf value without any remainder.The other, minimum and maximum are the range restriction properties, and exclusiveMinimum and exclusiveMaximum are helper properties describing whether the minimum and maximum restrictions are prohibiting equal value or not. As default value of exclusiveMinimum and exclusiveMaximum are false, if only minimum or maximum is assigned, the value is allowed to be equal to the minimum or maximum value.\n💻 Playground Link\nimport typia, { tags } from \"typia\";\nconsole.log(\n  typia.json.application<\n    [ number & tags.MultipleOf<5.5>],\n    \"3.0\"\n  >(),\n  typia.createIs<number & tags.MultipleOf<5.5>>(),\n);\n  // {\n  //   type: \"number\",\n  //   multipleOf: 5.5,\n  // }\n  //-----------------------\n  // (input) => {\n  //   return \"number\" === typeof input && input % 5.5 === 0;\n  // }","string#String":"export namespace IOpenAiSchema {\n  /**\n   * String type schema info.\n   */\n  export interface IString extends __IAttribute {\n    /**\n     * Discriminator value of the type.\n     */\n    type: \"string\";\n    /**\n     * Enumeration values.\n     */\n    enum?: string[];\n    /**\n     * Whether to allow `null` value or not.\n     */\n    nullable?: boolean;\n    /**\n     * Default value.\n     */\n    default?: string;\n    /**\n     * Format restriction.\n     */\n    format?:\n      | \"binary\"\n      | \"byte\"\n      | \"password\"\n      | \"regex\"\n      | \"uuid\"\n      | \"email\"\n      | \"hostname\"\n      | \"idn-email\"\n      | \"idn-hostname\"\n      | \"iri\"\n      | \"iri-reference\"\n      | \"ipv4\"\n      | \"ipv6\"\n      | \"uri\"\n      | \"uri-reference\"\n      | \"uri-template\"\n      | \"url\"\n      | \"date-time\"\n      | \"date\"\n      | \"time\"\n      | \"duration\"\n      | \"json-pointer\"\n      | \"relative-json-pointer\"\n      | (string & {});\n    /**\n     * Pattern restriction.\n     */\n    pattern?: string;\n    /**\n     * Minimum length restriction.\n     *\n     * @type uint64\n     */\n    minLength?: number;\n    /**\n     * Maximum length restriction.\n     *\n     * @type uint64\n     */\n    maxLength?: number;\n    /**\n     * Content media type restriction.\n     */\n    contentMediaType?: string;\n    /**\n     * Secret key for the schema.\n     *\n     * `x-wrtn-secret-key` is a property means a secret key that is required\n     * for the target API endpoint calling. If the secret key is not filled,\n     * the API call would be failed.\n     */\n    \"x-wrtn-secret-key\"?: string;\n    /**\n     * Secret scopes for the schema.\n     *\n     * `x-wrtn-secret-scopes` is a property means a list of secret scopes that\n     * are required for the target API endpoint calling. If the secret scopes\n     * are not satisfied, the API call would be failed.\n     */\n    \"x-wrtn-secret-scopes\"?: string[];\n  }\n}\nexport namespace OpenApiV3_0 {\n  export namespace IJsonSchema {\n    export interface IString extends __IAttribute {\n      type: \"string\";\n      enum?: Array<string | null>;\n      nullable?: boolean;\n      default?: string | null;\n      format?:\n        | \"binary\"\n        | \"byte\"\n        | \"password\"\n        | \"regex\"\n        | \"uuid\"\n        | \"email\"\n        | \"hostname\"\n        | \"idn-email\"\n        | \"idn-hostname\"\n        | \"iri\"\n        | \"iri-reference\"\n        | \"ipv4\"\n        | \"ipv6\"\n        | \"uri\"\n        | \"uri-reference\"\n        | \"uri-template\"\n        | \"url\"\n        | \"date-time\"\n        | \"date\"\n        | \"time\"\n        | \"duration\"\n        | \"json-pointer\"\n        | \"relative-json-pointer\"\n        | (string & {});\n      pattern?: string;\n      /** @type uint64 */ minLength?: number;\n      /** @type uint64 */ maxLength?: number;\n    }\n  }\n}\nexport namespace OpenApi {\n  export namespace IJsonSchema {\n    export interface IString extends __IAttribute {\n      type: \"string\";\n      default?: string;\n      format?:\n        | \"binary\"\n        | \"byte\"\n        | \"password\"\n        | \"regex\"\n        | \"uuid\"\n        | \"email\"\n        | \"hostname\"\n        | \"idn-email\"\n        | \"idn-hostname\"\n        | \"iri\"\n        | \"iri-reference\"\n        | \"ipv4\"\n        | \"ipv6\"\n        | \"uri\"\n        | \"uri-reference\"\n        | \"uri-template\"\n        | \"url\"\n        | \"date-time\"\n        | \"date\"\n        | \"time\"\n        | \"duration\"\n        | \"json-pointer\"\n        | \"relative-json-pointer\"\n        | (string & {});\n      pattern?: string;\n      contentMediaType?: string;\n      /** @type uint64 */ minLength?: number;\n      /** @type uint64 */ maxLength?: number;\n    }\n    export interface IConstant extends __IAttribute {\n      const: boolean | number | string;\n    }\n    export interface INull extends __IAttribute {\n      type: \"null\";\n      default?: null;\n    }\n  }\n}\nIn the LLM function calling, the string type is expressed as above.As integer and number type have minimum and miximum properties, the string type has minLength and maxLength properties to restrict the length of the string. Also, the string type has special properties that other types do not have, such as format, pattern, and contentMediaType.The pattern is used for restricting the string value by the regular exression. If the string value does not match the regular expression, the value is not valid.The format is used for restricting the string value by the format. The format property is not a regular expression, but a predefined format string. If you want to see the predefined format strings, please refer to below links.\nJSON schema string format\nRegular expressions for format\nThe last contentMediaType is designed for restricting the media type of the string content. It can be used only when the format property is one of them. For reference, the contentMediaType does not affect to the string value validation, but just used for the documentation reason.\nbinary\nbyte\nuri\nurl\n💻 Playground Link\nimport typia, { tags } from \"typia\";\nconsole.log(\n  typia.json.application<\n    [string & tags.Format<\"uuid\"> & tags.MinLength<5> & tags.MaxLength<255>],\n    \"3.0\"\n  >(),\n  typia.createIs<\n    string & tags.Format<\"uuid\"> & tags.MinLength<5> & tags.MaxLength<255>\n  >(),\n);\n  // {\n  //   type: \"string\",\n  //   format: \"uuid\",\n  //   minLength: 5,\n  //   maxLength: 255,\n  // }\n  //-----------------------\n  // (input) => {\n  //   return (\n  //     \"string\" === typeof input &&\n  //     /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\n  //       input,\n  //     ) &&\n  //     5 <= input.length &&\n  //     input.length <= 255\n  //   );\n  // }","array#Array":"export namespace IOpenAiSchema {\n  /**\n   * Array type schema info.\n   */\n  export interface IArray extends __IAttribute {\n    /**\n     * Discriminator value of the type.\n     */\n    type: \"string\";\n    /**\n     * Whether to allow `null` value or not.\n     */\n    nullable?: boolean;\n    /**\n     * Items type schema info.\n     *\n     * The `items` means the type of the array elements. In other words, it is\n     * the type schema info of the `T` in the TypeScript array type `Array<T>`.\n     */\n    items: IOpenAiSchema;\n    /**\n     * Unique items restriction.\n     *\n     * If this property value is `true`, target array must have unique items.\n     */\n    uniqueItems?: boolean;\n    /**\n     * Minimum items restriction.\n     *\n     * Restriction of minumum number of items in the array.\n     *\n     * @type uint64\n     */\n    minItems?: number;\n    /**\n     * Maximum items restriction.\n     *\n     * Restriction of maximum number of items in the array.\n     *\n     * @type uint64\n     */\n    maxItems?: number;\n  }\n}\nexport namespace OpenApiV3_0 {\n  export namespace IJsonSchema {\n    export interface IArray extends __IAttribute {\n      type: \"array\";\n      nullable?: boolean;\n      items: IJsonSchema;\n      uniqueItems?: boolean;\n      /** @type uint64 */ minItems?: number;\n      /** @type uint64 */ maxItems?: number;\n    }\n  }\n}\nexport namespace OpenApi {\n  export namespace IJsonSchema {\n    export interface IArray<Schema extends IJsonSchema = IJsonSchema>\n      extends __IAttribute {\n      type: \"array\";\n      items: Schema;\n      uniqueItems?: boolean;\n      /** @type uint64 */ minItems?: number;\n      /** @type uint64 */ maxItems?: number;\n    }\n    export interface ITuple<Schema extends IJsonSchema = IJsonSchema>\n      extends __IAttribute {\n      type: \"array\";\n      prefixItems: Schema[];\n      additionalItems?: boolean | Schema;\n      uniqueItems?: boolean;\n      /** @type uint64 */ minItems?: number;\n      /** @type uint64 */ maxItems?: number;\n    }\n    export interface INull extends __IAttribute {\n      type: \"null\";\n      default?: null;\n    }\n  }\n}\nIn the LLM function calling, the array type is expressed as above.At first, items property is used for describing the type of the array elements. In the TypeScript, it is the type schema info of the T element type in the TypeScript array type Array<T>.The uniqueItems property is used for describing whether the array elements are unique or not. If the uniqueItems property is true, the array elements must be unique. Otherwise false or undefined, the array elements are not restricted to be unique.Also, minItems and maxItems properties are used for restricting the number of the array elements. The minItems property is used for describing the minimum number of the array elements, and the maxItems property is used for describing the maximum number of the array elements.By the way, as LLM function calling's type system is based on the OpenAPI v3.0 JSON schema specification, it is not possible to express TypeScript tuple type like [string, number, ...boolean[]] type. If you still enforce to express the tuple type, it would be expressed as an union type on the IOpenAiSchema.IArray.items property.\n💻 Playground Link\nimport typia, { tags } from \"typia\";\nconsole.log(\n  typia.json.application<[\n    Array<string & tags.Format<\"uuid\">> & tags.MinItems<1>,\n    Array<number> & tags.UniqueItems,\n    [string, number, ...boolean[]],\n  ], \"3.0\">(),\n);\n  // {\n  //   type: \"array\",\n  //   items: {\n  //     type: \"string\",\n  //     format: \"uuid\",\n  //   },\n  //   minItems: 1,\n  // },\n  // {\n  //   type: \"array\",\n  //   items: { type: \"number\" },\n  //   uniqueItems: true,\n  // },\n  // {\n  //   type: \"array\",\n  //   items: {\n  //     oneOf: [\n  //       { type: \"string\" },\n  //       { type: \"number\" },\n  //       { type: \"boolean\" },\n  //     ],\n  //   },\n  //   minItems: 2,\n  // }","object#Object":"export namespace IOpenAiSchema {\n  /**\n   * Object type schema info.\n   */\n  export interface IObject extends __IAttribute {\n    /**\n     * Discriminator value of the type.\n     */\n    type: \"string\";\n    /**\n     * Whether to allow `null` value or not.\n     */\n    nullable?: boolean;\n    /**\n     * Properties of the object.\n     *\n     * The `properties` means a list of key-value pairs of the object's\n     * regular properties. The key is the name of the regular property,\n     * and the value is the type schema info.\n     *\n     * If you need additional properties that is represented by dynamic key,\n     * you can use the {@link additionalProperties} instead.\n     */\n    properties?: Record<string, IOpenAiSchema>;\n    /**\n     * List of key values of the required properties.\n     *\n     * The `required` means a list of the key values of the required\n     * {@link properties}. If some property key is not listed in the `required`\n     * list, it means that property is optional. Otherwise some property key\n     * exists in the `required` list, it means that the property must be filled.\n     *\n     * Below is an example of the {@link properties} and `required`.\n     *\n     * ```typescript\n     * interface SomeObject {\n     *   id: string;\n     *   email: string;\n     *   name?: string;\n     * }\n     * ```\n     *\n     * As you can see, `id` and `email` {@link properties} are {@link required},\n     * so that they are listed in the `required` list.\n     *\n     * ```json\n     * {\n     *   \"type\": \"object\",\n     *   \"properties\": {\n     *     \"id\": { \"type\": \"string\" },\n     *     \"email\": { \"type\": \"string\" },\n     *     \"name\": { \"type\": \"string\" }\n     *   },\n     *   \"required\": [\"id\", \"email\"]\n     * }\n     * ```\n     */\n    required?: string[];\n    /**\n     * Additional properties' info.\n     *\n     * The `additionalProperties` means the type schema info of the additional\n     * properties that are not listed in the {@link properties}.\n     *\n     * If the value is `true`, it means that the additional properties are not\n     * restricted. They can be any type. Otherwise, if the value is\n     * {@link IOpenAiSchema} type, it means that the additional properties must\n     * follow the type schema info.\n     *\n     * - `true`: `Record<string, any>`\n     * - `IOpenAiSchema`: `Record<string, T>`\n     */\n    additionalProperties?: boolean | IOpenAiSchema;\n  }\n}\nexport namespace OpenApiV3_0 {\n  export namespace IJsonSchema {\n    export interface IObject extends __IAttribute {\n      type: \"object\",\n      nullable?: boolean;\n      properties?: Record<string, IJsonSchema>;\n      required?: string[];\n      additionalProperties?: boolean | IJsonSchema;\n      maxProperties?: number;\n      minProperties?: number;\n    }\n  }\n}\nexport namespace OpenApi {\n  export namespace IJsonSchema {\n    export interface IObject<Schema extends IJsonSchema = IJsonSchema>\n      extends __IAttribute {\n      type: \"object\";\n      properties?: Record<string, Schema>;\n      additionalProperties?: boolean | Schema;\n      required?: string[];\n    }\n    export interface INull extends __IAttribute {\n      type: \"null\";\n      default?: null;\n    }\n  }\n}\nIn the LLM function calling, the object type is expressed as above.The object type has properties and required properties. The properties property is used for describing the regular properties of the object, and the required property is used for describing the required properties of the object.For example, above example code in the second tab contains a TypeScript object type. In the type, there are four regular properties; id, name, age and configurations. In the above example TypeScript object definition, only id and configurations properties are required, and the others are optional. Therefore, the required property is configured as [\"id\", \"configurations\"].Also, the configurations property is a special property that is represented by the dynamic key-value pairs. The additionalProperties property is used for describing the type schema info of the additional properties that are not listed in the properties property; Record<string, T>.For reference, if you configure the additionalProperties property just as true, it means that type of the additional properties are not restricted, so that it is equivalent to the any type case; Record<string, any>. Otherwise the additionalProperties property configured as false, it means the object type does not allow any superfluous properties. In the undefined value case, it means that does not consider and validatea the superfluous properties.\n💻 Playground Link\nimport typia, { tags } from \"typia\";\nconsole.log(\n  typia.json.application<[\n    {\n      id: string & tags.Format<\"uuid\">;\n      name?: string;\n      age?: number & tags.Type<\"uint32\">;\n      configurations: {\n        [key: string]: boolean;\n      };\n    }\n  ], \"3.0\">(),\n);\n  // {\n  //   type: \"object\",\n  //   properties: {\n  //     id: {\n  //       type: \"string\",\n  //       format: \"uuid\",\n  //     },\n  //     name?: {\n  //       type: \"string\",\n  //     },\n  //     age: {\n  //       type: \"integer\",\n  //       minimum: 0,\n  //     },\n  //     configurations: {\n  //       type: \"object\",\n  //       properties: {},\n  //       additionalProperties: {\n  //         type: \"boolean\",\n  //       },\n  //     },\n  //   },\n  //   required: [\"id\", \"configurations\"],\n  // }","oneof#OneOf":"export namespace IOpenAiSchema {\n  /**\n   * One of type schema info.\n   *\n   * `IOneOf` represents an union type of the TypeScript (`A | B | C`).\n   *\n   * For reference, even though your Swagger (or OpenAPI) document has\n   * defined `anyOf` instead of the `oneOf`, {@link OpenAiComposer} forcibly\n   * converts it to `oneOf` type.\n   */\n  export interface IOneOf extends __IAttribute {\n    /**\n     * List of the union types.\n     */\n    oneOf: IOpenAiSchema[];\n  }\n}\nexport namespace OpenApiV3_0 {\n  export namespace IJsonSchema {\n    export interface IOneOf extends __IAttribute {\n      oneOf: IJsonSchema[];\n      discriminator?: IOneOf.IDiscriminator;\n    }\n    export namespace IOneOf {\n      export interface IDiscriminator {\n        propertyName: string;\n        mapping?: Record<string, string>;\n      }\n    }\n    export interface IReference<Key = string> extends __IAttribute {\n      $ref: Key;\n    }\n  }\n}\nexport namespace OpenApi {\n  export namespace IJsonSchema {\n    export interface IOneOf<Schema extends IJsonSchema = IJsonSchema>\n      extends __IAttribute {\n      oneOf: Exclude<Schema, IJsonSchema.IOneOf>[];\n      discriminator?: IOneOf.IDiscriminator;\n    }\n    export namespace IOneOf {\n      export interface IDiscriminator {\n        propertyName: string;\n        mapping?: Record<string, string>;\n      }\n    }\n    export interface IReference<Key = string> extends __IAttribute {\n      $ref: Key;\n    }\n  }\n}\nIn the LLM function calling, the oneOf type is expressed as above.The oneOf type is used for representing the union type of the TypeScript (A | B | C).By the way, as LLM function calling's type schema does not support the reference type ($ref), IOpenAiSchema.IOneOf type does not have the discriminator property which points the discriminator property in the oneOf type.","unknown#Unknown":"export namespace IOpenAiSchema {\n  /**\n   * Unknown type schema info.\n   *\n   * It means the type of the value is `any`.\n   */\n  export interface IUnknown extends __IAttribute {\n    /**\n     * Type is never be defined.\n     */\n    type?: undefined;\n  }\n}\nIn the LLM function calling schema, unknown type is expressed as above.Within framework of the TypeScript definition, it is equivalent any and unknown types.Of course, as the type is literally unknown, LLM cannot compose proper value for the type. Therefore, it would better to avoid to using the unknown (any) type when you are considering an API to be utilized by the LLM function calling."}},"/tech-specs/openapi/convert":{"title":"Convert","data":{"conversion#Conversion":"import { OpenApi } from \"@samchon/openapi\";\nimport fs from \"fs\";\nconst document: \n  | OpenApiV3_1.IDocument\n  | OpenApiV3.IDocument\n  | SwaggerV2.IDocument = JSON.parse(fs.readFileSync(\"swagger.json\", \"utf8\"));\nconst emended: OpenApi.IDocument = OpenApi.migrate(document);\nYou can easily convert your OpenAPI document to \"Wrtn Studio Pro\" is following.Just install @samchon/openapi library and call its OpenApi.convert() function. Then, whatever your OpenAPI document version is, your document would be converted to the emended OpenAPI v3.1 specified that \"Wrtn Studio Pro\" has adopted.By the way, is your document following the OpenAPI specs exactly, without any type error? Even though marketplace would reject invalid OpenAPI document uploading, you may want to validate it by yourself on your local machine. In that case, you can assert or validate the OpenAPI document type like below sections.","type-assertion#Type Assertion":"npm install typia @samchon/openapi\nnpx typia setup\nnpx ts-node src/assert.ts\nimport { OpenApi, OpenApiV3, OpenApiV3_1, SwaggerV2 } from \"@samchon/openapi\";\nimport typia from \"typia\";\nconst main = async (): Promise<void> => {\n  // GET YOUR OPENAPI DOCUMENT\n  const response: Response = await fetch(\n    \"https://raw.githubusercontent.com/samchon/openapi/master/examples/v3.0/openai.json\"\n  );\n  const document: any = await response.json();\n  // TYPE ASSERTION\n  typia.assertGuard<\n    | OpenApiV3_1.IDocument\n    | OpenApiV3.IDocument\n    | SwaggerV2.IDocument\n  >(document);\n  // CONVERT TO EMENDED\n  const emended: OpenApi.IDocument = OpenApi.convert(document);\n  console.log(emended);\n};\nmain().catch(console.error);\nYou can assert your OpenAPI document through the typia.assertGuard<T>() function.If there's any type error, the typia.assertGuard<T>() function would throws the TypeGuardError exception. Otherwise, it would return nothing, and the input type would be considered as the T type. Therefore, in the above example code, document type be casted to OpenApiV3_1.IDocument | OpenApiV3.IDocument | SwaggerV2.IDocument type after the typia.assertGuard<T>() function call.For referene, if your OpenAPI document is uploaded to somewhere URL, you can assert it right now. Just open the below playground link, and change the URL to yours. And then, click the \"execute\" button. You may see the result of the type assertion; TypeGuardError exception or the converted OpenApi.IDocument object.\n💻 Playground Link","detailed-validation#Detailed Validation":"import { OpenApi, OpenApiV3, OpenApiV3_1, SwaggerV2 } from \"@samchon/openapi\";\nimport typia from \"typia\";\nconst main = async (): Promise<void> => {\n  // GET YOUR OPENAPI DOCUMENT\n  const response: Response = await fetch(\n    \"https://raw.githubusercontent.com/samchon/openapi/master/examples/v3.0/openai.json\"\n  );\n  const document: any = await response.json();\n  // TYPE VALIDATION\n  const result = typia.validate<\n    | OpenApiV3_1.IDocument\n    | OpenApiV3.IDocument\n    | SwaggerV2.IDocument\n  >(document);\n  if (result.success === false) {\n    console.info(result.errors);\n    return;\n  }\n  // CONVERT TO EMENDED\n  const emended: OpenApi.IDocument = OpenApi.convert(document);\n  console.info(emended);\n};\nmain().catch(console.error);\nYou can validate your OpenAPI document, and get detailed every type error reasons through the typia.validate<T>() function.If there're some type errors, the typia.validate<T>() function would return the IValidation.IFailure object with detailed type error reasons. Otherwise, it would return the IValidation.ISuccess<T>() object with the type T casted input value.For reference, if your OpenAPI document is uploaded to somewhere URL, you can validate it right now. Just open the below playground link, and change the URL to yours. And then, click the \"execute\" button. You may see the result of the type validation; IValidation.IFailure object with detailed type error reasons or the converted OpenApi.IDocument object.\n💻 Playground Link"}},"/tech-specs/openapi/document":{"title":"Document","data":{"concepts#Concepts":"\"Wrtn Studio Pro\" has adopted OpenAPI specification with some emendations.\"Wrtn Studio Pro\" is utilizing the OpenAPI v3.1 specification, but as the OpenAPI v3.1 specification has too many ambiguous and duplicated expressions, \"Wrtn Studio Pro\" has emended the OpenAPI v3.1 specification to remove such ambiguous and duplicated expressions for the convenience and clarity.Here is the full definitions of every OpenAPI specifications and \"Wrtn Studio Pro\" utilizing emended OpenAPI v3.1 specification. For reference, if user takes an original OpenAPI v3.1 speicified document without emendation or previous versions than OpenAPI v3.1, \"Wrtn Studio Pro\" automatically converts it to the emended.\nOpenAPI v3.1 emended\nOpenAPI v3.1\nOpenAPI v3.0\nSwagger v2.0","definitions#Definitions":"","document#Document":"export namespace OpenApi {\n  /**\n   * OpenAPI document.\n   *\n   * `OpenApi.IDocument` represents an OpenAPI document of emended OpenAPI v3.1.\n   *\n   * In other words, `OpenApi.IDocument` is a structure of `swagger.json` file of\n   * OpenAPI v3.1 specification, but a little bit shrinked to remove ambiguous and\n   * duplicated expressions of OpenAPI v3.1 for the convenience and clarity.\n   *\n   * @template Schema JSON schema type\n   * @template Operation HTTP operation type\n   */\n  export interface IDocument<\n    Schema extends IJsonSchema = IJsonSchema,\n    Operation extends IOperation<Schema> = IOperation<Schema>,\n  > {\n    /**\n     * OpenAPI version number.\n     */\n    openapi: `3.1.${number}`;\n    /**\n     * List of servers that provide the API.\n     */\n    servers?: IServer[];\n    /**\n     * Information about the API.\n     */\n    info?: IDocument.IInfo;\n    /**\n     * An object to hold reusable data structures.\n     *\n     * It stores both DTO schemas and security schemes.\n     *\n     * For reference, `nestia` defines every object and alias types as reusable DTO\n     * schemas. The alias type means that defined by `type` keyword in TypeScript.\n     */\n    components: IComponents<Schema>;\n    /**\n     * The available paths and operations for the API.\n     *\n     * The 1st key is the path, and the 2nd key is the HTTP method.\n     */\n    paths?: Record<string, IPath<Schema, Operation>>;\n    /**\n     * An object to hold Webhooks.\n     *\n     * Its structure is same with {@link paths}, so that the 1st key is the path,\n     * and the 2nd key is the HTTP method.\n     */\n    webhooks?: Record<string, IPath<Schema, Operation>>;\n    /**\n     * A declaration of which security mechanisms can be used across the API.\n     *\n     * When this property be configured, it would be overwritten in every API routes.\n     *\n     * For reference, key means the name of security scheme and value means the `scopes`.\n     * The `scopes` can be used only when target security scheme is `oauth2` type,\n     * especially for {@link ISwaggerSecurityScheme.IOAuth2.IFlow.scopes} property.\n     */\n    security?: Record<string, string[]>[];\n    /**\n     * List of tag names with description.\n     *\n     * It is possible to omit this property or skip some tag name even if\n     * the tag name is used in the API routes. In that case, the tag name\n     * would be displayed (in Swagger-UI) without description.\n     */\n    tags?: IDocument.ITag[];\n    /**\n     * Flag for indicating this document is emended by `@samchon/openapi`.\n     */\n    \"x-samchon-emended\": true;\n  }\n  export namespace IDocument {\n    /**\n     * Information about the API.\n     */\n    export interface IInfo {\n      /**\n       * The title of the API.\n       */\n      title: string;\n      /**\n       * A short summary of the API.\n       */\n      summary?: string;\n      /**\n       * A full description of the API.\n       */\n      description?: string;\n      /**\n       * A URL to the Terms of Service for the API.\n       */\n      termsOfService?: string;\n      /**\n       * The contact information for the exposed API.\n       */\n      contact?: IContact;\n      /**\n       * The license information for the exposed API.\n       */\n      license?: ILicense;\n      /**\n       * Version of the API.\n       */\n      version: string;\n    }\n    /**\n     * OpenAPI tag information.\n     *\n     * It is possible to skip composing this structure, even if some\n     * tag names are regsitered in the API routes ({@link OpenApi.IOperation.tags}).\n     * In that case, the tag name would be displayed in Swagger-UI without\n     * description.\n     *\n     * However, if you want to describe the tag name, you can compose this\n     * structure and describe the tag name in the {@link description} property.\n     */\n    export interface ITag {\n      /**\n       * The name of the tag.\n       */\n      name: string;\n      /**\n       * An optional string describing the tag.\n       */\n      description?: string;\n    }\n    /**\n     * Contact information for the exposed API.\n     */\n    export interface IContact {\n      /**\n       * The identifying name of the contact person/organization.\n       */\n      name?: string;\n      /**\n       * The URL pointing to the contact information.\n       */\n      url?: string;\n      /**\n       * The email address of the contact person/organization.\n       *\n       * @format email\n       */\n      email?: string;\n    }\n    /**\n     * License information for the exposed API.\n     */\n    export interface ILicense {\n      /**\n       * The license name used for the API.\n       */\n      name: string;\n      /**\n       * Identifier for the license used for the API.\n       *\n       * example: MIT\n       */\n      identifier?: string;\n      /**\n       * A URL to the license used for the API.\n       */\n      url?: string;\n    }\n  }\n}\nIn the OpenAPI specification, document is the root object of the OpenAPI document.At first, the documenet provides the version of the OpenAPI specification through the openapi property. As \"Wrtn Studio Pro\" has adopted the OpenAPI v3.1 speicification with some emendations, the openapi property is always set to 3.1.x, where x is a number. Also, the documents contains metata information of the API, such as the title, version, and contact information through the OpenApi.IDocument.info property.At second, the document object includes the path and webhooks properties. Through these path and webhooks properties and their nested OpenApi.IOperation structured objects, document defines the API's endpoints (method + path) and which parameter and request/response body types are required for the endpoint execution. Also, document object supports the tags property to categorize the API's endpoints, and contains the components property storing the reusable data structures, such as DTO schemas and security schemes as named types.At last, the document object includes the security property declaring which security mechanisms would be adjusted to every API endpoints.","server#Server":"export namespace OpenApi {\n  /**\n   * The remote server that provides the API.\n   */\n  export interface IServer {\n    /**\n     * A URL to the target host.\n     */\n    url: string;\n    /**\n     * An optional string describing the target server.\n     */\n    description?: string;\n    /**\n     * A map between a variable name and its value.\n     *\n     * When the server {@link url} is a type of template, this property\n     * would be utilized to fill the template with actual values.\n     */\n    variables?: Record<string, IServer.IVariable>;\n  }\n  export namespace IServer {\n    /**\n     * A variable for the server URL template.\n     */\n    export interface IVariable {\n      /**\n       * Default value to use for substitution.\n       */\n      default: string;\n      /**\n       * List of available values for the variable.\n       */\n      enum?: string[];\n      /**\n       * An optional description for the server variable.\n       */\n      description?: string;\n    }\n  }\n  export interface IDocument {\n    openapi: `3.1.${number}`;\n    servers?: IServer[];\n    info?: IDocument.IInfo;\n    components: IComponents;\n    paths?: Record<string, IPath>;\n    webhooks?: Record<string, IPath>;\n    security?: Record<string, string[]>[];\n    tags?: IDocument.ITag[];\n    \"x-samchon-emended\": true;\n  }\n  export interface IOperation {\n    operationId?: string;\n    parameters?: IOperation.IParameter[];\n    requestBody?: IOperation.IRequestBody;\n    responses?: Record<string, IOperation.IResponse>;\n    servers?: IServer[];\n    summary?: string;\n    description?: string;\n    security?: Record<string, string[]>[];\n    tags?: string[];\n    deprecated?: boolean;\n  }\n}\nIn the OpenAPI definition, server is an object representing the remote server that providing the API.The server object contains the url property, which is the URL of the target host. You can compose the actual API endpoints just by concatenating the server.url and path of the target operation. Sometimes, the server provide the additional property description, and variables to fill the URL template with actual values.Also, the server objects can be defined in both document.servers and operation.servers properties. If a server is defined in the document.servers property, it means that the server's url and its variables (optional) would be applied to every API operations. Otherwise if a server is defined in the operation.servers property, it means that the operation is an exceptional case, so that only the operation uses independent server information.For reference, it is possible to declare multiple server instances in both document.servers and operation.servers properties. Such multiple servers are used for separating real/development/local server addresses in the most cases. Therefore, in the multiple servers case, please read the description property carefully to distinguish the server's purpose.","operation#Operation":"export namespace OpenApi {\n  /**\n   * Path item.\n   *\n   * `OpenApi.IPath` represents a path item of emended OpenAPI v3.1,\n   * collecting multiple method operations in a single path.\n   */\n  export interface IPath<\n    Schema extends IJsonSchema = IJsonSchema,\n    Operation extends IOperation<Schema> = IOperation<Schema>,\n  > extends Partial<Record<Method, Operation>> {\n    /**\n     * Servers that provide the path operations.\n     */\n    servers?: IServer[];\n    /**\n     * Summary of the path.\n     */\n    summary?: string;\n    /**\n     * Description of the path.\n     */\n    description?: string;\n  }\n  /**\n   * Remote operation info.\n   *\n   * `OpenApi.IOperation` represents an Restful API operation provided by the\n   * remote server.\n   */\n  export interface IOperation<Schema extends IJsonSchema = IJsonSchema> {\n    /**\n     * Unique string used to identify the operation.\n     */\n    operationId?: string;\n    /**\n     * List of parameters that are applicable for this operation.\n     */\n    parameters?: IOperation.IParameter<Schema>[];\n    /**\n     * The request body applicable for this operation.\n     */\n    requestBody?: IOperation.IRequestBody<Schema>;\n    /**\n     * The list of possible responses as they are returned from executing this\n     * operation. Its key is the HTTP status code, and the value is the metadata of\n     * the response in the HTTP status code.\n     */\n    responses?: Record<string, IOperation.IResponse<Schema>>;\n    /**\n     * A list of servers providing this API operation.\n     */\n    servers?: IServer[];\n    /**\n     * A short summary of what the operation does.\n     */\n    summary?: string;\n    /**\n     * A verbose explanation of the operation behavior.\n     */\n    description?: string;\n    /**\n     * List of securities and their scopes that are required for execution.\n     *\n     * When this property be configured, the Restful API operation requires\n     * the matched security value for exection. Its key means security key\n     * matched with {@link OpenApi.IDocument.security}.\n     *\n     * The value means scopes required for the security key when the security\n     * type is {@link OpenApi.ISecurityScheme.IOAuth2}. Otherwise the target\n     * security type is not {@link OpenApi.ISecurityScheme.IOAuth2}, the value\n     * would be empty array.\n     */\n    security?: Record<string, string[]>[];\n    /**\n     * Tags for API documentation control.\n     */\n    tags?: string[];\n    /**\n     * Flag for indicating this operation is deprecated.\n     */\n    deprecated?: boolean;\n  }\n  export namespace IOperation {\n    /**\n     * Parameter of the operation.\n     */\n    export interface IParameter<Schema extends IJsonSchema = IJsonSchema> {\n      /**\n       * Representative name of the parameter.\n       *\n       * In the most case, the `name` is equivalent to parameter variable name.\n       * Therefore, the `name` must be filled with the significant variable name\n       * of the parameter.\n       *\n       * By the way, only when the {@link in} property is `path`, the `name`\n       * can be omitted. In that case, the `name` is automatically deduced from\n       * the URL path's positional template argument analyzing.\n       */\n      name?: string;\n      /**\n       * Location of the parameter.\n       *\n       * The `in` property is a string that determines the location of the parameter.\n       *\n       * - `path`: parameter is part of the path of the URL.\n       * - `query`: parameter is part of the query string.\n       * - `header`: parameter is part of the header.\n       * - `cookie`: parameter is part of the cookie.\n       */\n      in: \"path\" | \"query\" | \"header\" | \"cookie\";\n      /**\n       * Type info of the parameter.\n       */\n      schema: Schema;\n      /**\n       * Whether the parameter is required for execution or not.\n       *\n       * If the parameter is required, the value must be filled. Otherwise,\n       * it is possible to skip the parameter when executing the APi operation.\n       *\n       * For reference, the `required` property must be always `true` when the\n       * {@link in} property is `path`. Otherwise, the `required` property can\n       * be anything of them; `true`, `false` and `undefined`.\n       */\n      required?: boolean;\n      /**\n       * Short title of the parameter.\n       */\n      title?: string;\n      /**\n       * Verbose explanation of the parameter.\n       */\n      description?: string;\n      /**\n       * Example value of the parameter.\n       */\n      example?: any;\n      /**\n       * Collection of example values of the parameter with keys.\n       */\n      examples?: Record<string, IExample>;\n    }\n    /**\n     * Request body of the operation.\n     */\n    export interface IRequestBody<Schema extends IJsonSchema = IJsonSchema> {\n      content?: IContent<Schema>;\n      description?: string;\n      required?: boolean;\n      \"x-nestia-encrypted\"?: boolean;\n    }\n    /**\n     * Response of the operation.\n     */\n    export interface IResponse<Schema extends IJsonSchema = IJsonSchema> {\n      headers?: Record<string, IOperation.IParameter<Schema>>;\n      content?: IContent<Schema>;\n      description?: string;\n      \"x-nestia-encrypted\"?: boolean;\n    }\n    /**\n     * List of content types supported in request/response body.\n     */\n    export type IContent<Schema extends IJsonSchema = IJsonSchema> = Partial<\n      Record<ContentType, IMediaType<Schema>>\n    >;\n    /**\n     * Media type of a request/response body.\n     */\n    export interface IMediaType<Schema extends IJsonSchema = IJsonSchema> {\n      schema?: Schema;\n      example?: any;\n      examples?: Record<string, IExample>;\n    }\n    /**\n     * List of supported content media types.\n     */\n    export type ContentType =\n      | \"text/plain\"\n      | \"application/json\"\n      | \"application/x-www-form-url-encoded\"\n      | \"multipart/form-data\"\n      | \"*/*\"\n      | (string & {});\n  }\n}\nIn the OpenAPI definition, OpenApi.IOperationn is an object representing the Restful API function.It is stored in the OpenApi.IDocument.paths property of two-dimensional dictionary structure (Map<string, Map<string, Operation>>); the 1st key is the path and the 2nd key is the HTTP method. Also, it sometimes has a OpenApi.IOperation.servers property when the operation is provided by another server url.OpenApi.IOperation object contains the descriptive information of the operation, such as summary and description. The summary is a short summary of what the operation does, and the description is a verbose explanation of the operation behavior. For reference, those descriptive properties are very important to understand the operation's purpose and behavior to the LLM (Large Language Model) function calling, so that hope to describe them as detailed as possible.At last, the OpenApi.IOperation object has additional properties tags and deprecated. The tags property is used for API documentation level categorizing, and the deprecated property is used for indicating the operation is deprecated or not. When the deprecated property be turned on, the operation is still alive, but means to be removed in the future.","parameter#Parameter":"export namespace OpenApi {\n  export interface IOperation<Schema extends IJsonSchema = IJsonSchema> {\n    operationId?: string;\n    parameters?: IOperation.IParameter<Schema>[];\n    requestBody?: IOperation.IRequestBody<Schema>;\n    responses?: Record<string, IOperation.IResponse<Schema>>;\n    servers?: IServer[];\n    summary?: string;\n    description?: string;\n    security?: Record<string, string[]>[];\n    tags?: string[];\n    deprecated?: boolean;\n  }\n  export namespace IOperation {\n    /**\n     * Parameter of the operation.\n     */\n    export interface IParameter<Schema extends IJsonSchema = IJsonSchema> {\n      /**\n       * Representative name of the parameter.\n       *\n       * In the most case, the `name` is equivalent to parameter variable name.\n       * Therefore, the `name` must be filled with the significant variable name\n       * of the parameter.\n       *\n       * By the way, only when the {@link in} property is `path`, the `name`\n       * can be omitted. In that case, the `name` is automatically deduced from\n       * the URL path's positional template argument analyzing.\n       */\n      name?: string;\n      /**\n       * Location of the parameter.\n       *\n       * The `in` property is a string that determines the location of the parameter.\n       *\n       * - `path`: parameter is part of the path of the URL.\n       * - `query`: parameter is part of the query string.\n       * - `header`: parameter is part of the header.\n       * - `cookie`: parameter is part of the cookie.\n       */\n      in: \"path\" | \"query\" | \"header\" | \"cookie\";\n      /**\n       * Type info of the parameter.\n       */\n      schema: Schema;\n      /**\n       * Whether the parameter is required for execution or not.\n       *\n       * If the parameter is required, the value must be filled. Otherwise,\n       * it is possible to skip the parameter when executing the APi operation.\n       *\n       * For reference, the `required` property must be always `true` when the\n       * {@link in} property is `path`. Otherwise, the `required` property can\n       * be anything of them; `true`, `false` and `undefined`.\n       */\n      required?: boolean;\n      /**\n       * Short title of the parameter.\n       */\n      title?: string;\n      /**\n       * Verbose explanation of the parameter.\n       */\n      description?: string;\n      /**\n       * Example value of the parameter.\n       */\n      example?: any;\n      /**\n       * Collection of example values of the parameter with keys.\n       */\n      examples?: Record<string, IExample>;\n    }\n  }\n}\nIn the OpenAPI definition, OpenApi.IOperation.IParameter is an object representing the parameter of the API operation. For reference, in OpenAPI spec, the word \"parameter\" does not contain the request body. It covers only the parameters in the URL \"path\", \"query\", \"header\", and \"cookie\".In the OpenApi.IOperation.IParameter member properties, name property represents a variable name of the parameter, and in property means the category of the parameter. Also, if the parameter category (in) is \"path\", the parameter name can be optional. In that case, \"Wrtn Studio Pro\" duduces the parameter name through the URL path's positional template argument analyzing.Type schema information is stored in the schema property as an OpenApi.IJsonSchema instance, and the required property is used for indicating whether the parameter is essential for the API operation execution or not. By the way, if the category (in) of the parameter is \"path\", the required property must be always true.At last, the OpenApi.IOperation.IParameter object has additional descriptive properties title and description. The title property is a short title of the parameter, and the description property is a verbose explanation of the parameter. For reference, those descriptive properties are very important to understand the parameter's purpose and behavior to the LLM (Large Language Model) function calling, so that hope to describe them as detailed as possible.","requestresponse-body#Request/Response Body":"export namespace OpenApi {\n  export interface IOperation<Schema extends IJsonSchema = IJsonSchema> {\n    operationId?: string;\n    parameters?: IOperation.IParameter<Schema>[];\n    requestBody?: IOperation.IRequestBody<Schema>;\n    responses?: Record<string, IOperation.IResponse<Schema>>;\n    servers?: IServer[];\n    summary?: string;\n    description?: string;\n    security?: Record<string, string[]>[];\n    tags?: string[];\n    deprecated?: boolean;\n  }\n  export namespace IOperation {\n    /**\n     * Request body of the operation.\n     */\n    export interface IRequestBody<Schema extends IJsonSchema = IJsonSchema> {\n      content?: IContent<Schema>;\n      description?: string;\n      required?: boolean;\n      \"x-nestia-encrypted\"?: boolean;\n    }\n    /**\n     * Response of the operation.\n     */\n    export interface IResponse<Schema extends IJsonSchema = IJsonSchema> {\n      headers?: Record<string, IOperation.IParameter<Schema>>;\n      content?: IContent<Schema>;\n      description?: string;\n      \"x-nestia-encrypted\"?: boolean;\n    }\n    /**\n     * List of content types supported in request/response body.\n     */\n    export type IContent<Schema extends IJsonSchema = IJsonSchema> = Partial<\n      Record<ContentType, IMediaType<Schema>>\n    >;\n    /**\n     * Media type of a request/response body.\n     */\n    export interface IMediaType<Schema extends IJsonSchema = IJsonSchema> {\n      schema?: Schema;\n      example?: any;\n      examples?: Record<string, IExample>;\n    }\n    /**\n     * List of supported content media types.\n     */\n    export type ContentType =\n      | \"text/plain\"\n      | \"application/json\"\n      | \"application/x-www-form-url-encoded\"\n      | \"multipart/form-data\"\n      | \"*/*\"\n      | (string & {});\n  }\n}\nIn the OpenAPI specification, OpenApi.IOperation.IRequestBody and OpenApi.IOperation.IResponse are objects representing the request/response body of the API operation, and they are stored in the OpenApi.IOperation.requestBody and OpenApi.IOperation.responses properties.At first, OpenApi.IOperation.IRequestBody has three properties; content, description and required. As you know can from the property name, description is a verbose explanation of the request body, and required is a flag indicating whether the request body is essential for the API operation execution or not. The other content property is a dictionary structure of the request body's content types and their media types. In the media type (OpenApi.IOperation.IMediaType), the type schema information of the request body is enrolled in the schema property.About the OpenApi.IOperation.responses property is a type of dictionary that the key is the HTTP status code and the value is the metadata of the response in the HTTP status code. OpenApi.IOperation.IResponse is almost same with the OpenApi.IOperation.IRequestBody case, but OpenApi.IOperation.IResponse has an additional property headers that which header values are responsed from executing the operation.At last, there are many content types supported in the request/response body, but \"Wrtn Studio Pro\" handles only the following content types. It is possible to providing the other content types to \"Wrtn Studio Pro\", but only below types can be executed by LLM function calling in the \"Wrtn Studio Pro\".\ntext/plain\napplication/json\napplication/x-www-form-url-encoded\nmultipart/form-data","security-scheme#Security Scheme":"export namespace OpenApi {\n  /**\n   * Security scheme of Swagger Documents.\n   *\n   * `OpenApi.ISecurityScheme` is a data structure representing content of\n   * `securitySchemes` in `swagger.json` file. It is composed with 5 types of\n   * security schemes as an union type like below.\n   *\n   * @reference https://swagger.io/specification/#security-scheme-object\n   */\n  export type ISecurityScheme =\n    | ISecurityScheme.IApiKey\n    | ISecurityScheme.IHttpBasic\n    | ISecurityScheme.IHttpBearer\n    | ISecurityScheme.IOAuth2\n    | ISecurityScheme.IOpenId;\n  export namespace ISecurityScheme {\n    /**\n     * Normal API key type.\n     */\n    export interface IApiKey {\n      type: \"apiKey\";\n      in?: \"header\" | \"query\" | \"cookie\";\n      name?: string;\n      description?: string;\n    }\n    /**\n     * HTTP basic authentication type.\n     */\n    export interface IHttpBasic {\n      type: \"http\";\n      scheme: \"basic\";\n      description?: string;\n    }\n    /**\n     * HTTP bearer authentication type.\n     */\n    export interface IHttpBearer {\n      type: \"http\";\n      scheme: \"bearer\";\n      bearerFormat?: string;\n      description?: string;\n    }\n    /**\n     * OAuth2 authentication type.\n     */\n    export interface IOAuth2 {\n      type: \"oauth2\";\n      flows: IOAuth2.IFlowSet;\n      description?: string;\n    }\n    export interface IOpenId {\n      type: \"openIdConnect\";\n      openIdConnectUrl: string;\n      description?: string;\n    }\n    export namespace IOAuth2 {\n      export interface IFlowSet {\n        authorizationCode?: IFlow;\n        implicit?: Omit<IFlow, \"tokenUrl\">;\n        password?: Omit<IFlow, \"authorizationUrl\">;\n        clientCredentials?: Omit<IFlow, \"authorizationUrl\">;\n      }\n      export interface IFlow {\n        authorizationUrl?: string;\n        tokenUrl?: string;\n        refreshUrl?: string;\n        scopes?: Record<string, string>;\n      }\n    }\n  }\n  export interface IComponents<Schema extends IJsonSchema = IJsonSchema> {\n    schemas?: Record<string, Schema>;\n    securitySchemes?: Record<string, ISecurityScheme>;\n  }\n  export interface IDocument<\n    Schema extends IJsonSchema = IJsonSchema,\n    Operation extends IOperation<Schema> = IOperation<Schema>,\n  > {\n    openapi: `3.1.${number}`;\n    servers?: IServer[];\n    info?: IDocument.IInfo;\n    components: IComponents<Schema>;\n    paths?: Record<string, IPath<Schema, Operation>>;\n    webhooks?: Record<string, IPath<Schema, Operation>>;\n    security?: Record<string, string[]>[];\n    tags?: IDocument.ITag[];\n    \"x-samchon-emended\": true;\n  }\n  export interface IOperation<Schema extends IJsonSchema = IJsonSchema> {\n    operationId?: string;\n    parameters?: IOperation.IParameter<Schema>[];\n    requestBody?: IOperation.IRequestBody<Schema>;\n    responses?: Record<string, IOperation.IResponse<Schema>>;\n    servers?: IServer[];\n    summary?: string;\n    description?: string;\n    security?: Record<string, string[]>[];\n    tags?: string[];\n    deprecated?: boolean;\n  }\n}\nIn the OpenAPI definition, OpenApi.ISecurityScheme is an union type representing the security scheme of the API. It is placed on the OpenApi.IComponents.securitySchemes property, and referenced by the OpenApi.IDocument.security and OpenApi.IOperation.security properties.When OpenApi.IDocument.security and OpenApi.IOperation.security are referencing the security schemes, its key is the name of the security schema, and the value is the scopes required for the security scheme. The scopes can be used only when the security scheme is oauth2 type, especially for the OpenApi.ISecurityScheme.IOAuth2.IFlow.scopes property. If the target security scheme is not oauth2 type, the scopes value would be an empty array.About individual schema types of the OpenApi.ISecurityScheme, there are 5 types of security schemes. The first OpenApi.ISecurityScheme.IApiKey is a normal API key type, and the second OpenApi.ISecurityScheme.IHttpBasic is an HTTP basic authentication type. The third OpenApi.ISecurityScheme.IHttpBearer is an HTTP bearer authentication type, and the fourth OpenApi.ISecurityScheme.IOAuth2 is an OAuth2 authentication type. The last OpenApi.ISecurityScheme.IOpenId is an OpenID Connect authentication type.","detailed-emendations#Detailed Emendations":"","document-1#Document":"export namespace OpenApi {\n  export interface IDocument<\n    Schema extends IJsonSchema = IJsonSchema,\n    Operation extends IOperation<Schema> = IOperation<Schema>,\n  > {\n    openapi: `3.1.${number}`;\n    servers?: IServer[];\n    info?: IDocument.IInfo;\n    components: IComponents<Schema>;\n    paths?: Record<string, IPath<Schema, Operation>>;\n    webhooks?: Record<string, IPath<Schema, Operation>>;\n    security?: Record<string, string[]>[];\n    tags?: IDocument.ITag[];\n    \"x-samchon-emended\": true;\n  }\n  export interface IComponents<Schema extends IJsonSchema = IJsonSchema> {\n    schemas?: Record<string, Schema>;\n    securitySchemes?: Record<string, ISecurityScheme>;\n  }\n}\nexport namespace OpenApiV3_1 {\n  export interface IDocument {\n    openapi: `3.1.${number}`;\n    servers?: IServer[];\n    info?: IDocument.IInfo;\n    components?: IComponents;\n    paths?: Record<string, IPath>;\n    webhooks?: Record<\n      string,\n      | IJsonSchema.IReference<`#/components/pathItems/${string}`> \n      | IPath\n    >;\n    security?: Record<string, string[]>[];\n    tags?: IDocument.ITag[];\n  }\n  export interface IComponents {\n    schemas?: Record<string, IJsonSchema>;\n    pathItems?: Record<string, IPath>;\n    responses?: Record<string, IOperation.IResponse>;\n    parameters?: Record<string, IOperation.IParameter>;\n    requestBodies?: Record<string, IOperation.IRequestBody>;\n    securitySchemes?: Record<string, ISecurityScheme>;\n    headers?: Record<string, Omit<IOperation.IParameter, \"in\">>;\n    examples?: Record<string, IExample>;\n  }\n}\nIn the original OpenAPI v3.1 specification, the OpenApiV3_1.IDocument object has an union value typed dynamic record property webhooks. Its values can reference OpenApiV3_1.IComponents object or contain the OpenApiV3_1.IPath objet directly.By the way, OpenApiV3_1.IDocument.paths property is a little bit different with the OpenApiV3_1.IDocument case. Even though its containing value type is exactly equal to the OpenApiV3_1.IDocument.webhooks property, the OpenApiV3_1.IDocument.paths property is not union typed, it cannot reference OpenApiV3_1.IComponents object. Therefore, OpenApiV3_1.IDocument.webhooks can reference the OpenApiV3_1.IComponents object, but it is not suitable for the reusability.To resolve the ambiguous expression of the OpenApiV3_1.IDocument.webhooks property type, OpenApi.IDocument object has been emended to contain the OpenApiV3_1.IDocument.webhooks property as a direct OpenApi.IPath object. If OpenApiV3_1.IDocument.paths was also possible to reference the OpenApiV3_1.IComponents object, I may consider to keeping the OpenApiV3_1.IDocument.webhooks's union value type for reusability, but as you can see, it is not.Anyway, by removing the union typed dynamic record property, the OpenApi.IDocument object becomes more clear and concise. The OpenApi.IDocument becomes significant root object without referencing to nested, and OpenApi.IComponents object is only used for storing the reusable data structures, such as DTO schemas and security schemes.","path#Path":"export namespace OpenApi {\n  export interface IPath<\n    Schema extends IJsonSchema = IJsonSchema,\n    Operation extends IOperation<Schema> = IOperation<Schema>,\n  > extends Partial<Record<Method, Operation>> {\n    servers?: IServer[];\n    summary?: string;\n    description?: string;\n  }\n  export interface IComponents<Schema extends IJsonSchema = IJsonSchema> {\n    schemas?: Record<string, Schema>;\n    securitySchemes?: Record<string, ISecurityScheme>;\n  }\n}\nexport namespace OpenApiV3_1 {\n  export interface IPath extends Partial<Record<Method, IOperation>> {\n    parameters?: Array<\n      | IOperation.IParameter\n      | IJsonSchema.IReference<`#/components/headers/${string}`>\n      | IJsonSchema.IReference<`#/components/parameters/${string}`>\n    >;\n    servers?: IServer[];\n    summary?: string;\n    description?: string;\n  }\n  export interface IOperation {\n    operationId?: string;\n    parameters?: Array<\n      | IOperation.IParameter\n      | IJsonSchema.IReference<`#/components/headers/${string}`>\n      | IJsonSchema.IReference<`#/components/parameters/${string}`>\n    >;\n    requestBody?:\n      | IOperation.IRequestBody\n      | IJsonSchema.IReference<`#/components/requestBodies/${string}`>;\n    responses?: Record<\n      string,\n      | IOperation.IResponse\n      | IJsonSchema.IReference<`#/components/responses/${string}`>\n    >;\n    servers?: IServer[];\n    summary?: string;\n    description?: string;\n    security?: Record<string, string[]>[];\n    tags?: string[];\n    deprecated?: boolean;\n  }\n  export interface IComponents {\n    schemas?: Record<string, IJsonSchema>;\n    pathItems?: Record<string, IPath>;\n    responses?: Record<string, IOperation.IResponse>;\n    parameters?: Record<string, IOperation.IParameter>;\n    requestBodies?: Record<string, IOperation.IRequestBody>;\n    securitySchemes?: Record<string, ISecurityScheme>;\n    headers?: Record<string, Omit<IOperation.IParameter, \"in\">>;\n    examples?: Record<string, IExample>;\n  }\n}\nIn the original OpenAPI v3.1 specification, the OpenApiV3_1.IPath object can contain parameters property, which can be applied to all operations belonged to the path. If both OpenApiV3_1.IPath and belonged OpenApiV3_1.IOperation objects have their own parameters properties, the OpenApiV3_1.IPath's parameters would be attached to in front of the operation's parameters.As OpenApiV3_1.IPath.parameters property is such ambiguous and duplicated with the OpenApiV3_1.IOperation.parameters property, \"Wrtn Studio Pro\" removes the OpenApi.IPath.parameters property and move it to the children OpenApi.IOperation's parameters property.By removing the OpenApiV3_1.IPath.parameters property, the OpenApi.IPath object comes only a collection of operations with the same path value. Also, only OpenApi.IOperation object handles the properties about the operation subject, the \"Wrtn Studio Pro\" emended OpenAPI specification becomes more clear and concise.","operation-1#Operation":"export namespace OpenApi {\n  export interface IOperation<Schema extends IJsonSchema = IJsonSchema> {\n    operationId?: string;\n    parameters?: IOperation.IParameter<Schema>[];\n    requestBody?: IOperation.IRequestBody<Schema>;\n    responses?: Record<string, IOperation.IResponse<Schema>>;\n    servers?: IServer[];\n    summary?: string;\n    description?: string;\n    security?: Record<string, string[]>[];\n    tags?: string[];\n    deprecated?: boolean;\n  }\n  export interface IComponents<Schema extends IJsonSchema = IJsonSchema> {\n    schemas?: Record<string, Schema>;\n    securitySchemes?: Record<string, ISecurityScheme>;\n  }\n}\nexport namespace OpenApiV3_1 {\n  export interface IOperation {\n    operationId?: string;\n    parameters?: Array<\n      | IOperation.IParameter\n      | IJsonSchema.IReference<`#/components/headers/${string}`>\n      | IJsonSchema.IReference<`#/components/parameters/${string}`>\n    >;\n    requestBody?:\n      | IOperation.IRequestBody\n      | IJsonSchema.IReference<`#/components/requestBodies/${string}`>;\n    responses?: Record<\n      string,\n      | IOperation.IResponse\n      | IJsonSchema.IReference<`#/components/responses/${string}`>\n    >;\n    servers?: IServer[];\n    summary?: string;\n    description?: string;\n    security?: Record<string, string[]>[];\n    tags?: string[];\n    deprecated?: boolean;\n  }\n  export interface IComponents {\n    schemas?: Record<string, IJsonSchema>;\n    pathItems?: Record<string, IPath>;\n    responses?: Record<string, IOperation.IResponse>;\n    parameters?: Record<string, IOperation.IParameter>;\n    requestBodies?: Record<string, IOperation.IRequestBody>;\n    securitySchemes?: Record<string, ISecurityScheme>;\n    headers?: Record<string, Omit<IOperation.IParameter, \"in\">>;\n    examples?: Record<string, IExample>;\n  }\n}\nIn the original OpenAPI v3.1 specification, the OpenApiV3_1.IOperation object has many union typed properties which references OpenApiV3_1.IComponents or contains metadata information by itself; parameters, requestBody and responses.However, as \"Wrtn Studio Pro\" tends to avoid indirect referencing to the components object for the convenience and clarity, the OpenApi.IOperation object's union typed properties has emended to containn the metadata information by itself.By revmoing such indirect referencing, the OpenApi.IOperation object becomes more clear and concise. It always contains the metadata information of operation by itself, and the OpenApi.IComponents object is only used for storing the reusable data structures, such as DTO schemas and security schemes.","parameter-1#Parameter":"export namespace OpenApi {\n  export namespace IOperation {\n    export interface IParameter<Schema extends IJsonSchema = IJsonSchema> {\n      name?: string;\n      in: \"path\" | \"query\" | \"header\" | \"cookie\";\n      schema: Schema;\n      required?: boolean;\n      title?: string;\n      description?: string;\n      example?: any;\n      examples?: Record<string, IExample>;\n    }\n  }\n  export interface IComponents<Schema extends IJsonSchema = IJsonSchema> {\n    schemas?: Record<string, Schema>;\n    securitySchemes?: Record<string, ISecurityScheme>;\n  }\n  export interface IExample {\n    summary?: string;\n    description?: string;\n    value?: any;\n    externalValue?: string;\n  }\n}\nexport namespace OpenApiV3_1 {\n  export namespace IOperation {\n    export interface IParameter {\n      name?: string;\n      in: \"path\" | \"query\" | \"header\" | \"cookie\";\n      schema: IJsonSchema;\n      required?: boolean;\n      description?: string;\n      example?: any;\n      examples?: Record<\n        string,\n        IExample | IJsonSchema.IReference<`#/components/examples/${string}`>\n      >;\n    }\n  }\n  export interface IComponents {\n    schemas?: Record<string, IJsonSchema>;\n    pathItems?: Record<string, IPath>;\n    responses?: Record<string, IOperation.IResponse>;\n    parameters?: Record<string, IOperation.IParameter>;\n    requestBodies?: Record<string, IOperation.IRequestBody>;\n    securitySchemes?: Record<string, ISecurityScheme>;\n    headers?: Record<string, Omit<IOperation.IParameter, \"in\">>;\n    examples?: Record<string, IExample>;\n  }\n  export interface IExample {\n    summary?: string;\n    description?: string;\n    value?: any;\n    externalValue?: string;\n  }\n}\nIn the original OpenAPI v3.1 specification, the OpenApiV3_1.IOperation.IParameter has examples property, and the examples has an union typed value which references OpenApiV3_1.IComponents or contains the example value by itself.However, as \"Wrtn Studio Pro\" tends to avoid indirect referencing to the components object for the convenience and clarity, the OpenApi.IOperation.IParameter.examples has emended to only contain the example values by itself, instead of referencing the components object.By revmoing such indirect referencing, the OpenApi.IOperation.IParameter object becomes more clear and concise. It always contains the metadata information of operation by itself, and the OpenApi.IComponents object is only used for storing the reusable data structures, such as DTO schemas and security schemes."}},"/tech-specs/openapi/json":{"title":"Json","data":{"concepts#Concepts":"\"Wrtn Studio Pro\" has adopted OpenAPI v3.1 specified JSON schema definitions with some emendations.\"Wrtn Studio Pro\" is utilizng OpenAPI v3.1 specification and its following schema defining rule of \"JSON schema draft 2020-12\", for every schema definitions like API marketplace sales and Workflow Engine. If customer uploads a different version of OpenAPI specified JSON schema in the API marketplace, \"Wrtn Studio Pro\" will convert it to the JSON schema draft 2020-12 version.By the way, as JSON schema draft 2020-12 version has many synonym definitions of same meaning, \"Wrtn Studio Pro\" has emended the JSON schema draft 2020-12 version a little bit for clarity and consistency. Below is the list of JSON schema definitions in each OpenAPI version including the emended by \"Wrtn Studio Pro\".For reference, if user takes an original OpenAPI v3.1 specified document witout emendation or previous version than OpenAPI v3.1, \"Wrtn Studio Pro\" automatically converts it to the emended OpenAPI v3.1 version.\nOpenAPI v3.1 emended\nOpenAPI v3.1\nOpenAPI v3.0\nSwagger v2.0\nexport namespace OpenApi {\n  export type IJsonSchema =\n    | IJsonSchema.IConstant\n    | IJsonSchema.IBoolean\n    | IJsonSchema.IInteger\n    | IJsonSchema.INumber\n    | IJsonSchema.IString\n    | IJsonSchema.IArray\n    | IJsonSchema.ITuple\n    | IJsonSchema.IObject\n    | IJsonSchema.IReference\n    | IJsonSchema.IOneOf\n    | IJsonSchema.INull\n    | IJsonSchema.IUnknown;\n  export namespace IJsonSchema {\n    export interface IConstant extends __IAttribute {\n      const: boolean | number | string;\n    }\n    export interface IBoolean extends __ISignificant<\"boolean\"> {\n      default?: boolean;\n    }\n    export interface IInteger extends __ISignificant<\"integer\"> {\n      /** @type int64 */ default?: number;\n      /** @type int64 */ minimum?: number;\n      /** @type int64 */ maximum?: number;\n      exclusiveMinimum?: boolean;\n      exclusiveMaximum?: boolean;\n      /**\n       * @type uint64\n       * @exclusiveMinimum 0\n       */\n      multipleOf?: number;\n    }\n    export interface INumber extends __ISignificant<\"number\"> {\n      default?: number;\n      minimum?: number;\n      maximum?: number;\n      exclusiveMinimum?: boolean;\n      exclusiveMaximum?: boolean;\n      /** @exclusiveMinimum 0 */ multipleOf?: number;\n    }\n    export interface IString extends __ISignificant<\"string\"> {\n      default?: string;\n      format?:\n        | \"binary\"\n        | \"byte\"\n        | \"password\"\n        | \"regex\"\n        | \"uuid\"\n        | \"email\"\n        | \"hostname\"\n        | \"idn-email\"\n        | \"idn-hostname\"\n        | \"iri\"\n        | \"iri-reference\"\n        | \"ipv4\"\n        | \"ipv6\"\n        | \"uri\"\n        | \"uri-reference\"\n        | \"uri-template\"\n        | \"url\"\n        | \"date-time\"\n        | \"date\"\n        | \"time\"\n        | \"duration\"\n        | \"json-pointer\"\n        | \"relative-json-pointer\"\n        | (string & {});\n      pattern?: string;\n      contentMediaType?: string;\n      /** @type uint64 */ minLength?: number;\n      /** @type uint64 */ maxLength?: number;\n    }\n    export interface IArray<Schema extends IJsonSchema = IJsonSchema>\n      extends __ISignificant<\"array\"> {\n      items: Schema;\n      uniqueItems?: boolean;\n      /** @type uint64 */ minItems?: number;\n      /** @type uint64 */ maxItems?: number;\n    }\n    export interface ITuple<Schema extends IJsonSchema = IJsonSchema>\n      extends __ISignificant<\"array\"> {\n      prefixItems: Schema[];\n      additionalItems?: boolean | Schema;\n      uniqueItems?: boolean;\n      /** @type uint64 */ minItems?: number;\n      /** @type uint64 */ maxItems?: number;\n    }\n    export interface IObject<Schema extends IJsonSchema = IJsonSchema>\n      extends __ISignificant<\"object\"> {\n      properties?: Record<string, Schema>;\n      additionalProperties?: boolean | Schema;\n      required?: string[];\n    }\n    export interface IReference<Key = string> extends __IAttribute {\n      $ref: Key;\n    }\n    export interface IOneOf<Schema extends IJsonSchema = IJsonSchema>\n      extends __IAttribute {\n      oneOf: Exclude<Schema, IJsonSchema.IOneOf>[];\n      discriminator?: IOneOf.IDiscriminator;\n    }\n    export namespace IOneOf {\n      export interface IDiscriminator {\n        propertyName: string;\n        mapping?: Record<string, string>;\n      }\n    }\n    export interface INull extends __ISignificant<\"null\"> {\n      default?: null;\n    }\n    export interface IUnknown extends __IAttribute {\n      type?: undefined;\n    }\n    export interface __ISignificant<Type extends string> extends __IAttribute {\n      type: Type;\n    }\n    export interface __IAttribute {\n      title?: string;\n      description?: string;\n      deprecated?: boolean;\n    }\n  }\n}\nexport namespace OpenApiV3_1 {\n  export type IJsonSchema =\n    | IJsonSchema.IMixed\n    | IJsonSchema.IConstant\n    | IJsonSchema.IBoolean\n    | IJsonSchema.IInteger\n    | IJsonSchema.INumber\n    | IJsonSchema.IString\n    | IJsonSchema.IArray\n    | IJsonSchema.IObject\n    | IJsonSchema.IReference\n    | IJsonSchema.IRecursiveReference\n    | IJsonSchema.IUnknown\n    | IJsonSchema.INull\n    | IJsonSchema.IAllOf\n    | IJsonSchema.IAnyOf\n    | IJsonSchema.IOneOf;\n  export namespace IJsonSchema {\n    export interface IMixed\n      extends IConstant,\n        Omit<IBoolean, \"type\" | \"default\" | \"enum\">,\n        Omit<INumber, \"type\" | \"default\" | \"enum\">,\n        Omit<IString, \"type\" | \"default\" | \"enum\">,\n        Omit<IArray, \"type\">,\n        Omit<IObject, \"type\">,\n        IOneOf,\n        IAnyOf,\n        IAllOf {\n      type: Array<\n        \"boolean\" | \"integer\" | \"number\" | \"string\" | \"array\" | \"object\"\n      >;\n      default?: any[];\n      enum?: any[];\n    }\n    export interface IConstant extends __IAttribute {\n      const: boolean | number | string;\n    }\n    export interface IBoolean extends __ISignificant<\"boolean\"> {\n      default?: boolean | null;\n      enum?: Array<boolean | null>;\n    }\n    export interface IInteger extends __ISignificant<\"integer\"> {\n      /** @type int64 */ default?: number | null;\n      /** @type int64 */ enum?: Array<number | null>;\n      /** @type int64 */ minimum?: number;\n      /** @type int64 */ maximum?: number;\n      /** @type int64 */ exclusiveMinimum?: number | boolean;\n      /** @type int64 */ exclusiveMaximum?: number | boolean;\n      /**\n       * @type uint64\n       * @exclusiveMinimum 0\n       */\n      multipleOf?: number;\n    }\n    export interface INumber extends __ISignificant<\"number\"> {\n      default?: number | null;\n      enum?: Array<number | null>;\n      minimum?: number;\n      maximum?: number;\n      exclusiveMinimum?: number | boolean;\n      exclusiveMaximum?: number | boolean;\n      /** @exclusiveMinimum 0 */ multipleOf?: number;\n    }\n    export interface IString extends __ISignificant<\"string\"> {\n      contentMediaType?: string;\n      default?: string | null;\n      enum?: Array<string | null>;\n      format?:\n        | \"binary\"\n        | \"byte\"\n        | \"password\"\n        | \"regex\"\n        | \"uuid\"\n        | \"email\"\n        | \"hostname\"\n        | \"idn-email\"\n        | \"idn-hostname\"\n        | \"iri\"\n        | \"iri-reference\"\n        | \"ipv4\"\n        | \"ipv6\"\n        | \"uri\"\n        | \"uri-reference\"\n        | \"uri-template\"\n        | \"url\"\n        | \"date-time\"\n        | \"date\"\n        | \"time\"\n        | \"duration\"\n        | \"json-pointer\"\n        | \"relative-json-pointer\"\n        | (string & {});\n      pattern?: string;\n      /** @type uint64 */ minLength?: number;\n      /** @type uint64 */ maxLength?: number;\n    }\n    export interface IUnknown extends __IAttribute {\n      type?: undefined;\n    }\n    export interface INull extends __ISignificant<\"null\"> {\n      default?: null;\n    }\n    export interface IAllOf extends __IAttribute {\n      allOf: IJsonSchema[];\n    }\n    export interface IAnyOf extends __IAttribute {\n      anyOf: IJsonSchema[];\n    }\n    export interface IOneOf extends __IAttribute {\n      oneOf: IJsonSchema[];\n      discriminator?: IOneOf.IDiscriminator;\n    }\n    export namespace IOneOf {\n      export interface IDiscriminator {\n        propertyName: string;\n        mapping?: Record<string, string>;\n      }\n    }\n    export interface IArray extends __ISignificant<\"array\"> {\n      items: IJsonSchema | IJsonSchema[];\n      prefixItems?: IJsonSchema[];\n      uniqueItems?: boolean;\n      additionalItems?: boolean | IJsonSchema;\n      /** @type uint64 */ minItems?: number;\n      /** @type uint64 */ maxItems?: number;\n    }\n    export interface IObject extends __ISignificant<\"object\"> {\n      properties?: Record<string, IJsonSchema>;\n      required?: string[];\n      additionalProperties?: boolean | IJsonSchema;\n      maxProperties?: number;\n      minProperties?: number;\n    }\n    export interface IReference<Key = string> extends __IAttribute {\n      $ref: Key;\n    }\n    export interface IRecursiveReference extends __IAttribute {\n      $recursiveRef: string;\n    }\n    export interface __ISignificant<Type extends string> extends __IAttribute {\n      type: Type;\n      nullable?: boolean;\n    }\n    export interface __IAttribute {\n      title?: string;\n      description?: string;\n      deprecated?: boolean;\n    }\n  }\n}\nexport namespace OpenApiV3 {\n  export type IJsonSchema =\n    | IJsonSchema.IBoolean\n    | IJsonSchema.IInteger\n    | IJsonSchema.INumber\n    | IJsonSchema.IString\n    | IJsonSchema.IArray\n    | IJsonSchema.IObject\n    | IJsonSchema.IReference\n    | IJsonSchema.IUnknown\n    | IJsonSchema.INullOnly\n    | IJsonSchema.IAllOf\n    | IJsonSchema.IAnyOf\n    | IJsonSchema.IOneOf;\n  export namespace IJsonSchema {\n    export interface IBoolean extends __ISignificant<\"boolean\"> {\n      default?: boolean | null;\n      enum?: Array<boolean | null>;\n    }\n    export interface IInteger extends __ISignificant<\"integer\"> {\n      /** @type int64 */ default?: number | null;\n      /** @type int64 */ enum?: Array<number | null>;\n      /** @type int64 */ minimum?: number;\n      /** @type int64 */ maximum?: number;\n      exclusiveMinimum?: boolean;\n      exclusiveMaximum?: boolean;\n      /**\n       * @type uint64\n       * @exclusiveMinimum 0\n       */\n      multipleOf?: number;\n    }\n    export interface INumber extends __ISignificant<\"number\"> {\n      default?: number | null;\n      enum?: Array<number | null>;\n      minimum?: number;\n      maximum?: number;\n      exclusiveMinimum?: boolean;\n      exclusiveMaximum?: boolean;\n      /** @exclusiveMinimum 0 */ multipleOf?: number;\n    }\n    export interface IString extends __ISignificant<\"string\"> {\n      default?: string | null;\n      enum?: string[];\n      format?:\n        | \"binary\"\n        | \"byte\"\n        | \"password\"\n        | \"regex\"\n        | \"uuid\"\n        | \"email\"\n        | \"hostname\"\n        | \"idn-email\"\n        | \"idn-hostname\"\n        | \"iri\"\n        | \"iri-reference\"\n        | \"ipv4\"\n        | \"ipv6\"\n        | \"uri\"\n        | \"uri-reference\"\n        | \"uri-template\"\n        | \"url\"\n        | \"date-time\"\n        | \"date\"\n        | \"time\"\n        | \"duration\"\n        | \"json-pointer\"\n        | \"relative-json-pointer\"\n        | (string & {});\n      pattern?: string;\n      /** @type uint64 */ minLength?: number;\n      /** @type uint64 */ maxLength?: number;\n    }\n    export interface IArray extends __ISignificant<\"array\"> {\n      items: IJsonSchema;\n      uniqueItems?: boolean;\n      /** @type uint64 */ minItems?: number;\n      /** @type uint64 */ maxItems?: number;\n    }\n    export interface IObject extends __ISignificant<\"object\"> {\n      properties?: Record<string, IJsonSchema>;\n      required?: string[];\n      additionalProperties?: boolean | IJsonSchema;\n      maxProperties?: number;\n      minProperties?: number;\n    }\n    export interface IReference<Key = string> extends __IAttribute {\n      $ref: Key;\n    }\n    export interface IUnknown extends __IAttribute {\n      type?: undefined;\n    }\n    export interface INullOnly extends __IAttribute {\n      type: \"null\";\n    }\n    export interface IAllOf extends __IAttribute {\n      allOf: IJsonSchema[];\n    }\n    export interface IAnyOf extends __IAttribute {\n      anyOf: IJsonSchema[];\n    }\n    export interface IOneOf extends __IAttribute {\n      oneOf: IJsonSchema[];\n      discriminator?: IOneOf.IDiscriminator;\n    }\n    export namespace IOneOf {\n      export interface IDiscriminator {\n        propertyName: string;\n        mapping?: Record<string, string>;\n      }\n    }\n    export interface __ISignificant<Type extends string> extends __IAttribute {\n      type: Type;\n      nullable?: boolean;\n    }\n    export interface __IAttribute {\n      title?: string;\n      description?: string;\n      deprecated?: boolean;\n    }\n  }\n}\nexport namespace SwaggerV2 {\n  export type IJsonSchema =\n    | IJsonSchema.IBoolean\n    | IJsonSchema.IInteger\n    | IJsonSchema.INumber\n    | IJsonSchema.IString\n    | IJsonSchema.IArray\n    | IJsonSchema.IObject\n    | IJsonSchema.IReference\n    | IJsonSchema.IUnknown\n    | IJsonSchema.INullOnly\n    | IJsonSchema.IAllOf\n    | IJsonSchema.IAnyOf\n    | IJsonSchema.IOneOf;\n  export namespace IJsonSchema {\n    export interface IBoolean extends __ISignificant<\"boolean\"> {\n      default?: boolean | null;\n      enum?: Array<boolean | null>;\n    }\n    export interface IInteger extends __ISignificant<\"integer\"> {\n      /** @type int64 */ default?: number | null;\n      /** @type int64 */ enum?: Array<number | null>;\n      /** @type int64 */ minimum?: number;\n      /** @type int64 */ maximum?: number;\n      exclusiveMinimum?: boolean;\n      exclusiveMaximum?: boolean;\n      /**\n       * @type uint64\n       * @exclusiveMinimum 0\n       */\n      multipleOf?: number;\n    }\n    export interface INumber extends __ISignificant<\"number\"> {\n      default?: number | null;\n      enum?: Array<number | null>;\n      minimum?: number;\n      maximum?: number;\n      exclusiveMinimum?: boolean;\n      exclusiveMaximum?: boolean;\n      /** @exclusiveMinimum 0 */ multipleOf?: number;\n    }\n    export interface IString extends __ISignificant<\"string\"> {\n      default?: string | null;\n      enum?: Array<string | null>;\n      format?:\n        | \"binary\"\n        | \"byte\"\n        | \"password\"\n        | \"regex\"\n        | \"uuid\"\n        | \"email\"\n        | \"hostname\"\n        | \"idn-email\"\n        | \"idn-hostname\"\n        | \"iri\"\n        | \"iri-reference\"\n        | \"ipv4\"\n        | \"ipv6\"\n        | \"uri\"\n        | \"uri-reference\"\n        | \"uri-template\"\n        | \"url\"\n        | \"date-time\"\n        | \"date\"\n        | \"time\"\n        | \"duration\"\n        | \"json-pointer\"\n        | \"relative-json-pointer\"\n        | (string & {});\n      pattern?: string;\n      /** @type uint64 */ minLength?: number;\n      /** @type uint64 */ maxLength?: number;\n    }\n    export interface IArray extends __ISignificant<\"array\"> {\n      items: IJsonSchema;\n      uniqueItems?: boolean;\n      /** @type uint64 */ minItems?: number;\n      /** @type uint64 */ maxItems?: number;\n    }\n    export interface IObject extends __ISignificant<\"object\"> {\n      properties?: Record<string, IJsonSchema>;\n      required?: string[];\n      additionalProperties?: boolean | IJsonSchema;\n      maxProperties?: number;\n      minProperties?: number;\n    }\n    export interface IReference<Key = string> extends __IAttribute {\n      $ref: Key;\n    }\n    export interface IUnknown extends __IAttribute {\n      type?: undefined;\n    }\n    export interface INullOnly extends __IAttribute {\n      type: \"null\";\n    }\n    export interface IAllOf extends __IAttribute {\n      allOf: IJsonSchema[];\n    }\n    export interface IAnyOf extends __IAttribute {\n      \"x-anyOf\": IJsonSchema[];\n    }\n    export interface IOneOf extends __IAttribute {\n      \"x-oneOf\": IJsonSchema[];\n    }\n    export interface __ISignificant<Type extends string> extends __IAttribute {\n      type: Type;\n      \"x-nullable\"?: boolean;\n    }\n    export interface __IAttribute {\n      title?: string;\n      description?: string;\n      deprecated?: boolean;\n    }\n  }\n}","definitions#Definitions":"","common-properties#Common Properties":"export namespace OpenApi {\n  export namespace IJsonSchema {\n    /**\n     * Common attributes that can be applied to all types.\n     */\n    export interface __IAttribute {\n      /**\n       * Representative title of the schema.\n       */\n      title?: string;\n      /**\n       * Detailed description of the schema.\n       * \n       * Very important for LLM (Large Language Model) function calling.\n       */\n      description?: string;\n      /**\n       * Whether the type is deprecated or not.\n       */\n      deprecated?: boolean;\n    }\n  }\n}\nEvery JSON schema definitions have the following common properties.The first title is the representative name of the schema, and the meaning \"representative\" is powerful even some OpenAPI (swagger) document viewers are replacing the parameter/property/variable name to the title assigned value.The other description is the detailed explanation of the schema. In the OpenAPI (swagger) document viewer level, the title is a little bit important than description, but in the LLM (Large Language Model) function calling level, it is something different. As the description property is used for describing the schema in detail to LLM agent, the description proeprty is very important with its original type info.The last deprecated is used to mark the schema as deprecated. If the schema is marked as deprecated, the schema is not recommended to use anymore. The schema is still valid so that no problem would be right now, but the @deprecated means that the API provider will remove it soon, so that would not work in the future.","atomic-types#Atomic Types":"","constant#Constant":"export namespace OpenApi {\n  export namespace IJsonSchema {\n    /**\n     * Constant value type.\n     */\n    export interface IConstant {\n      /**\n       * The constant value.\n       */\n      const: boolean | number | string;\n      /**\n       * Representative title of the schema.\n       */\n      title?: string;\n      /**\n       * Detailed description of the schema.\n       * \n       * Very important for LLM (Large Language Model) function calling.\n       */\n      description?: string;\n      /**\n       * Whether the type is deprecated or not.\n       */\n      deprecated?: boolean;\n    }\n  }\n}\nimport typia from \"typia\";\nconst enum State {\n  NONE = 0,\n  CONNECTING = 1,\n  CLOSING = 2,\n  REJECTING = 3,\n  CONNECTED = 4,\n  CLOSED = 5,\n}\ntypia.json.application<[\n  \"one\" | \"two\" | \"three\",\n  State\n]>();\n  //{\n  //  version: \"3.1\",\n  //  components: {\n  //    schemas: {\n  //      State: {\n  //        oneOf: [\n  //          {\n  //            const: 0,\n  //            description: \"Did nothing yet\",\n  //          },\n  //          {\n  //            const: 1,\n  //            description: \"Connecting to the server\",\n  //          },\n  //          {\n  //            const: 2,\n  //            description: \"Closing the connection\",\n  //          },\n  //          {\n  //            const: 3,\n  //            description: \"Connection is alive\",\n  //          },\n  //          {\n  //            const: 4,\n  //            description: \"Connection has been closed\",\n  //          },\n  //        ],\n  //      },\n  //    },\n  //  },\n  //  schemas: [\n  //    {\n  //      oneOf: [\n  //        { const: \"one\" },\n  //        { const: \"two\" },\n  //        { const: \"three\" },\n  //      ],\n  //    },\n  //    { $ref: \"#/components/schemas/State\" },\n  //  ],\n  //}\n💻 Playground Link\nIn the JSON schema definition, the Constant type is used for representing a constant literal value.The constant literal value means that the value is always fixed and never changes. In the TypeScript, the constant literal value type is defined like below. As you can see, the constant literal values false, 1, and \"two\" are always fixed and never changed, so that assigned to the const property of the JSON schema.","boolean#Boolean":"export namespace OpenApi {\n  export namespace IJsonSchema {\n    /**\n     * Constant value type.\n     */\n    export interface IBoolean {\n      /**\n       * Discriminator value of the type.\n       */\n      type: \"boolean\";\n      /**\n       * The default value.\n       */\n      default?: boolean;\n      /**\n       * Representative title of the schema.\n       */\n      title?: string;\n      /**\n       * Detailed description of the schema.\n       * \n       * Very important for LLM (Large Language Model) function calling.\n       */\n      description?: string;\n      /**\n       * Whether the type is deprecated or not.\n       */\n      deprecated?: boolean;\n    }\n  }\n}\nimport typia, { tags } from \"typia\";\ntypia.json.application<[\n  boolean & tags.Default<false>\n]>();\n  // {\n  //   type: \"boolean\",\n  //   default: false,\n  // }\nIn the JSON schema definition, the boolean type is expressed as above.Different with the previous Constant type, the boolean type has a special property default, which is used for representing the default value for the schema. The default value is used when the schema value is not assigned by the user.","integer#Integer":"export namespace OpenApi {\n  export namespace IJsonSchema {\n    /**\n     * Integer type info.\n     */\n    export interface IInteger {\n      /**\n       * Discriminator value of the type.\n       */\n      type: \"integer\";\n      /**\n       * Minimum value restriction.\n       *\n       * @type int64\n       */\n      minimum?: number;\n      /**\n       * Maximum value restriction.\n       *\n       * @type int64\n       */\n      maximum?: number;\n      /**\n       * Exclusive minimum value restriction.\n       *\n       * For reference, even though your Swagger (or OpenAPI) document has\n       * defined the `exclusiveMinimum` value as `number`, {@link OpenApi}\n       * forcibly converts it to `boolean` type, and assign the numeric value to\n       * the {@link minimum} property.\n       * \n       * @default false\n       */\n      exclusiveMinimum?: boolean;\n      /**\n       * Exclusive maximum value restriction.\n       *\n       * For reference, even though your Swagger (or OpenAPI) document has\n       * defined the `exclusiveMaximum` value as `number`, {@link OpenApi}\n       * forcibly converts it to `boolean` type, and assign the numeric value to\n       * the {@link maximum} property.\n       * \n       * @default false\n       */\n      exclusiveMaximum?: boolean;\n      /**\n       * Multiple of value restriction.\n       *\n       * @type uint64\n       * @exclusiveMinimum 0\n       */\n      multipleOf?: number;\n      /**\n       * Default value.\n       *\n       * @type int64\n       */\n      default?: number;\n      /**\n       * Representative title of the schema.\n       */\n      title?: string;\n      /**\n       * Detailed description of the schema.\n       * \n       * Very important for LLM (Large Language Model) function calling.\n       */\n      description?: string;\n      /**\n       * Whether the type is deprecated or not.\n       */\n      deprecated?: boolean;\n    }\n  }\n}\nimport typia, { tags } from \"typia\";\nconsole.log(\n  typia.json.application<[\n    number & tags.Type<\"uint32\"> & tags.Minimum<100>,\n  ]>(),\n  typia.createIs<number & tags.Type<\"uint32\"> & tags.Minimum<100>>(),\n);\n// {\n//   type: \"integer\",\n//   minimum: 100,\n// }\n//-----------------------\n// (input) => {\n//   return (\n//     \"number\" === typeof input &&\n//     Math.floor(input) === input &&\n//     -2147483648 <= input &&\n//     100 <= input\n//   );\n// }\n💻 Playground Link\nIn the JSON schema definition, the integer type is expressed as above.Unlike above boolean type is, the integer type has additional restriction properties.At first, multipleOf means the value must be multiple of the assigned value. Therefore, if you assign an integer value to the multipleOf restricted type, your integer value must be possible to divid by the multipleOf value without any remainder.The other, minimum and maximum are the range restriction properties, and exclusiveMinimum and exclusiveMaximum are helper properties describing whether the minimum and maximum restrictions are prohibiting equal value or not. As default value of exclusiveMinimum and exclusiveMaximum are false, if only minimum or maximum is assigned, the value is allowed to be equal to the minimum or maximum value.\nx >= 0 // { minimum: 0, exclusiveMinimum: false }\ny < 10 // { maximum: 10, exclusiveMaximum: true }","number#Number":"export namespace OpenApi {\n  export namespace IJsonSchema {\n    /**\n     * Number (double) type info.\n     */\n    export interface INumber {\n      /**\n       * Discriminator value of the type.\n       */\n      type: \"number\";\n      /**\n       * Minimum value restriction.\n       */\n      minimum?: number;\n      /**\n       * Maximum value restriction.\n       */\n      maximum?: number;\n      /**\n       * Exclusive minimum value restriction.\n       *\n       * For reference, even though your Swagger (or OpenAPI) document has\n       * defined the `exclusiveMinimum` value as `number`, {@link OpenAiComposer}\n       * forcibly converts it to `boolean` type, and assign the numeric value to\n       * the {@link minimum} property.\n       */\n      exclusiveMinimum?: boolean;\n      /**\n       * Exclusive maximum value restriction.\n       *\n       * For reference, even though your Swagger (or OpenAPI) document has\n       * defined the `exclusiveMaximum` value as `number`, {@link OpenAiComposer}\n       * forcibly converts it to `boolean` type, and assign the numeric value to\n       * the {@link maximum} property.\n       */\n      exclusiveMaximum?: boolean;\n      /**\n       * Multiple of value restriction.\n       *\n       * @exclusiveMinimum 0\n       */\n      multipleOf?: number;\n      /**\n       * Default value.\n       */\n      default?: number;\n      /**\n       * Representative title of the schema.\n       */\n      title?: string;\n      /**\n       * Detailed description of the schema.\n       * \n       * Very important for LLM (Large Language Model) function calling.\n       */\n      description?: string;\n      /**\n       * Whether the type is deprecated or not.\n       */\n      deprecated?: boolean;\n    }\n  }\n}\nimport typia, { tags } from \"typia\";\nconsole.log(\n  typia.json.application<[\n    number & tags.MultipleOf<5.5>,\n  ]>(),\n  typia.createIs<number & tags.MultipleOf<5.5>>(),\n);\n  // {\n  //   type: \"number\",\n  //   multipleOf: 5.5,\n  // }\n  //-----------------------\n  // (input) => {\n  //   return \"number\" === typeof input && input % 5.5 === 0;\n  // }\n💻 Playground Link\nIn the JSON schema definition, the number type is expressed as above.Only one thing different with number and integer type is, whether to allow the decimal point or not. The number type allows the decimal point, but the integer type does not allow the decimal point. Therefore, member properties of number type are exactly same with integer type.\nDescription in the integer type is also applied to the number type.\nAt first, multipleOf means the value must be multiple of the assigned value. Therefore, if you assign an integer value to the multipleOf restricted type, your integer value must be possible to divid by the multipleOf value without any remainder.The other, minimum and maximum are the range restriction properties, and exclusiveMinimum and exclusiveMaximum are helper properties describing whether the minimum and maximum restrictions are prohibiting equal value or not. As default value of exclusiveMinimum and exclusiveMaximum are false, if only minimum or maximum is assigned, the value is allowed to be equal to the minimum or maximum value.\nx >= 0 // { minimum: 0, exclusiveMinimum: false }\ny < 10 // { maximum: 10, exclusiveMaximum: true }","string#String":"export namespace OpenApi {\n  export namespace IJsonSchema {\n    /**\n     * String type info.\n     */\n    export interface IString {\n      /**\n       * Discriminator value of the type.\n       */\n      type: \"string\";\n      /**\n       * Format restriction.\n       */\n      format?:\n        | \"binary\"\n        | \"byte\"\n        | \"password\"\n        | \"regex\"\n        | \"uuid\"\n        | \"email\"\n        | \"hostname\"\n        | \"idn-email\"\n        | \"idn-hostname\"\n        | \"iri\"\n        | \"iri-reference\"\n        | \"ipv4\"\n        | \"ipv6\"\n        | \"uri\"\n        | \"uri-reference\"\n        | \"uri-template\"\n        | \"url\"\n        | \"date-time\"\n        | \"date\"\n        | \"time\"\n        | \"duration\"\n        | \"json-pointer\"\n        | \"relative-json-pointer\"\n        | (string & {});\n      /**\n       * Pattern restriction.\n       */\n      pattern?: string;\n      /**\n       * Content media type restriction.\n       */\n      contentMediaType?: string;\n      /**\n       * Minimum length restriction.\n       *\n       * @type uint64\n       */\n      minLength?: number;\n      /**\n       * Maximum length restriction.\n       *\n       * @type uint64\n       */\n      maxLength?: number;\n      /**\n       * Default value.\n       */\n      default?: string;\n      /**\n       * Representative title of the schema.\n       */\n      title?: string;\n      /**\n       * Detailed description of the schema.\n       * \n       * Very important for LLM (Large Language Model) function calling.\n       */\n      description?: string;\n      /**\n       * Whether the type is deprecated or not.\n       */\n      deprecated?: boolean;\n    }\n  }\n}\nimport typia, { tags } from \"typia\";\nconsole.log(\n  typia.json.application<[\n    string & tags.Format<\"uuid\"> & tags.MinLength<5> & tags.MaxLength<255>,\n  ]>(),\n  typia.createIs<\n    string & tags.Format<\"uuid\"> & tags.MinLength<5> & tags.MaxLength<255>\n  >(),\n);\n  // {\n  //   type: \"string\",\n  //   format: \"uuid\",\n  //   minLength: 5,\n  //   maxLength: 255,\n  // }\n  //-----------------------\n  // (input) => {\n  //   return (\n  //     \"string\" === typeof input &&\n  //     /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\n  //       input,\n  //     ) &&\n  //     5 <= input.length &&\n  //     input.length <= 255\n  //   );\n  // }\n💻 Playground Link\nIn the JSON schema definition, the string type is expressed as above.As integer and number type have minimum and miximum properties, the string type has minLength and maxLength properties to restrict the length of the string. Also, the string type has special properties that other types do not have, such as format, pattern, and contentMediaType.The pattern is used for restricting the string value by the regular exression. If the string value does not match the regular expression, the value is not valid.The format is used for restricting the string value by the format. The format property is not a regular expression, but a predefined format string. If you want to see the predefined format strings, please refer to below links.\nJSON schema string format\nRegular expressions for format\nThe last contentMediaType is designed for restricting the media type of the string content. It can be used only when the format property is one of them. For reference, the contentMediaType does not affect to the string value validation, but just used for the documentation reason.\nbinary\nbyte\nuri\nurl","nested-types#Nested Types":"","array#Array":"export namespace OpenApi {\n  export namespace IJsonSchema {\n    /**\n     * Array type info.\n     */\n    export interface IArray {\n      /**\n       * Discriminator value of the type.\n       */\n      type: \"array\";\n      /**\n       * Items type info.\n       *\n       * The `items` means the type of the array elements. In other words, it is\n       * the type schema info of the `T` in the TypeScript array type `Array<T>`.\n       */\n      items: IJsonSchema;\n      /**\n       * Unique items restriction.\n       *\n       * If this property value is `true`, target array must have unique items.\n       */\n      uniqueItems?: boolean;\n      /**\n       * Minimum items restriction.\n       *\n       * Restriction of minumum number of items in the array.\n       *\n       * @type uint64\n       */\n      minItems?: number;\n      /**\n       * Maximum items restriction.\n       *\n       * Restriction of maximum number of items in the array.\n       *\n       * @type uint64\n       */\n      maxItems?: number;\n      /**\n       * Representative title of the schema.\n       */\n      title?: string;\n      /**\n       * Detailed description of the schema.\n       * \n       * Very important for LLM (Large Language Model) function calling.\n       */\n      description?: string;\n      /**\n       * Whether the type is deprecated or not.\n       */\n      deprecated?: boolean;\n    }\n  }\n}\nimport typia, { tags } from \"typia\";\nconsole.log(\n  typia.json.application<[\n    Array<string & tags.Format<\"uuid\">> \n      & tags.MinItems<1> \n      & tags.UniqueItems\n  ]>(),\n  typia.createIs<\n    Array<string & tags.Format<\"uuid\">> \n      & tags.MinItems<1>\n      & tags.UniqueItems\n  >(),\n);\n  // {\n  //   type: \"array\",\n  //   items: {\n  //     type: \"string\",\n  //     format: \"uuid\",\n  //   },\n  //   minItems: 1,\n  //   uniqueItems: true,\n  // }\n  //-----------------------\n  // (() => {\n  //   return (input) =>\n  //     Array.isArray(input) &&\n  //     1 <= input.length &&\n  //     (input.length <= 1 || input.length === new Set(input).size) &&\n  //     input.every(\n  //       (elem) =>\n  //         \"string\" === typeof elem &&\n  //         /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\n  //           elem,\n  //         ),\n  //     );\n  // })()\nIn the JSON schema definition, the array type is expressed as above.At first, items property is used for describing the type of the array elements. In the TypeScript, it is the type schema info of the T element type in the TypeScript array type Array<T>.The uniqueItems property is used for describing whether the array elements are unique or not. If the uniqueItems property is true, the array elements must be unique. Otherwise false or undefined, the array elements are not restricted to be unique.Also, minItems and maxItems properties are used for restricting the number of the array elements. The minItems property is used for describing the minimum number of the array elements, and the maxItems property is used for describing the maximum number of the array elements.","tuple#Tuple":"export namespace OpenApi {\n  export namespace IJsonSchema {\n    /**\n     * Tuple type info.\n     */\n    export interface ITuple {\n      /**\n       * Discriminator value of the type.\n       */\n      type: \"array\";\n      /**\n       * Prefix items.\n       *\n       * The `prefixItems` means the type schema info of the prefix items in the\n       * tuple type. In the TypeScript, it is expressed as `[T1, T2]`.\n       *\n       * If you want to express `[T1, T2, ...TO[]]` type, you can configure the\n       * `...TO[]` through the {@link additionalItems} property.\n       */\n      prefixItems: IJsonSchema[];\n      /**\n       * Additional items.\n       *\n       * The `additionalItems` means the type schema info of the additional items\n       * after the {@link prefixItems}. In the TypeScript, if there's a type\n       * `[T1, T2, ...TO[]]`, the `...TO[]` is represented by the `additionalItems`.\n       *\n       * By the way, if you configure the `additionalItems` as `true`, it means\n       * the additional items are not restricted. They can be any type, so that\n       * it is equivalent to the TypeScript type `[T1, T2, ...any[]]`.\n       *\n       * Otherwise configure the `additionalItems` as the {@link IJsonSchema},\n       * it means the additional items must follow the type schema info.\n       * Therefore, it is equivalent to the TypeScript type `[T1, T2, ...TO[]]`.\n       */\n      additionalItems?: boolean | IJsonSchema;\n      /**\n       * Unique items restriction.\n       *\n       * If this property value is `true`, target tuple must have unique items.\n       */\n      uniqueItems?: boolean;\n      /**\n       * Minimum items restriction.\n       *\n       * Restriction of minumum number of items in the tuple.\n       *\n       * @type uint64\n       */\n      minItems?: number;\n      /**\n       * Maximum items restriction.\n       *\n       * Restriction of maximum number of items in the tuple.\n       *\n       * @type uint64\n       */\n      maxItems?: number;\n      /**\n       * Representative title of the schema.\n       */\n      title?: string;\n      /**\n       * Detailed description of the schema.\n       * \n       * Very important for LLM (Large Language Model) function calling.\n       */\n      description?: string;\n      /**\n       * Whether the type is deprecated or not.\n       */\n      deprecated?: boolean;\n    }\n  }\n}\nimport typia from \"typia\";\nconsole.log(\n  typia.json.application<[\n    [3, 4, string],\n    [number, string, boolean],\n    [boolean, number, ...string[]]\n  ]>(),\n);\n  // [\n  //   {\n  //     type: \"array\",\n  //     prefixItems: [\n  //       { const: 3 },\n  //       { const: 4 },\n  //       { type: \"string\" },\n  //     ],\n  //     additionalItems: false,\n  //   },\n  //   {\n  //     type: \"array\",\n  //     prefixItems: [\n  //       { type: \"number\" },\n  //       { type: \"string\" },\n  //       { type: \"boolean\" },\n  //     ],\n  //     additionalItems: false,\n  //   },\n  //   {\n  //     type: \"array\",\n  //     prefixItems: [\n  //       { type: \"boolean\" },\n  //       { type: \"number\" },\n  //     ],\n  //     additionalItems: {\n  //       type: \"string\",\n  //     },\n  //   },\n  // ]\nIn the JSON schema definition, the tuple type is expressed as above.The tuple type is a special type of the array type. The array type is used for representing the array of the same type elements, but the tuple type is used for representing the array of the different type elements.In the TypeScript, the tuple type is expressed as [T1, T2, ...TO[]], and such list of prefixed items are archived on the prefixItems property. If you make the prefixItems to be zero length array, it is equivalent to the empty array type.By the way, if you want to express [T1, T2, ...TO[]] type, which means that only T1, T2 types are prefixed and the rest of the types are any type, you can configure the ...TO[] type through the additionalItems property.","object#Object":"export namespace OpenApi {\n  export namespace IJsonSchema {\n    /**\n     * Object type info.\n     */\n    export interface IObject {\n      /**\n       * Discriminator value of the type.\n       */\n      type: \"object\";\n      /**\n       * Properties of the object.\n       *\n       * The `properties` means a list of key-value pairs of the object's\n       * regular properties. The key is the name of the regular property,\n       * and the value is the type schema info.\n       *\n       * If you need additional properties that is represented by dynamic key,\n       * you can use the {@link additionalProperties} instead.\n       */\n      properties?: Record<string, IJsonSchema>;\n      /**\n       * Additional properties' info.\n       *\n       * The `additionalProperties` means the type schema info of the additional\n       * properties that are not listed in the {@link properties}.\n       *\n       * If the value is `true`, it means that the additional properties are not\n       * restricted. They can be any type. Otherwise, if the value is\n       * {@link IOpenAiSchema} type, it means that the additional properties must\n       * follow the type schema info.\n       *\n       * - `true`: `Record<string, any>`\n       * - `IOpenAiSchema`: `Record<string, T>`\n       */\n      additionalProperties?: boolean | IJsonSchema;\n      /**\n       * List of key values of the required properties.\n       *\n       * The `required` means a list of the key values of the required\n       * {@link properties}. If some property key is not listed in the `required`\n       * list, it means that property is optional. Otherwise some property key\n       * exists in the `required` list, it means that the property must be filled.\n       *\n       * Below is an example of the {@link properties} and `required`.\n       *\n       * ```typescript\n       * interface SomeObject {\n       *   id: string;\n       *   email: string;\n       *   name?: string;\n       * }\n       * ```\n       *\n       * As you can see, `id` and `email` {@link properties} are {@link required},\n       * so that they are listed in the `required` list.\n       *\n       * ```json\n       * {\n       *   \"type\": \"object\",\n       *   \"properties\": {\n       *     \"id\": { \"type\": \"string\" },\n       *     \"email\": { \"type\": \"string\" },\n       *     \"name\": { \"type\": \"string\" }\n       *   },\n       *   \"required\": [\"id\", \"email\"]\n       * }\n       * ```\n       */\n      required?: string[];\n      /**\n       * Representative title of the schema.\n       */\n      title?: string;\n      /**\n       * Detailed description of the schema.\n       * \n       * Very important for LLM (Large Language Model) function calling.\n       */\n      description?: string;\n      /**\n       * Whether the type is deprecated or not.\n       */\n      deprecated?: boolean;\n    }\n  }\n}\nimport typia, { tags } from \"typia\";\nconsole.log(\n  typia.json.application<[\n    {\n      id: string & tags.Format<\"uuid\">;\n      name?: string;\n      age?: number & tags.Type<\"uint32\">;\n      configurations: {\n        [key: string]: boolean;\n      };\n    }\n  ]>(),\n);\n  // {\n  //   type: \"object\",\n  //   properties: {\n  //     id: {\n  //       type: \"string\",\n  //       format: \"uuid\",\n  //     },\n  //     name?: {\n  //       type: \"string\",\n  //     },\n  //     age: {\n  //       type: \"integer\",\n  //       minimum: 0,\n  //     },\n  //     configurations: {\n  //       type: \"object\",\n  //       properties: {},\n  //       additionalProperties: {\n  //         type: \"boolean\",\n  //       },\n  //     },\n  //   },\n  //   required: [\"id\", \"configurations\"],\n  // }\nIn the JSON schema definition, the object type is expressed as above.The object type has properties and required properties. The properties property is used for describing the regular properties of the object, and the required property is used for describing the required properties of the object.For example, above example code in the second tab contains a TypeScript object type. In the type, there are four regular properties; id, name, age and configurations. In the above example TypeScript object definition, only id and configurations properties are required, and the others are optional. Therefore, the required property is configured as [\"id\", \"configurations\"].Also, the configurations property is a special property that is represented by the dynamic key-value pairs. The additionalProperties property is used for describing the type schema info of the additional properties that are not listed in the properties property; Record<string, T>.For reference, if you configure the additionalProperties property just as true, it means that type of the additional properties are not restricted, so that it is equivalent to the any type case; Record<string, any>. Otherwise the additionalProperties property configured as false, it means the object type does not allow any superfluous properties. In the undefined value case, it means that does not consider and validatea the superfluous properties.","reference#Reference":"export namespace OpenApi {\n  export namespace IJsonSchema {\n    /**\n     * Reference type directing named schema.\n     */\n    export interface IReference<Key = string> {\n      /**\n       * Reference to the named schema.\n       *\n       * The `ref` is a reference to the named schema. Format of the `$ref` is\n       * following the JSON Pointer specification. In the OpenAPI, the `$ref`\n       * starts with `#/components/schemas/` which means the type is stored in\n       * the {@link OpenApi.IComponents.schemas} object.\n       *\n       * - `#/components/schemas/SomeObject`\n       * - `#/components/schemas/AnotherObject`\n       */\n      $ref: Key;\n      /**\n       * Representative title of the schema.\n       */\n      title?: string;\n      /**\n       * Detailed description of the schema.\n       * \n       * Very important for LLM (Large Language Model) function calling.\n       */\n      description?: string;\n      /**\n       * Whether the type is deprecated or not.\n       */\n      deprecated?: boolean;\n    }\n  }\n}\nimport typia from \"typia\";\ninterface IMember {\n  id: string;\n  name: string;\n  age?: number;\n}\nconsole.log(\n  typia.json.application<[\n    IMember,\n    {\n      x: number;\n      y: number;\n      z?: number;\n    }\n  ]>(),\n);\n  // {\n  //   components: {\n  //     schemas: {\n  //       IMember: {\n  //         type: \"object\",\n  //         properties: {\n  //           id: { type: \"string\" },\n  //           name: { type: \"string\" },\n  //           age: { type: \"number\" },\n  //         },\n  //         required: [\"id\", \"name\"],\n  //       },\n  //     },\n  //   },\n  //   schemas: [\n  //     {\n  //       $ref: \"#/components/schemas/IMember\",\n  //     },\n  //     {\n  //       type: \"object\",\n  //       properties: {\n  //         x: { type: \"number\" },\n  //         y: { type: \"number\" },\n  //         z: { type: \"number\" },\n  //       },\n  //       required: [\"x\", \"y\"],\n  //     },\n  //   ],\n  // }\nIn the JSON schema definition, the reference type is expressed as above.The reference type is used for referencing the named schema, defined in the components instance. If you have a named schema, you can reference it by the $ref property with #/components/schemas prefix. In the above case, $ref of the IMember type is #/components/schemas/IMember.Also in the above example code of second tab, you can see that two types are listed in the JSON schema generator. The first is the IMember  type that is defined as a explicit named interface type, and the second is the literal object type. As the IMember type is defined as a named schema, it is referenced by the $ref property.The other one is not named type case, so that listed in the schemas directly.","oneof#OneOf":"export namespace OpenApi {\n  export namespace IJsonSchema {\n    /**\n     * Union type.\n     *\n     * IOneOf` represents an union type of the TypeScript (`A | B | C`).\n     *\n     * For reference, even though your Swagger (or OpenAPI) document has\n     * defined `anyOf` instead of the `oneOf`, {@link OpenApi} forcibly\n     * converts it to `oneOf` type.\n     */\n    export interface IOneOf {\n      /**\n       * List of the union types.\n       */\n      oneOf: Exclude<IJsonSchema, IJsonSchema.IOneOf>[];\n      /**\n       * Discriminator info of the union type.\n       */\n      discriminator?: IOneOf.IDiscriminator;\n      /**\n       * Representative title of the schema.\n       */\n      title?: string;\n      /**\n       * Detailed description of the schema.\n       * \n       * Very important for LLM (Large Language Model) function calling.\n       */\n      description?: string;\n      /**\n       * Whether the type is deprecated or not.\n       */\n      deprecated?: boolean;\n    }\n    export namespace IOneOf {\n      /**\n       * Discriminator info of the union type.\n       */\n      export interface IDiscriminator {\n        /**\n         * Property name for the discriminator.\n         */\n        propertyName: string;\n        /**\n         * Mapping of the discriminator value to the schema name.\n         *\n         * This property is valid only for {@link IReference} typed\n         * {@link IOneOf.oneof} elements. Therefore, `key` of `mapping` is\n         * the discriminator value, and `value` of `mapping` is the\n         * schema name like `#/components/schemas/SomeObject`.\n         */\n        mapping?: Record<string, string>;\n      }\n    }\n  }\n}\nimport typia from \"typia\";\ninterface ICircle {\n  type: \"circle\";\n  radius: number;\n}\ninterface ITriangle {\n  type: \"triangle\";\n  base: number;\n  height: number;\n}\ninterface IRectangle {\n  type: \"rectangle\";\n  width: number;\n  height: number;\n}\nconsole.log(\n  typia.json.application<[\n    | ICircle \n    | ITriangle \n    | IRectangle\n  ]>(),\n);\n  // {\n  //   version: \"3.1\",\n  //   components: {\n  //     schemas: {\n  //       ICircle: {\n  //         type: \"object\",\n  //         properties: {\n  //           type: { const: \"circle\" },\n  //           radius: { type: \"number\" },\n  //         },\n  //         required: [\"type\", \"radius\"],\n  //       },\n  //       ITriangle: {\n  //         type: \"object\",\n  //         properties: {\n  //           type: { const: \"triangle\" },\n  //           base: { type: \"number\" },\n  //           height: { type: \"number\" },\n  //         },\n  //         required: [\"type\", \"base\", \"height\"],\n  //       },\n  //       IRectangle: {\n  //         type: \"object\",\n  //         properties: {\n  //           type: { const: \"rectangle\" },\n  //           width: { type: \"number\" },\n  //           height: { type: \"number\" },\n  //         },\n  //         required: [\"type\", \"width\", \"height\"],\n  //       },\n  //     },\n  //   },\n  //   schemas: [\n  //     {\n  //       oneOf: [\n  //         { $ref: \"#/components/schemas/ICircle\" },\n  //         { $ref: \"#/components/schemas/ITriangle\" },\n  //         { $ref: \"#/components/schemas/IRectangle\" },\n  //       ],\n  //       discriminator: {\n  //         propertyName: \"type\",\n  //         mapping: {\n  //           circle: \"#/components/schemas/ICircle\",\n  //           triangle: \"#/components/schemas/ITriangle\",\n  //           rectangle: \"#/components/schemas/IRectangle\",\n  //         },\n  //       },\n  //     },\n  //   ],\n  // }\nIn the JSON schema definition, the oneOf type is expressed as above.The oneOf type is used for representing the union type of the TypeScript (A | B | C).Individual types composing the union type are listed in the oneOf property. Also, the discriminator property is constructed only when discriminator property exists in the union type, and every individual types are named reference type like above case.\nICircle.type: \"circle\"\nITriangle.type: \"triangle\"\nIRectangle.type: \"rectangle\"","special-types#Special Types":"","null#Null":"export namespace OpenApi {\n  export namespace IJsonSchema {\n    /**\n     * Null type.\n     */\n    export interface INull {\n      /**\n       * Discriminator value of the type.\n       */\n      type: \"null\";\n      /**\n       * Default value.\n       */\n      default?: null;\n      /**\n       * Representative title of the schema.\n       */\n      title?: string;\n      /**\n       * Detailed description of the schema.\n       * \n       * Very important for LLM (Large Language Model) function calling.\n       */\n      description?: string;\n      /**\n       * Whether the type is deprecated or not.\n       */\n      deprecated?: boolean;\n    }\n  }\n}\nimport typia from \"typia\";\nconsole.log(\n  typia.json.application<[\n    null,\n    string | null,\n    number | null,\n  ]>(),\n);\n  // [\n  //   { type: \"null\" },\n  //   {\n  //     oneOf: [\n  //       { type: \"null\" },\n  //       { type: \"string\" },\n  //     ],\n  //   },\n  //   {\n  //     oneOf: [\n  //       { type: \"null\" },\n  //       { type: \"number\" },\n  //     ],\n  //   },\n  // ]\nIn the JSON schema definition, the null type is expressed as above.It is exactly same with null type in the TypeScript.If you want to declare a nullable type of the other type, you have to use the oneOf type with null type.","unknown#Unknown":"export namespace OpenApi {\n  export namespace IJsonSchema {\n    /**\n     * Unknown, `any` type.\n     */\n    export interface IUnknown extends __IAttribute {\n      /**\n       * Type is never be defined.\n       */\n      type?: undefined;\n      /**\n       * Representative title of the schema.\n       */\n      title?: string;\n      /**\n       * Detailed description of the schema.\n       * \n       * Very important for LLM (Large Language Model) function calling.\n       */\n      description?: string;\n      /**\n       * Whether the type is deprecated or not.\n       */\n      deprecated?: boolean;\n    }\n  }\n}\nimport typia from \"typia\";\nconsole.log(\n  typia.json.application<[\n    any,\n    unknown\n  ]>(),\n);\n  // [\n  //   {}, \n  //   {},\n  // ]\nIn the JSON schema definition, unknown type is expressed as above.In the TypeScript definition, it is equivalent any and unknown types.","components#Components":"export namespace OpenApi {\n  /**\n   * Reusable components in OpenAPI.\n   *\n   * A storage of reusable components in OpenAPI document.\n   *\n   * In other words, it is a storage of named DTO schemas and security schemes.\n   */\n  export interface IComponents<Schema extends IJsonSchema = IJsonSchema> {\n    /**\n     * An object to hold reusable DTO schemas.\n     *\n     * In other words, a collection of named JSON schemas.\n     */\n    schemas?: Record<string, Schema>;\n  }\n}\nimport typia from \"typia\";\ninterface ICircle {\n  type: \"circle\";\n  radius: number;\n}\ninterface ITriangle {\n  type: \"triangle\";\n  base: number;\n  height: number;\n}\ninterface IRectangle {\n  type: \"rectangle\";\n  width: number;\n  height: number;\n}\nconsole.log(\n  typia.json.application<[\n    | ICircle \n    | ITriangle \n    | IRectangle\n  ]>(),\n);\n  // {\n  //   version: \"3.1\",\n  //   components: {\n  //     schemas: {\n  //       ICircle: {\n  //         type: \"object\",\n  //         properties: {\n  //           type: { const: \"circle\" },\n  //           radius: { type: \"number\" },\n  //         },\n  //         required: [\"type\", \"radius\"],\n  //       },\n  //       ITriangle: {\n  //         type: \"object\",\n  //         properties: {\n  //           type: { const: \"triangle\" },\n  //           base: { type: \"number\" },\n  //           height: { type: \"number\" },\n  //         },\n  //         required: [\"type\", \"base\", \"height\"],\n  //       },\n  //       IRectangle: {\n  //         type: \"object\",\n  //         properties: {\n  //           type: { const: \"rectangle\" },\n  //           width: { type: \"number\" },\n  //           height: { type: \"number\" },\n  //         },\n  //         required: [\"type\", \"width\", \"height\"],\n  //       },\n  //     },\n  //   },\n  //   schemas: [\n  //     {\n  //       oneOf: [\n  //         { $ref: \"#/components/schemas/ICircle\" },\n  //         { $ref: \"#/components/schemas/ITriangle\" },\n  //         { $ref: \"#/components/schemas/IRectangle\" },\n  //       ],\n  //       discriminator: {\n  //         propertyName: \"type\",\n  //         mapping: {\n  //           circle: \"#/components/schemas/ICircle\",\n  //           triangle: \"#/components/schemas/ITriangle\",\n  //           rectangle: \"#/components/schemas/IRectangle\",\n  //         },\n  //       },\n  //     },\n  //   ],\n  // }\nCollection of named schemas.In the JSON schema definition, the components is a collection of named schemas. It is used for storing the reusable DTO schemas, and referenced by the reference type with $ref property and #/components/schemas/ prefixed addresses.Above second tab is the example code defining and utilizing the named schemas. As you can see, the named schemas are same with the TypeScript's named types. They're stored in the components.schemas object with the key-value pairs, and referenced by the $ref property with #/components/schemas/ prefixed addresses.","detailed-emendations#Detailed Emendations":"","decompositions#Decompositions":"","mixed#Mixed":"// OpenAPI v3.1\nconst original: OpenApiV3_1.IJsonSchema.IMixed = {\n  type: [\"number\", \"string\", \"object\"],\n  properties: {\n    id: { type: \"string\" },\n    validated: { type: \"boolean\" }, \n    required: [\"id\", \"validated\"],\n  },\n  minimum: 0,\n  exclusiveMinimum: true,\n  nullalble: true,\n};\n// Emended\nconst emended: OpenApi.IJsonSchema.IOneOf = {\n  oneOf: [\n    { type: \"null\" },\n    { \n      type: \"number\",\n      minimum: 0,\n      exclusiveMinimum: true,\n    },\n    { type: \"string\" },\n    {\n      type: \"object\",\n      properties: {\n        id: { type: \"string\" },\n        validated: { type: \"boolean\" }, \n        required: [\"id\", \"validated\"],\n      },\n    },\n  ],\n};\nexport namespace OpenApiV3_1 {\n  export type IJsonSchema =\n    | IJsonSchema.IMixed\n    | IJsonSchema.IConstant\n    | IJsonSchema.IBoolean\n    | IJsonSchema.IInteger\n    | IJsonSchema.INumber\n    | IJsonSchema.IString\n    | IJsonSchema.IArray\n    | IJsonSchema.IObject\n    | IJsonSchema.IReference\n    | IJsonSchema.IUnknown\n    | IJsonSchema.INull\n    | IJsonSchema.IAllOf\n    | IJsonSchema.IAnyOf\n    | IJsonSchema.IOneOf;\n  export namespace IJsonSchema {\n    export interface IMixed\n      extends IConstant,\n        Omit<IBoolean, \"type\" | \"default\" | \"enum\">,\n        Omit<INumber, \"type\" | \"default\" | \"enum\">,\n        Omit<IString, \"type\" | \"default\" | \"enum\">,\n        Omit<IArray, \"type\">,\n        Omit<IObject, \"type\">,\n        IReference,\n        IOneOf,\n        IAnyOf,\n        IAllOf {\n      type: Array<\n        \"boolean\" | \"integer\" | \"number\" | \"string\" | \"array\" | \"object\"\n      >;\n      default?: any[];\n      enum?: any[];\n    }\n  }\n}\nexport namespace OpenApi {\n  export type IJsonSchema =\n    | IJsonSchema.IConstant\n    | IJsonSchema.IBoolean\n    | IJsonSchema.IInteger\n    | IJsonSchema.INumber\n    | IJsonSchema.IString\n    | IJsonSchema.IArray\n    | IJsonSchema.ITuple\n    | IJsonSchema.IObject\n    | IJsonSchema.IReference\n    | IJsonSchema.IOneOf\n    | IJsonSchema.INull\n    | IJsonSchema.IUnknown;\n}\nIn the OpenAPI v3.1 specification, there is an mixed type in the JSON schema, which layed out every properties of individual JSON schema types. Such mixed type is unclear and dangerous to anyone who sees it, so \"Wrtn Studio Pro\" decomposes the mixed type to oneOf type for clarity.For reference, the reason why OpenAPI and JSON schema foundations have designed such all-rounder mixed type for OpenAPI document hand-writing users. It may be hard to believe that people would handwrite OpenAPI documentation, but this strategy actually exists. However, such strategy is actually exists and name of the strategy is \"CDD (Contract Driven Development)\".\nContract Driven Development\nHand write the OpenAPI document first (maybe as yaml extension)\nAPI interface designing, and developing server and client applications at the same time later.","enum#Enum":"// OpenAPI v3.1\nconst original: OpenApiV3_1.IJsonSchema.IString = {\n  type: \"string\",\n  enum: [\"cat\", \"dog\", \"lion\"],\n};\n// Emended\nconst emended: OpenApi.IJsonSchema.IOneOf = {\n  oneOf: [\n    { const: \"cat\" },\n    { const: \"dog\" },\n    { const: \"lion\" },\n  ],\n};","changements#Changements":"","allof#AllOf":"// OpenAPI v3.1\nconst original: OpenApiV3_1.IJsonSchema.IAllOf = {\n  allOf: [\n    {\n      type: \"object\",\n      properties: {\n        name: { type: \"string\" },\n        hobby: {\n          type: \"object\",\n          properties: {\n            name: { type: \"string\" },\n          },\n          required: [\"name\"],\n        },\n      },\n      required: [\"name\", \"hobby\"],\n    },\n    {\n      type: \"object\",\n      properties: {\n        age: { type: \"integer\" },\n        hobby: {\n          type: \"object\",\n          properties: {\n            category: { type: \"string\" },\n          },\n          required: [\"category\"],\n        },\n      },\n      required: [\"age\", \"hobby\"],\n    },\n  ],\n};\n// Emended\nconst emended: OpenApi.IJsonSchema.IObject = {\n  type: \"object\",\n  properties: {\n    name: { type: \"string\" },\n    hobby: {\n      type: \"object\",\n      properties: {\n        name: { type: \"string\" },\n        category: { type: \"string\" },\n      },\n      required: [\"name\", \"category\"],\n    },\n    age: { type: \"integer\" },\n  },\n  required: [\"name\", \"hobby\", \"age\"],\n};\nIn the OpenAPI v3.1 specification, there is a special reference type allOf. The allOf type is used for composing the schema by combining multiple schemas, and it is exactly similar to the TypeScript's intersection type like A & B.However, such intersection allOf type can be converted to a plain object or array type. Therefore, \"Wrtn Studio Pro\" forcibly casts the allOf type to the plain object or array type for clarity.","anyof#AnyOf":"// OpenAPI v3.1\nconst original: OpenApiV3_1.IJsonSchema.IAnyOf = {\n  anyOf: [\n    { type: \"number\" },\n    { type: \"string\" },\n  ],\n};\n// Emended\nconst emended: OpenApi.IJsonSchema.IOneOf = {\n  oneOf: [\n    { type: \"number\" },\n    { type: \"string\" },\n  ],\n};\nIn the OpenAPI v3.1 specification, there're two ways to composing union type. The first way is to defining oneOf, and the other way is to defining anyOf type. To pursue clartiy by removing synonym expression, \"Wrtn Studio Pro\" forcibly casts the anyOf type to oneOf type.For reference, \"Wrtn Studio Pro\" is compiling workflow program to TypeScript, and the TypeScript's union type is similar to the oneOf meaning. Such principle applies equally to other programming languages; oneOf, which must clearly refer to one type, is more appropriate than anyOf, which can be any type.This is the reason why \"Wrtn Studio Pro\" has adopted oneOf type instead of anyOf type.","recursivereference#RecursiveReference":"// OpenAPI v3.1\nconst original: OpenApiV3_1.IJsonSchema.IRecursiveReference = {\n  $recursiveRef: \"#/components/schemas/Category\",\n};\n// Emended\nconst emended: OpenApi.IJsonSchema.IReference {\n  $ref: \"#/components/schemas/Category\",\n};\nIn the OpenAPI v3.1 specification, there is a special reference type recursiveRef. The recursiveRef indicates the reference type is recursive, so that the reference type is referring to itself recursively when visiting the nested schema elements.However, the recursiveRef type is not a mandatory specification, and it is easy to check whether the reference type is recursive or not, so that \"Wrtn Studio Pro\" forcibly casts the recursiveRef type to the ref type for clarity.","separations#Separations":"","nullable#Nullable":"// OpenAPI v3.1\nconst original: OpenApiV3_1.IJsonSchema.IOneOf = {\n  oneOf: [\n    { \n      type: \"number\", \n      nullable: true,\n    },\n    {\n      type: \"string\",\n      nullable: true,\n    },\n  ],\n};\n// Emended\nconst emended: OpenApi.IJsonSchema.IOneOf = { \n  oneOf: [\n    { type: \"number\" },\n    { type: \"string\" },\n    { type: \"null\" },\n  ],\n};\nimport typia from \"typia\";\ntypia.json.application<[\n  number | string | null,\n]>();\n  // {\n  //   oneOf: [\n  //     {\n  //       type: \"null\",\n  //     },\n  //     {\n  //       type: \"string\",\n  //     },\n  //     {\n  //       type: \"number\",\n  //     },\n  //   ],\n  // }\n💻 Playground Link\nIn the OpenAPI v3.1 specification, there're two ways to composing nullable type. The first is adding nullable property to a schema, and the second way is to declaring a null type and combinating it with the oneOf type.To pursue clarity by removing synonym expression, \"Wrtn Studio Pro\" adapts the second way; \"declaring null type and combinating it with the oneOf type.For reference, \"Wrtn Studio Pro\" has adopted the null type with oneOf type combination is, it is clear than nullable property case. As you can see from the above example code of the second tab, the nullable property can be duplicated when union type comes.","array-and-tuple#Array and Tuple":"export namespace OpenApiV3_1 {\n  export namespace IJsonSchema {\n    export interface IArray extends __ISignificant<\"array\"> {\n      items: IJsonSchema | IJsonSchema[];\n      prefixItems?: IJsonSchema[];\n      additionalItems?: boolean | IJsonSchema;\n      uniqueItems?: boolean;\n      /** @type uint64 */ minItems?: number;\n      /** @type uint64 */ maxItems?: number;\n    }\n  }\n}\nexport namespace OpenApi {\n  export namespace IJsonSchema {\n    export interface IArray extends __ISignificant<\"array\"> {\n      items: IJsonSchema;\n      uniqueItems?: boolean;\n      /** @type uint64 */ minItems?: number;\n      /** @type uint64 */ maxItems?: number;\n    }\n    export interface ITuple extends __ISignificant<\"array\"> {\n      prefixItems: IJsonSchema[];\n      additionalItems?: boolean | IJsonSchema;\n      uniqueItems?: boolean;\n      /** @type uint64 */ minItems?: number;\n      /** @type uint64 */ maxItems?: number;\n    }\n  }\n}\n//----\n// OpenAPI v3.1\n//----\nconst originalArray: OpenApiV3_1.IJsonSchema.IArray = {\n  type: \"array\",\n  items: {\n    type: \"boolean\",\n  }\n};\nconst originalTuple: OpenApiV3_1.IJsonSchema.IArray = {\n  type: \"array\",\n  items: [\n    { type: \"string\" },\n    { type: \"number\" },\n  ],\n}\n//----\n// Emended\n//---\nconst emendedArray: OpenApi.IJsonSchema.IArray = {\n  type: \"array\",\n  items: {\n    type: \"boolean\",\n  },\n};\nconst emendedTuple: OpenApi.IJsonSchema.ITuple = {\n  type: \"array\",\n  prefixItems: [\n    { type: \"string\" },\n    { type: \"number\" },\n  ],\n};\nimport typia from \"typia\";\ntypia.json.application<[\n  Array<boolean>,\n  [string, number],\n  [number, string, ...boolean[]],\n]>();\n// {\n//   version: \"3.1\",\n//   schemas: [\n//     {\n//       type: \"array\",\n//       items: { type: \"boolean\" },\n//     },\n//     {\n//       type: \"array\",\n//       prefixItems: [\n//         { type: \"string\" },\n//         { type: \"number\" },\n//       ],\n//     },\n//     {\n//       type: \"array\",\n//       prefixItems: [\n//         { type: \"number\" },\n//         { type: \"string\" },\n//       ],\n//       additionalItems: { type: \"boolean\" },\n//     },\n//   ],\n// }\n💻 Playground Link\nAs you can see, original specification of OpenAPI v3.1 has define Array to be ambiguous.The items property can be either a single schema or an array of schemas. When the items property is a single schema, it means an Array<T> type in the TypeScript. On the other hand, when the items property is an array of schemas, it means a tuple type in TypeScript like [string, number] case.Also in the tuple type case, it is possible to utilize prefixItems property instead of the items proeprty. Furthermore, the additionalItems property can be used only when the tuple type case.To clarify the distinction between array and tuple types, \"Wrtn Studio Pro\" has separated OpenApiV3_1.IJsonSchema.IArray type to OpenApi.IJsonSchema.IArray and OpenApi.IJsonSchema.ITuple types, removing vulnerable properties to each side."}},"/tech-specs/openapi/plugin":{"title":"Plugin","data":{"json-schema#JSON Schema":"We are defining surplus plugin properties for special purposes.\nexport namespace ISwaggerSchema {\n  /**\n   * String type info.\n   */\n  export interface IString extends OpenApi.IJsonSchema.IString, __IAttribute {\n    /**\n     * Secret key for the schema.\n     *\n     * `x-wrtn-secret-key` is a property means a secret key that is required\n     * for the target API endpoint calling. If the secret key is not filled,\n     * the API call would be failed.\n     */\n    \"x-wrtn-secret-key\"?: string;\n    /**\n     * Secret scopes for the schema.\n     *\n     * `x-wrtn-secret-scopes` is a property means a list of secret scopes that\n     * are required for the target API endpoint calling. If the secret scopes\n     * are not satisfied, the API call would be failed.\n     */\n    \"x-wrtn-secret-scopes\"?: string[];\n  }\n  /**\n   * Plugin properties for every types.\n   */\n  export interface __IAttribute {\n    /**\n     * Placeholder value for frontend application.\n     *\n     * Placeholder means the value to be shown in the input field as a hint.\n     * For example, when an email input field exists, the placeholder value\n     * would be \"Insert your email address here\".\n     */\n    \"x-wrtn-placeholder\"?: string;\n    /**\n     * Prerequisite API endpoint for the schema.\n     *\n     * `x-wrtn-prerequisite` is a property representing the prerequisite API\n     * interaction. It means that, the endpoint API should be called before\n     * calling the target API, for composing some argument value.\n     *\n     * @reference https://github.com/wrtnio/decorators/blob/main/src/Prerequisite.ts\n     */\n    \"x-wrtn-prerequisite\"?: {\n      /**\n       * HTTP method to call the endpoint.\n       */\n      method: \"get\" | \"post\" | \"patch\" | \"put\" | \"delete\";\n      /**\n       * Path of the endpoint.\n       */\n      path: string;\n      /**\n       * Function returning transformed values using JMESPath expression.\n       *\n       * `Prerequisite.Props.jmesPath` is a string typed property that extracts desired values\n       * from the prerequisite API response using a JMESPath expression. This property simplifies\n       * and replaces the `label`, `value`, and `array` properties.\n       *\n       * JMESPath expressions are used to extract the desired data based on the API response.\n       * The expression must always be a valid JMESPath syntax.\n       *\n       * - Type: `jmesPath: string`\n       * - Example: `\"members[*].data.title\"`\n       * - Usage: `jmespath.search(response, jmesPath)`\n       *\n       * Note: The `label`, `value`, and `array` properties are no longer in use.\n       */\n      jmesPath: string;\n    };\n  }\n}\nexport namespace OpenApi {\n  export type IJsonSchema =\n    | IJsonSchema.IConstant\n    | IJsonSchema.IBoolean\n    | IJsonSchema.IInteger\n    | IJsonSchema.INumber\n    | IJsonSchema.IString\n    | IJsonSchema.IArray\n    | IJsonSchema.ITuple\n    | IJsonSchema.IObject\n    | IJsonSchema.IReference\n    | IJsonSchema.IOneOf\n    | IJsonSchema.INull\n    | IJsonSchema.IUnknown;\n  export namespace IJsonSchema {\n    export interface IConstant extends __IAttribute {\n      const: boolean | number | string;\n    }\n    export interface IBoolean extends __ISignificant<\"boolean\"> {\n      default?: boolean;\n    }\n    export interface IInteger extends __ISignificant<\"integer\"> {\n      /** @type int64 */ default?: number;\n      /** @type int64 */ minimum?: number;\n      /** @type int64 */ maximum?: number;\n      exclusiveMinimum?: boolean;\n      exclusiveMaximum?: boolean;\n      /**\n       * @type uint64\n       * @exclusiveMinimum 0\n       */\n      multipleOf?: number;\n    }\n    export interface INumber extends __ISignificant<\"number\"> {\n      default?: number;\n      minimum?: number;\n      maximum?: number;\n      exclusiveMinimum?: boolean;\n      exclusiveMaximum?: boolean;\n      /** @exclusiveMinimum 0 */ multipleOf?: number;\n    }\n    export interface IString extends __ISignificant<\"string\"> {\n      default?: string;\n      format?:\n        | \"binary\"\n        | \"byte\"\n        | \"password\"\n        | \"regex\"\n        | \"uuid\"\n        | \"email\"\n        | \"hostname\"\n        | \"idn-email\"\n        | \"idn-hostname\"\n        | \"iri\"\n        | \"iri-reference\"\n        | \"ipv4\"\n        | \"ipv6\"\n        | \"uri\"\n        | \"uri-reference\"\n        | \"uri-template\"\n        | \"url\"\n        | \"date-time\"\n        | \"date\"\n        | \"time\"\n        | \"duration\"\n        | \"json-pointer\"\n        | \"relative-json-pointer\"\n        | (string & {});\n      pattern?: string;\n      contentMediaType?: string;\n      /** @type uint64 */ minLength?: number;\n      /** @type uint64 */ maxLength?: number;\n    }\n    export interface IArray<Schema extends IJsonSchema = IJsonSchema>\n      extends __ISignificant<\"array\"> {\n      items: Schema;\n      uniqueItems?: boolean;\n      /** @type uint64 */ minItems?: number;\n      /** @type uint64 */ maxItems?: number;\n    }\n    export interface ITuple<Schema extends IJsonSchema = IJsonSchema>\n      extends __ISignificant<\"array\"> {\n      prefixItems: Schema[];\n      additionalItems?: boolean | Schema;\n      uniqueItems?: boolean;\n      /** @type uint64 */ minItems?: number;\n      /** @type uint64 */ maxItems?: number;\n    }\n    export interface IObject<Schema extends IJsonSchema = IJsonSchema>\n      extends __ISignificant<\"object\"> {\n      properties?: Record<string, Schema>;\n      additionalProperties?: boolean | Schema;\n      required?: string[];\n    }\n    export interface IReference<Key = string> extends __IAttribute {\n      $ref: Key;\n    }\n    export interface IOneOf<Schema extends IJsonSchema = IJsonSchema>\n      extends __IAttribute {\n      oneOf: Exclude<Schema, IJsonSchema.IOneOf>[];\n      discriminator?: IOneOf.IDiscriminator;\n    }\n    export namespace IOneOf {\n      export interface IDiscriminator {\n        propertyName: string;\n        mapping?: Record<string, string>;\n      }\n    }\n    export interface INull extends __ISignificant<\"null\"> {\n      default?: null;\n    }\n    export interface IUnknown extends __IAttribute {\n      type?: undefined;\n    }\n    export interface __ISignificant<Type extends string> extends __IAttribute {\n      type: Type;\n    }\n    export interface __IAttribute {\n      title?: string;\n      description?: string;\n      deprecated?: boolean;\n    }\n  }\n}\n\"Wrtn Studio Pro\" is defining surplus plugin properties to JSON schema for special purposes.At first, \"Wrtn Studio Pro\" has defined two additional properties to the string type; x-wrtn-secret-key and x-wrtn-secret-scopes. When those properties are specified, it means that the target value must be filled with the secret value which satisfies the secret key and scopes.For example, in the \"Wrtn Studio Pro\", you can send an email in the chatting room through the G-Mail service. To send an email through the G-Mail service, you need to fill the secret value of the Google manually. Therefore, below G-Mail sending related JSON schema has the x-wrtn-secret-key and x-wrtn-secret-scopes properties to specify the secret key and scopes.\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"to\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      },\n      \"title\": \"Email address of the receipant.\"\n    },\n    \"subject\": {\n      \"type\": \"string\",\n      \"title\": \"Title of the email content.\"\n    },\n    \"body\": {\n      \"type\": \"string\",\n      \"title\": \"Body of the email content.\",\n      \"description\": \"Mail content body of the email sending.\\n\\nThe content must be written in the HTML format. If not, the content body can be broken.\\n\\nAlso, adjust only the G-Mail adjustable CSS styles.\\n\\nAt last, please do not write too long content. If the content length is too much long, e-mail sending can be failure.\"\n    },\n    \"cc\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      },\n      \"title\": \"List of reference email list\"\n    },\n    \"Bcc\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      },\n      \"title\": \"List of hidden reference email list\"\n    },\n    \"secretKey\": {\n      \"type\": \"string\",\n      \"x-wrtn-secret-key\": \"google\",\n      \"x-wrtn-secret-scopes\": [\n        \"https://mail.google.com/\"\n      ],\n      \"title\": \"Authentification key for the G-Mail service.\"\n    }\n  },\n  \"required\": [\n    \"to\",\n    \"subject\",\n    \"body\",\n    \"secretKey\"\n  ],\n  \"title\": \"The information for sending an email through the G-Mail service.\"\n}\nAlso, \"Wrtn Studio Pro\" has defined some additional properties to every JSON schema types. The additional properties are x-wrtn-placeholder and x-wrtn-prerequisite.The first property x-wrtn-placeholder is a property to show a hint label in the input field. For example, when there is a string typed JSON schema with email format, the x-wrtn-placeholder property would be written like \"Insert your e-mail address please\".The other property x-wrtn-prerequisite is a property indicating the prerequisite API interaction. It means that the prerequisite API should be called befored composing the target value of the JSON schema. method and path member properties of the x-wrtn-prerequisite are the HTTP method and path of the prerequisite API endpoint. The jmesPath member property is a JMESPath expression to extract the desired values from the prerequisite API response.","operation#Operation":"/**\n * Remote operation info.\n *\n * `ISwaggerOperation` represents an Restful API operation provided by the\n * remote server.\n */\nexport interface ISwaggerOperation extends OpenApi.IOperation<ISwaggerSchema> {\n  /**\n   * Icon URL.\n   *\n   * `x-wrtn-icon` is a property means an icon URL representing the target API.\n   */\n  \"x-wrtn-icon\"?: string & tags.Format<\"uri\">;\n}\nexport namespace OpenApi {\n  /**\n   * Remote operation info.\n   *\n   * `OpenApi.IOperation` represents an Restful API operation provided by the\n   * remote server.\n   */\n  export interface IOperation<Schema extends IJsonSchema = IJsonSchema> {\n    /**\n     * Unique string used to identify the operation.\n     */\n    operationId?: string;\n    /**\n     * List of parameters that are applicable for this operation.\n     */\n    parameters?: IOperation.IParameter<Schema>[];\n    /**\n     * The request body applicable for this operation.\n     */\n    requestBody?: IOperation.IRequestBody<Schema>;\n    /**\n     * The list of possible responses as they are returned from executing this\n     * operation. Its key is the HTTP status code, and the value is the metadata of\n     * the response in the HTTP status code.\n     */\n    responses?: Record<string, IOperation.IResponse<Schema>>;\n    /**\n     * A list of servers providing this API operation.\n     */\n    servers?: IServer[];\n    /**\n     * A short summary of what the operation does.\n     */\n    summary?: string;\n    /**\n     * A verbose explanation of the operation behavior.\n     */\n    description?: string;\n    /**\n     * List of securities and their scopes that are required for execution.\n     *\n     * When this property be configured, the Restful API operation requires\n     * the matched security value for exection. Its key means security key\n     * matched with {@link OpenApi.IDocument.security}.\n     *\n     * The value means scopes required for the security key when the security\n     * type is {@link OpenApi.ISecurityScheme.IOAuth2}. Otherwise the target\n     * security type is not {@link OpenApi.ISecurityScheme.IOAuth2}, the value\n     * would be empty array.\n     */\n    security?: Record<string, string[]>[];\n    /**\n     * Tags for API documentation control.\n     */\n    tags?: string[];\n    /**\n     * Flag for indicating this operation is deprecated.\n     */\n    deprecated?: boolean;\n  }\n}\n\"Wrtn Studio Pro\" is defining plugin property x-wrtn-icon to the OpenApi.IOperatio object.It is to show representative icon images for each API operation.Here is the example operation case shown in the \"Wrtn Studio Pro\" service.","document#Document":"export namespace OpenApi {\n  /**\n   * OpenAPI document.\n   *\n   * `OpenApi.IDocument` represents an OpenAPI document of emended OpenAPI v3.1.\n   *\n   * In other words, `OpenApi.IDocument` is a structure of `swagger.json` file of\n   * OpenAPI v3.1 specification, but a little bit shrinked to remove ambiguous and\n   * duplicated expressions of OpenAPI v3.1 for the convenience and clarity.\n   *\n   * @template Schema JSON schema type\n   * @template Operation HTTP operation type\n   */\n  export interface IDocument<\n    Schema extends IJsonSchema = IJsonSchema,\n    Operation extends IOperation<Schema> = IOperation<Schema>,\n  > {\n    /**\n     * Flag for indicating this document is emended by `@samchon/openapi`.\n     */\n    \"x-samchon-emended\": true;\n    /**\n     * OpenAPI version number.\n     */\n    openapi: `3.1.${number}`;\n    /**\n     * List of servers that provide the API.\n     */\n    servers?: IServer[];\n    /**\n     * Information about the API.\n     */\n    info?: IDocument.IInfo;\n    /**\n     * An object to hold reusable data structures.\n     *\n     * It stores both DTO schemas and security schemes.\n     *\n     * For reference, `nestia` defines every object and alias types as reusable DTO\n     * schemas. The alias type means that defined by `type` keyword in TypeScript.\n     */\n    components: IComponents<Schema>;\n    /**\n     * The available paths and operations for the API.\n     *\n     * The 1st key is the path, and the 2nd key is the HTTP method.\n     */\n    paths?: Record<string, IPath<Schema, Operation>>;\n    /**\n     * An object to hold Webhooks.\n     *\n     * Its structure is same with {@link paths}, so that the 1st key is the path,\n     * and the 2nd key is the HTTP method.\n     */\n    webhooks?: Record<string, IPath<Schema, Operation>>;\n    /**\n     * A declaration of which security mechanisms can be used across the API.\n     *\n     * When this property be configured, it would be overwritten in every API routes.\n     *\n     * For reference, key means the name of security scheme and value means the `scopes`.\n     * The `scopes` can be used only when target security scheme is `oauth2` type,\n     * especially for {@link ISwaggerSecurityScheme.IOAuth2.IFlow.scopes} property.\n     */\n    security?: Record<string, string[]>[];\n    /**\n     * List of tag names with description.\n     *\n     * It is possible to omit this property or skip some tag name even if\n     * the tag name is used in the API routes. In that case, the tag name\n     * would be displayed (in Swagger-UI) without description.\n     */\n    tags?: IDocument.ITag[];\n  }\n}\n\"Wrtn Studio Pro\" utilizing emended OpenAPI v3.1 specification has special property on the OpenApi.IDocument object. The property is x-samchon-emended and it is a flag for indicating this document is emended by @samchon/openapi.If the x-samchon-emended is false or undefined, it means that the document has not been emended yet. In that case, \"Wrtn Studio Pro\" automatically emends the document by @samchon/openapi and sets the x-samchon-emended flag to be true."}},"/tech-specs/openapi/preface":{"title":"Preface","data":{"everywhere#Everywhere":"\"Wrtn Studio Pro\" is utilizing OpenAPI specifications everywhere.\"Wrtn Studio Pro\" is a service providing a Meta LLM (A.I. Chatbot) which can perform various function callings from API marketplace sales, and an Workflow Compiler (with SWL language) that automates the Meta LLM scenario as an re-usable and executable program function with visual diagrams.By the way, \"Wrtn Studio Pro\" is utilizing OpenAPI specifications for standard schema/operation definitions, so that the OpenAPI specifications are used in every part of the \"Wrtn Studio Pro\"; LLM function calling, Workflow schema definitions, and API marketplace documentation.Therefore, if you want to learn the principles of \"Wrtn Studio Pro\", you have to understand the OpenAPI specifications. Let's start to see how the \"Wrtn Studio Pro\" defines and utilizes the OpenAPI specifications. Also, if you're planning to participant in \"Wrtn Studio Pro\" as an API provider, it would better to read the appendix article: Contract Driven Development.","specification#Specification":"\"Wrtn Studio Pro\" has adopted OpenAPI v3.1 specifications, but emended it for clarity and consistency.If user of API marketplace uploads a different version of OpenAPI specifications, \"Wrtn Studio Pro\" will convert it to the internal \"emended 3.1\" version of OpenAPI specifications. Below is the list of the OpenAPI specifications including the emended version of ours.\nOpenAPI v3.1 emended\nOpenAPI v3.1\nOpenAPI v3.0\nSwagger v2.0","plugins#Plugins":"\"Wrtn Studio Pro\" has defined additional OpenAPI plugin properties for special purposes.For example, x-wrtn-secret-key and x-wrtn-secret-scopes are plugin properties that indicating the user (or LLM) must assign the secret key value and the secret value must satisfy the scopes to the target string typed (OpenApi.IJsonSchema.IString) schema value.\nOperation Schema Plugin\nJSON Schema Plugins\n{\n  \"type\": \"string\",\n  \"x-wrtn-secret-key\": \"google\",\n  \"x-wrtn-secret-scopes\": [\"https://mail.google.com/\"]\n}","conversion#Conversion":"import { OpenApi, OpenApiV3, OpenApiV3_1, SwaggerV2 } from \"@samchon/openapi\";\nimport typia from \"typia\";\nconst main = async (): Promise<void> => {\n  // GET YOUR OPENAPI DOCUMENT\n  const response: Response = await fetch(\n    \"https://raw.githubusercontent.com/samchon/openapi/master/examples/v3.0/openai.json\"\n  );\n  const document: any = await response.json();\n  // TYPE ASSERTION\n  typia.assertGuard<\n    | OpenApiV3_1.IDocument\n    | OpenApiV3.IDocument\n    | SwaggerV2.IDocument\n  >(document);\n  // CONVERT TO EMENDED\n  const emended: OpenApi.IDocument = OpenApi.convert(document);\n  console.log(emended);\n};\nmain().catch(console.error);\n💻 Playground Link\nManual conversion to \"emended OpenAPI v3.1 specification\".When you upload OpenAPI document to the \"Wrtn Studio Pro\", the uploaded OpenAPI document would be automatically converted to the \"emended OpenAPI v3.1 specification\". It does not matter whatever your OpenAPI document version is.By the way, if you want to pre-convert it to the \"emended OpenAPI v3.1 specification\" manually for testing, you can do it like above example code. Also, by following the above example TypeScript code, you can validate your OpenAPI document before the conversion, too."}},"/tech-specs/swl/preface":{"title":"Preface","data":{}},"/tech-specs/workflow/editor":{"title":"Editor","data":{}},"/tech-specs/workflow/inspector":{"title":"Inspector","data":{}},"/tech-specs/workflow/preface":{"title":"Preface","data":{"workflow-engine#Workflow Engine":"Workflow engine for re-usable program generation.\"Wrtn Studio Pro\" provides an \"Workflow Engine\" which can build a re-usable program function. The workflow can be generated by two ways. The first is analyzing the user's utternance and LLM function call histories in the Meta LLM (A.I. Chatbot) and constructs the workflow by SWL Language. The second way is using the Workflow Editor manually which can build the workflow with visual diagrams. Of course, generating workflow by the first way and updating it by the second way is also possible.When you've succeded to build a workflow program (function), you can execute it in two ways. The first way is to executing the workflow program manually by configuring the parameter values by yourself. The other way is to registering the to a scheduler, so that the workflow program can be executed automatically at the scheduled time by the system.For reference, the workflow program also belongs to the ecosystem of the \"Wrtn Studio Pro\". The workflow program can be re-executed by the Meta LLM (A.I. Chatbot) with LLM function calling. If you enroll your workflow program to the API Marketplace, the workflow program can be re-used by the many other users.","workflow-schema#Workflow Schema":"Compiler + Repository.\"Workflow Engine\" is a type of compiler which generates a re-usable program function. And the workflow document must be archived into somewhere repository of some account. Therefore, workflow schemas are categorized into three parts; compiler, repository and belonged account.At first, the compiler category schemas are represented by AST (Abstract Syntax Tree). The AST is a tree representation of the abstract syntactic structure of source code written in a programming language. The AST is used in the compiler backend to generate the executable program function.At second, account and repository categorized schemas are similar to the Github account/repository structures. The account schema is literally an account innformation of user or enterprise, and the repository schema is a storage for the workflow documents including commit histories for version control.","compiler-backend#Compiler Backend":"Build executable program from workflow document.When you've built an workflow document by manually or Meta LLM (A.I. Chatbot), compiler backend of \"Workflow Engine\" transforms the workflow document into an executable program function. The compiler backend is a kind of interpreter which reads the workflow document and generates the program function.The result of the compilation is a TypeScript/JavaScript source code, and it is mounted on an Worker instance. When you (or scheduler) call the workflow program function, it would be called by the RPC (Remote Procedure Call) protocol.If you've published the workflow program to the API Marketplace, the workflow program would be wrapped into an API endpoint of OpenAPI specification. Therefore, the workflow program can be called by the HTTP protocol as well.","workflow-editor#Workflow Editor":"\"Workflow Engine\" is a type of visual compiler.","json-schema-renderer#JSON Schema Renderer":"UI components based on JSON schema."}},"/tech-specs/workflow/schema":{"title":"Schema","data":{"summary#Summary":"In here chapter, we will learn about the schema of the workflow engine.The \"Workflow Engine\" is a type of compiler which generates a re-usable program function. And the workflow document must be archived into somewhere repository of some account. Therefore, workflow schemas are categorized into three parts; compiler, repository and belonged account.At first, the compiler category schemas are represented by AST (Abstract Syntax Tree). The AST is a tree representation of the abstract syntactic structure of source code written in a programming language. The AST is used in the compiler backend to generate the executable program function.At second, account and repository categorized schemas are similar to the Github account/repository structures. The account schema is literally an account innformation of user or enterprise, and the repository schema is a storage for the workflow documents including commit histories for version control.By the way, even though the workflow schemas are separated to three parts (compiler, repository and account), they are all started from and interconnected in the workflow document. Therefore, we will learn from the workflow document, the IStudioWorkflow type.","workflow#Workflow":"Workflow document with function metadata.\nIStudioWorkflow: Workflow document (file)\nIStudioWorkflowData: Function metadata with AST nodes\nIStudioWorkflowParameter: Metadata of parameter types\nIStudioWorkflowSwagger: OpenAPI document used in the workflow for (LLM) function calling\nWorkflow document is a type of file which is stored into a repository. It is represented by the IStudioWorkflow type, and contains the location, file name and extension of the workflow document.The workflow document also has been designed to compile to a re-usable program function. Therefore, the workflow document contains the metadata of the goal function to be compiled. These function metadata informations are stored in the IStudioWorkflowData type, and includes the parameter types, return type and description of the function including the AST nodes.In the workflow document function data, there would be some function call statements to the OpenAPI operations obtained from the OpenAPI Marketplace. If the workflow document has been generated by Meta LLM (A.I. Chatbot) through SWL language, the function call statement must be. In the workflow document, such OpenAPI documents are capsuled into the IStudioWorkflowSwagger type and their operations are wrapped into the IStudioWorkflowSwaggerOperation type.","statements#Statements":"AST Statements with geometry info.\nIStudioWorkflowBlockStatement\nIStudioWorkflowBranchStatement\nIStudioWorkflowCallStatement\nIStudioWorkflowSetStatement\nIStudioWorkflowForEachStatement\nIStudioWorkflowWhileStatement\nIStudioWorkflowRepeatStatement\nIStudioWorkflowReturnStatement\nIStudioWorkflowSetReturnValueStatement\nIStudioWorkflowBreakStatement\nIStudioWorkflowContinueStatement\nIGeometry2D\nHere is the every statements defined in the workflow document data.For reference, a statement in the context of an Abstract Syntax Tree (AST) refers to a syntactic construct that represents a single instruction or command in a programming language. Statements are the building blocks of a program's logic and control flow. They can include various types of operations, such as:\nAssignment Statements: Assigning a value to a variable (e.g., x = 5).\nControl Flow Statements: Directing the flow of execution (e.g., if, for, while).\nFunction Calls: Invoking a function (e.g., print(\"Hello, World!\")).\nReturn Statements: Specifying the value to be returned from a function (e.g., return x).\nIn an AST, each statement is represented as a node, and the relationships between statements can be depicted through parent-child connections, reflecting the structure and flow of the program. This representation allows for easier analysis and manipulation of the code during various stages of compilation or interpretation.By the way, as workflow embodies a visual diagram, the statements are also have the geometry information represented by the IGeometry2D type. As the IGeometry2D has the position and scale properties, every statement nodes in the workflow diagram can be placed and scaled in the visual editor.","expressions#Expressions":"AST Expressions.\nIAstArrayLiteralExpression\nIAstBinaryExpression\nIAstCallExpression\nIAstConditionalExpression\nIAstElementAccessExpression\nIAstNonNullExpression\nIAstObjectLiteralExpression\nIAstParenthesizedExpression\nIAstPrefixUnaryExpression\nIAstPostfixUnaryExpression\nIAstPropertyAccessExpression\nIAstSpreadElementExpression\nIAstTemplateExpression\nIAstIdentifier\nIAstTrueLiteral\nIAstFalseLiteral\nIAstNumericLiteral\nIAstNoSubstitutionTemplateLiteral\nIAstStringLiteral\nIAstNullLiteral\nIAstArrayFilterExpression\nIAstArrayFlatExpression\nIAstArrayFunctionParameterIdentifier\nIAstArrayFunctionIndexIdentifier\nIAstArrayMapExpression\nIAstObjectFlatExpression\nIAstObjectEntriesExpression\nIAstWorkflowParameterIdentifier\nIAstWorkflowVariableIdentifier\nIAstWorkflowCallStatementResultIdentifier\nIAstWorkflowEnvironmentVariableIdentifier\nIAstWorkflowLoopStatementElementIdentifier\nIAstWorkflowLoopStatementResultIdentifier\nIAstWorkflowSecretIdentifier\nIAstWorkflowMetadataIdentifier\nHere is the every expressions defined in the workflow document data.For reference, in the context of an Abstract Syntax Tree (AST), an expression is a structure that evaluates to a value. Expressions can range from simple values or variables to complex forms that include operations, function calls, and other expressions. Common types of expressions include:\nLiteral Expressions: Direct values like numbers or strings (e.g., 42, \"Hello\").\nVariable Expressions: References to variables (e.g., x).\nArithmetic Expressions: Combinations of values and operators (e.g., x + y, 3 * (a - b)).\nFunction Call Expressions: Calls to functions that return values (e.g., max(x, y))\nAlso, as workflow embodies a visual diagram, depth of the expression cannot be infinite like text programming language, and too much complicate structures cannot be drawn by the visual components either. In such reason, you can find some additional expressions in the above list, which does not exist in the text programming languages.The IAstArrayFunctionParameterIdentifier type is one of the example case which resolves too much complicated structure for visual expression. It can be combined by many expressions and statements in the text programming language like below, but \"Wrtn Studio Pro\" resolved it to a single expression for simple visual expression.\nsomeArray.forEach((item, i) => {});\n// - `CallExpression`\n//   - `PropertyAccessExpression`\n//     - `Identifier`: someArray\n//     - `Identifier`: forEach\n//   - `ArrowFunction`\n//     - `ParameterDeclaration`: item\n//       - `Identifier`\n//     - `ParameterDeclaration`: i\n//       - `Identifier`\n//     - `EqualsGreaterThanToken`\n//     - `Block`","repository-schema#Repository Schema":"","studio_repositories#studio_repositories":"스튜디오 저장소.studio_repositories 는 스튜디오 시스템 내 개별 저장소를 형상화한 엔티티로써,\n온라인 서비스 상 깃허브의 저장소 같은 개념이다. 그리고 물리적으로는\n디스크 드라이브에 비유될 수 있는 개념이다.그리고 저장소는 특정 계정에 귀속되며, 각각의 저장소를\n소유한 계정주는 회원일 수도 있고,\n기업일 수도 있다. 더하여, 저장소를 생성한 계정주는\n그 자신 외에도, 저장소의 접근 권한 제어를\n통하여, 동료 회원이나\n팀원들과 해당 저장소를 함께 사용할 수 있다.Properties\nid: Primary Key.\nstudio_account_id: 귀속 계정의 studio_accounts.id\nhub_customer_id: 저장소를 생성한 최초 고객의 hub_customers.id\ncode\n식별자 코드.서비스 상 저장소 URL 주소의 일부 경로에 해당하는 부분.\ntitle: 저장소 제목\ndescription: 저장소에 대한 상세 설명\ndisclosure\n저장소의 공개 수준.\npublic: 모든 회원이 열람 가능한 공개 저장소.\nprotected: 직원들만 열람 가능한 보호 저장소.\nprivate: 권한을 부여받은 이들만 열람 가능한 비공개 저장소.\ncreated_at: 저장소 생성 일시.\nupdated_at: 저장소 편집 일시.\ndeleted_at: 저장소 삭제 일시.","studio_repository_accesses#studio_repository_accesses":"저장소 접근 권한 정보.studio_repository_accesses 는 저장소의 접근 권한 정보를 형상화한 엔티티로써,\n계정주가 저장소의 권한을 타\n회원이나 기업의 팀에게\n나눠줄 때 기록되는 엔티티이다.참고로 저장소를 생성한 계정주 또한, 접근 권한 제어에 기록되는 대상이다. 즉,\n계정주가 저장소를 생성한 그 즉시로, 본 테이블 레코드가 하나 생성되고 시작하는\n것.Properties\nid: Primary Key.\nstudio_repository_id: 귀속 저장소의 studio_repositories.id\nhub_customer_id: 접근 권한 제어를 생성한 고객의 hub_customers.id\nhub_member_id: 권한을 공여받은 회원의 hub_members.id\nstudio_enterprise_team_id: 권한을 공여받은 팀의 studio_enterprise_teams.id\nrole\n부여한 역할.\nowner: 저장소의 소유자. 모든 권한을 가진다\nmanager: 저장소의 매니저, 일반 구성원에 대한 권한을 가진다\nmember: 일반 구성원\nobserver: 저장소의 관람자, 오직 읽기만 가능\ncreated_at: 레코드 생성 일시.\nupdated_at: 레코드 편집 일시.\ndeleted_at: 레코드 삭제 일시.\napproved_at: 저장소 초대 승인 일시.","studio_repository_access_assignments#studio_repository_access_assignments":"저장소의 접근 권한 부여 정보.studio_repository_access_assignments 는 저장소에\n대한 접근 권한 부여 이력 정보를 형상화한\n엔티티이다.따라서 본 엔티티는 특정 회원 또는\n기업 팀을 대상으로 저장소에 대한 접근 권한을\n부여할 때 최초 1회 생명되며, 이후로 해당 권한의 역할을 변경할 때마다 누적된다.Properties\nid: Primary Key.\nstudio_repository_access_id: 귀속 저장소 접근 권한 정보의 studio_repository_accesses.id\nhub_customer_id: 새 역할을 부여한 고객의 hub_customers.id.\nrole: 새 역할.\ncreated_at: 레코드 생성 일시.","studio_repository_commits#studio_repository_commits":"저장소의 커밋 정보.저장소를 구성하는 각각의\n버킷들을 편집하고, 그 이력을 기록하는 행위를\n커밋이라고 한다. 그리고 studio_repository_commits 는 저장소에\n쓰기 권한을 가진\n고객이 행한 커밋 행위를 형상화한 엔티티이다.즉 본 커밋 레코드가 하나 생성되었다는 것은, 최소 한 개 이상의 버킷이 수정되었고,\n그리하여 그들에 대한 스냅샷 레코드들이\n새로이 생성되었다는 것을 뜻한다.단 커밋을 발행하였다하여, 그것이 곧 커밋의 완결을 뜻하는 것은 아니다. 커밋은\n그것의 기록 확정 일시를 뜻하는 archived_at 속성이 null 인 경우에는\n버킷들을 계속 수정할 수 있으며, 심지어 현재 수정 중인 커밋을 취소하고 삭제할\n수도 있다.Properties\nid: Primary Key.\nstudio_repository_id: 귀속 저장소의 studio_repositories.id\nparent_id: 부모 커밋의 id\nhub_customer_id: 커밋을 푸시한 고객의 hub_customers.id\ntitle: 커밋의 제목.\ndescription: 커밋에 대한 설명 서술부.\ncreated_at: 레코드 생성 일시.\nupdated_at: 레코드 수정 일시.\ndeleted_at: 레코드 삭제 일시.\narchived_at\n커밋 기록 확정 일시.커밋의 모든 변경사항을 서버에 기록함으로써, 이를 확정하고 완결짓는다.커밋을 기록한 이후로는, 일절 수정 및 삭제가 불가능하다.","studio_repository_buckets#studio_repository_buckets":"저장소 내 버킷 정보.studio_repository_buckets 는 저장소 내 존재하는 버킷을 형상화한 것으로써,\n여기서 말하는 버킷이란 곧, 저장소 내에 배치되는 다양한 폴더 및 파일들을 뜻한다.그리고 버킷은 최초 생성시, 그리고 그것을 수정하거나 경로를 변경할 때마다, 그\n내역을 모두 스냅샷이라는 단위로\n저장하여 이를 추적한다. 때문에 버킷의 주 정보 또한 하위\nstudio_repository_bucket_snapshots 엔티티에 기록되어, 실제로\n파일명이나 확장자 및 배치 폴더, 그리고 주 컨텐츠 등의 속성이 모두 스냅샷에\n속한다. 또한, 이러한 버킷의 수정은 모두\n커밋이라는 단위에 묶여, 한 번에 이루어진다.또한 여기서 말하는 파일이란, 일반적인 파일 뿐 아니라,\n워크플로우 문서 등 특수목적용\n파일도 함께 포함된다. 다만 이들에 대한 세부 서브타입 역시, 본 엔티티가 아닌\n하위 studio_repository_bucket_snapshots 엔티티로부터 파생된다.Properties\nid: Primary Key.\nstudio_repository_id: 귀속 저장소의 studio_repositories.id\nhub_customer_id: 버킷을 생성한 고객의 hub_customers.id\nstudio_repository_buckets_migration_id: Studio1.0 마이그레이션 테이블의 studio_repository_buckets_migration.id\ntype\n파일의 유형.파일의 타입에 관하여 discriminator 역할을 수행하는 속성이다.\ndirectory: 디렉터리\nfile: 일반적인 파일, 커넥터용 TS 소스 파일들도 포함됨\nworkflow: 워크플로우 문서\ncreated_at: 레코드 생성 일시.\nupdated_at: 레코드 수정 일시.\ndeleted_at: 레코드 삭제 일시.","studio_repository_bucket_snapshots#studio_repository_bucket_snapshots":"버킷의 스냅샷 정보.studio_repository_bucket_snapshots 는 저장소 내 버킷의 스냅샷을 형상화한\n엔티티로써, 고객이 저장소에\n버킷을 새로이 생성하거나 혹은 편집을 가할\n때마다 생성된다.물론, 버킷의 생성 및 수정 등 스냅샷이 변경되는 사건은 개개별별 독립적으로\n이루어지는 게 아니라, 커밋 단위에 묶여 한번에\n이루어진다.또한 버킷이 그러하였듯, 스냅샷 또한 그 종류에 따라 하위 서브타입들을 가진다.\nstudio_repository_file_snapshots: 일반 파일\nstudio_repository_workflow_snapshots: 워크플로우 문서 파일\n폴더는 별도 서브타입 레코드 없음\nProperties\nid: Primary Key.\nstudio_repository_bucket_id: 귀속 버킷의 studio_repository_buckets.id\nstudio_repository_commit_id: 귀속 커밋의 studio_repository_commits.id\npath: 버킷의 전체 경로.\nlocation\n버킷의 폴더상 경로.참고로 여기서 말하는 폴더상 경로는, 파일의 이름 및 확장자를 제외한 것을 뜻한다.\"foo/bar/baz.tz\" 라는 파일이 있다면, 이 중 location 값은 \"foo/bar\" 인 것.\nname\n파일의 이름.LICENSE 와 같이, 파일명을 생략하는 파일의 경우에는 \"\" 값 할당.\nextension\n파일의 확장자.LICENSE 와 같이, 확장자를 생략하는 파일의 경우에는 null 값 할당.물론 버킷의 타입이 디렉터리인 경우 또한 그러하다.\ncreated_at: 레코드 생성 일시.\nupdated_at: 레코드 수정 일시.","studio_repository_workflow_snapshots#studio_repository_workflow_snapshots":"워크플로우 문서의 스냅샷 레코드.studio_repository_workflow_snapshots 는 워크플로우 문서 파일의 스냅샷을\n형상화한 엔티티로써, studio 의 서브타입이다. 문자 그대로 워크플로우\n문서의 편집 내역을 기록하여, 워크플로우 문서 파일이 새로이 생성되거나 혹은 수정을\n가할 때마다 생성된다.물론, 워크플로우 문서 파일의 생성 및 수정 등 스냅샷이 변경되는 사건은 개개별별\n독립적으로 이루어지는 게 아니라, 커밋 단위에\n묶여 한 번에 이루어진다.Properties\nid: Primary Key.\nstudio_meta_chat_session_connection_message_id\n귀속 Meta LLM 채팅 세션 메시지의 studio_meta_chat_session_connections.id만일 본 워크플로우가 Meta LLM 채팅으로부터 비롯된 것이라면, 해당\n채팅 세션에서 워크플로우를 구성한\n메시지의 ID 를\n기록해주도록 한다.\nmeta_version\n메타데이터 버전.사용자가 정의한 스냅샷의 식별 버전이 아니다. 워크플로우 문서의 자료구조에\n대한 버전으로써, 뤼튼의 Studio 시스템이 직접 관리하는 단위.다만, Studio 프로젝트가 업그레이드되면서, 구 버전의 워크플로우 문서들도\n스케쥴러가 일괄 최신 버전으로 업데이트 해 주기에, 클라이언트 개발자는\n이 버전을 굳이 신경 쓸 필요가 없다.\nnamespace: 워크플로우 네임스페이스 식별자.\nvalid\n유효성 여부.워크플로우가 실행 가능한 지 여부를 나타낸다.최소 compile 이나 execute 함수를 실행해야 그 유효성을 확인할 수 있으며,\n그 전까지 본 속성의 값은 null 이다.물론, 릴리즈된 워크플로우라면, 이 값은 무조건 true 일 수 밖에 없다.\nis_chatbot: 챗봇을 위한 워크플로우인지 여부.\nicon: 워크플로우 대표 아이콘 URL.\nthumbnail\n워크플로우 썸네일 이미지.워크플로우 에디터 상 미니맵 혹은 축소 버전 이미지에 해당한다.\ntitle: 워크플로우 제목.\nsummary: 워크플로우 함수에 대한 요약 설명.\ndescription: 워크플로우 함수에 대한 상세 설명.\ndata\n문서 데이터.DTO 상 IStudioWorkflowData.ICreate 타입에 해당.","studio_repository_releases#studio_repository_releases":"저장소로부터의 배포 프로그램 정보.studio_repository_releases 는 저장소에서\n특징 커밋을 대상으로 배포한 프로그램을\n형상화한 엔티티이다.따라서 본 studio_repository_releases 엔티티에는 저장소를 구성하는 각\n파일 버킷의 노드 중, 고객이 선택한 요소들을 기점으로\n하여 studio_repository_release_nodes 레코드들이 구성된다. 그리고\n이들에 대한 메타데이터 (타입) 정보와 함께, 컴파일 및 번들링된 결과물이\n저장된다.이들을 널리 배포하는 것이 바로 릴리즈인 것.Properties\nid: Primary Key.\nstudio_repository_commit_id: 배포 대상 커밋의 studio_repository_commits.id\nhub_customer_id: 배포를 실시한 고객의 hub_customers.id\nversion: 배포 버전.\ncomponents\nJSON 스키마 컴포넌트.네임드 타입들의 집합.\nprogram_url\n프로그램의 URL 주소.현재 구조에서는 프로그램에 해당하는 script가 저장되어있는 s3 uri 주소.\ndebug_url: 디버깅 프로그램의 URL 주소.\ncreated_at: 레코드 생성 일시.\nopened_at: 배포 개시 일시.\ndeleted_at: 레코드 삭제 일시.","studio_repository_release_nodes#studio_repository_release_nodes":"저장소 배포 프로그램을 구성하는 개별 노드.studio_repository_release_nodes 는 저장소에서 배포한 프로그램 내,\n사용자가 지정하여 배출 (export) 한 프로그래밍 노드들을 형상화한 엔티티이다.참고로 배출 가능한 노드의 종류로는 사용자 정의 함수와, 워크플로우 문서가 있다.\n물론 워크플로우 문서 또한\n빌드 결과물이 단일 함수로 귀결되기에, 결국 노드란 곧 본 저장소로부터 배출된\n재사용 가능한 함수를 뜻한다.또한, 배출된 노드는 각각이 고유한 Rest API 상 endpoint 를 가진다. 따라서\n저장소의 각 노드는 다른 프로그램에서 import 하여 사용할 수도 있지만,\nRest API 를 통하여 외부에서 호출하는 것도 가능하다. 그리고 이를\nGenerative Hub 의 매물로 등록, 판매하는 것도 가능하다.Properties\nid: Primary Key.\nstudio_repository_release_id: 귀속 릴리즈 레코드의 studio_repository_releases.id\nstudio_repository_bucket_snapshot_id: 대상 버킷 스냅샷의 studio_repository_buckets.id\naccessor\n대상 함수에의 접근자.노드가 대상으로 하는 객체의 접근자를 IAstExpression 타입으로 표현한 것.가령 대상 객체(함수)의 이름이 \"compute\" 인데, 해당 파일로부터 최상위\n스코프에서 바로 export 된 것이라면, 그 타입은 IAstIdentifier 가 된다.\n반대로 re-export 되었거나 혹은 특정 namespace 로부터 export 되었다면,\n그 때는 IAstPropertyAccessExpression` 이 되거나 하는 식이다.\n{ type: \"Identifier\", text: \"compute\" }\n{\ntype: \"PropertyAccessExpression\",\nexpression: { type: \"Identifier\", text: \"Mathmatics\" },\nquestionDotToken: null,\nname: { type: \"Identifier\", text: \"compute\" },\n}\nsummary: 요약 설명문.\ndescription: 상세 설명문.\nmetadata\n메타데이터 정보.대상 노드가 함수인 경우에는 파라미터와 리턴 타입 등의 정보가 담긴다.자세한 내용은 관련 DTO 를 참고할 것.\nsequence: 귀속 릴리즈 내 배치 순서.\npurpose: 추출 목적","account-schema#Account Schema":"","studio_accounts#studio_accounts":"계정 엔티티.studio_accounts 는 스튜디오 시스템의 계정을 형상화한 엔티티이다. 계정은 고유\n식별자 코드를 가지는 하나의 주체 단위로써, 저장소\n등을 소유할 수 있다. 가령 깃허브에서 특정 저장소의 주소가\nhttps://github.com/samchon/typia 라면, 이 중 samchon 이 계정의\n식별자이자, typia 라는 저장소의 소유 주체인 것.그리고 여기서 말하는 계정이란, 그 주체가 반드시 사람을 지칭하지 않는다.\n계정주가 회원일 수도 있지만,\n기업일 수도 있기 때문이다. 예를 들어\nhttps://github.com/Microsoft/TypeScript 의 경우, 계정주가 사람이 아닌,\n기업인 마이크로소프트가 된다.이외에 계정은 그 소유주를 바꿀 수 있다. 그리고 소유주를 바꿀 때, 그 주체가\n개인에서 기업으로 변경되는 것 또한 가능하다. 예를 들어 개인으로 시작했던\n계정과 저장소가 흥행하여, 향후 기업으로 승격하는 경우가 그러하다.Properties\nid: Primary Key.\nhub_channel_id: 귀속 채널의 hub_channels.id\nhub_member_id: 계정주 회원의 hub_members.id ID.\nstudio_enterprise_id: 계정주 기업의 studio_enterprises.id ID.\ncode\n식별자 코드.서비스 상, URL 주소의 일부 경로에 해당하는 부분.\ncreated_at: 계정 생성 일시.\ndeleted_at: 레코드 삭제 일시.","studio_enterprises#studio_enterprises":"기업 엔티티.studio_enterprises 는 기업을 형상화한 엔티티로써, 문자 그대로 회사 단위로\n본 스튜디오 시스템에 참여하는 주체를 뜻한다. 그리고 기업의 경우는\n회원 때와 달리, 반드시 계정을\n소유하고 있어야 한다.또한 기업은 하위 엔티티로, 직원 및\n그들로 구성된 팀을 가진다. 그리고 이 중\n팀은 그 구성원들이 단체로 기업\n귀속 저장소의 동일한\n접근 권한을 가질 수 있다.Properties\nid: Primary Key.\nhub_channel_id: 귀속 채널의 hub_channels.id\nhub_customer_id: 기업을 생성한 고객의 hub_customers.id\nname: 기업명.\ncreated_at: 레코드 생성 일시.\nupdated_at: 레코드 편집 일시.\ndeleted_at: 레코드 삭제 일시.","studio_enterprise_employees#studio_enterprise_employees":"기업 내 직원 엔티티.studio_enterprise_employees 는 기업에 소속된 직원을 형상화한 엔티티이다.\n직원은 기업 내 각 팀에\n소속되어 활동하며, 팀 단위로 기업의\n저장소로부터 권한을\n부여받는다.참고로 직원은 오직, 본 스튜디오 시스템에 회원으로써 가입한\n사람만이 임명될 수 있으며,\n한 사람이 여러 회사에 동시에 직원으로 소속되는 것이 가능하다.Properties\nid: Primary Key.\nstudio_enterprise_id: 귀속 기업의 studio_enterprises.id\nhub_member_id: 대상 직원의 회원 hub_members.id\ntitle\n직책.\nowner: 기업의 소유자. 모든 권한을 가진다\nmanager: 기업의 매니저, 일반 구성원에 대한 권한을 가진다\nmember: 일반 구성원\nobserver: 관람자, 오직 읽기만 가능\ncreated_at: 직원 최초 초대 일시.\nupdated_at: 레코드 수정 일시.\napproved_at: 직원 초대 수락 일시.\ndeleted_at: 레코드 삭제 일시.","studio_enterprise_employee_appointments#studio_enterprise_employee_appointments":"직원 임명 정보.studio_enterprise_employee_appointments 는 기업 내\n직원의 임명 및 직책 변경 정보에 대한 이력을\n형상화한 엔티티이다.따라서 본 엔티티 레코드는 기업이 직원을 임명할 때 최초 1회 생성되며,\n이후로 직원의 직책을 변경할 때마다 누적된다.Properties\nid: Primary Key.\nstudio_enterprise_employee_id: 대상 직원의 studio_enterprise_employees.id\nhub_customer_id: 직원을 임명 또는 직책 변경한 고객의 hub_customers.id\ntitle: 부여한 직책.\ncreated_at: 레코드 생성 일시.","studio_enterprise_teams#studio_enterprise_teams":"기업 내 팀 정보.studio_enterprise_teams 는 기업 내 팀을 형상화한 엔티티이다.\n팀은 구성원으로써\n직원들을 거느리며, 팀 단위로 기업의\n저장소로부터 권한을\n부여받아 활동할 수 있다.Properties\nid: Primary Key.\nstudio_enterprise_id: 귀속 기업의 studio_enterprises.id\nhub_customer_id: 팀을 생성한 고객의 hub_customers.id\ncode\n팀의 식별자 코드.팀 페이지의 URL 주소상 경로의 일부분에 해당.\nname: 팀명.\ncreated_at: 레코드 생성 일시.\nupdated_at: 레코드 수정 일시.\ndeleted_at: 레코드 삭제 일시.","studio_enterprise_team_companions#studio_enterprise_team_companions":"기업 내 팀의 구성원 정보.studio_enterprise_team_companions 는 기업을 구성하는 각\n팀에, 어떤 직원들이\n구성원으로 참여하는 지를 형상화한 엔티티이다.참고로 직원은 팀에 구성원으로 참여하며, 모종의 역할을 부여받는데, 이는 그들의 고유\n직책과 상이할 수 있다. 또한 기업의 직원은, 동시에 여러 팀에 소속되는 것이 가능하다.\n이는 한 명의 회원이 여러 회사에 동시에 직원으로 임명되는게\n가능했던 것과 유사.Properties\nid: Primary Key.\nstudio_enterprise_team_id: 귀속 팀의 studio_enterprise_teams.id\nstudio_enterprise_employee_id: 대상 직원의 studio_enterprise_employees.id\nrole\n부여된 역할.\nchief: 팀장\nmanager: 매니저, 일반 구성원에 대한 권한을 가짐\nmember: 일반 구성원\nobserver: 관람자, 오직 읽기만 가능\ncreated_at: 레코드 생성 일시.\nupdated_at: 레코드 수정 일시.\ndeleted_at: 레코드 삭제 일시.","studio_enterprise_team_companion_appointments#studio_enterprise_team_companion_appointments":"기업 내 팀 구성원의 임명 정보.studio_enterprise_team_companion_appointments 는 기업 내\n팀 구성원의 임명 및 역할 변경 정보에 대한\n이력을 형상화한 엔티티이다.따라서 본 엔티티 레코드는 팀이 구성원을 임명할 때 최초로 생명되며, 이후로 구성원의\n역할을 변경할 때마다 누적된다.Properties\nid: Primary Key.\nstudio_enterprise_team_companion_id: 대상 팀 구성원의 studio_enterprise_team_companions.id\nhub_customer_id: 팀 구성원을 임명 또는 역할 변경한 고객의 hub_customers.id\nrole: 부여한 역할.\ncreated_at: 레코드 생성 일시."}},"/tech-specs/marketplace/examples":{"title":"Examples","data":{"connector-server#Connector Server":"","representative-product#Representative Product":"Representative product in the API marketplace.\nGithub Repository: https://github.com/wrtnio/connectors/\nSwagger UI: https://wrtnio.github.io/connectors/swagger/\nThe connector is an example project made by \"Wrtn Studio Pro\" team. It is a representative and default OpenAPI product in the marketplace. If a new customer has not purchased anything in the API marketplace, only the connector belonged API functions would be utilized in the \"Meta LLM (A.I. Chatbot)\".The connector has thousands of API functions interacting with significant services like Google, Github, Slack, and so on. The API functions are groupped by these service names as OpenAPI tags. You can see which API functions are provided in the connector server by visiting the Swagger UI. As you can see, every API functions and DTO types are fully documented with detailed descriptions. Such descriptions help the LLM function calling to select proper function to call and understand of it.Also, as this connector server has been disclosured in the Github repository as an open source project, you can learn how to make a well-structured OpenAPI based project. Even though the connector server has the \"AGPL 3.0\" license, so that you cannot use it for commercial purpose, the connector server's source codes and API/DTO definitions would be good reference to compose your OpenAPI product in the API marketplace.","pure-typescript-type#Pure TypeScript Type":"import { ApiProperty } from \"@nestjs/swagger\";\nimport {\n  ArrayNotEmpty,\n  Format,\n  IsArray,\n  IsObject,\n  IsOptional,\n  IsString,\n  Match,\n  MaxLength,\n  Type,\n  ValidateNested,\n} from \"class-validator\";\nexport class BbsArticle {\n  @ApiProperty({\n    format: \"uuid\",\n  })\n  @IsString()\n  id!: string;\n  // DUPLICATED SCHEMA DEFINITION\n  // - duplicated function call + property type\n  // - have to specify `isArray` and `nullable` props by yourself\n  @ApiProperty({\n    type: () => AttachmentFile,\n    nullable: true,\n    isArray: true,\n    description: \"List of attached files.\",\n  })\n  @Type(() => AttachmentFile)\n  @IsArray()\n  @IsOptional()\n  @IsObject({ each: true })\n  @ValidateNested({ each: true })\n  files!: AttachmentFile[] | null;\n  @ApiProperty({\n    type: \"string\",\n    nullable: true,\n    minLength: 5,\n    maxLength: 100,\n    description: \"Title of the article.\",\n  })\n  @IsOptional()\n  @IsString()\n  title!: string | null;\n  @ApiProperty({\n    description: \"Main content body of the article.\",\n  })\n  @IsString()\n  body!: string;\n  @ApiProperty({\n    format: \"date-time\",\n    description: \"Creation time of article\",\n  })\n  @IsString()\n  created_at!: string;\n}\nexport class AttachmentFile {\n  @ApiProperty({\n    type: \"string\",\n    maxLength: 255,\n    pattern: \"^[a-zA-Z0-9-_]+$\",\n    description: \"File name.\",\n  })\n  @Matches(/^[a-z0-9]+$/)\n  @MaxLength(255)\n  @IsString()\n  name!: string | null;\n  @ApiProperty({\n    type: \"string\",\n    nullable: true,\n    maxLength: 255,\n    pattern: \"^[a-zA-Z0-9-_]+$\",\n    description: \"File extension.\",\n  })\n  @Matches(/^[a-z0-9]+$/)\n  @MaxLength(8)\n  @IsOptional()\n  @IsString()\n  extension!: string | null;\n  @ApiProperty({\n    format: \"uri\",\n    description: \"URL of the file.\",\n  })\n  @Format(\"uri\")\n  @IsString()\n  url!: string;\n}\nimport { tags } from \"typia\";\nexport interface IBbsArticle {\n  /**\n   * Primary Key.\n   */\n  id: string & tags.Format<\"uuid\">;\n  /**\n   * List of attached files.\n   */\n  files: null | IAttachmentFile[];\n  /**\n   * Title of the article.\n   */\n  title: null | (string & tags.MinLength<5> & tags.MaxLength<100>);\n  /**\n   * Main content body of the article.\n   */\n  body: string;\n  /**\n   * Creation time of article.\n   */\n  created_at: string & tags.Format<\"date-time\">;\n}\nexport interface IAttachmentFile {\n  /**\n   * File name.\n   */\n  name: string & tags.Pattern<\"^[a-z0-9]+$\"> & tags.MaxLength<255>;\n  /**\n   * File extension.\n   */\n  extension: null | (string & tags.Pattern<\"^[a-z0-9]+$\"> & tags.MaxLength<8>);\n  /**\n   * URL of the file.\n   */\n  url: string & tags.Format<\"uri\">;\n}\nSafe and efficient OpenAPI generation by nestia.In the \"Wrtn Studio Pro\" application, every features start from the OpenAPI specification. API marketplace also trades the OpenAPI document specification. Therefore, exact and efficient OpenAPI generation is much important than anything other.By the way, the connector server is the representative OpenAPI product providing initial API functions for the newcomers. If there's an error on its OpenAPI document, it may lead to the unpexpected behavior from the LLM (Large Language Model) function calling, so that quality of the \"Wrtn Studio Pro\" would be downgraded just by such connector server's OpenAPI document level error. Otherwise there's no error on the OpenAPI document, but it is not efficient, the productivity of the \"Wrtn Studio Pro\" would be decreased.In such reason, \"Wrtn Studio Pro\" team had to find the best solution for OpenAPI document generation which can ensure both safety and efficiency. The solution is nestia developed by one of \"Wrtn Studio Pro\" developer, which does not require any extra dedication for the OpenAPI document generation. As you can see from the above code snippets, NestJS DTO definitions require triple duplicated schema definitions.One thing ridiculous is, NestJS has relatively few duplicate definitions or OpenAPI document elements that are handwritten by humans. Most other languages ​​or frameworks cannot get beyond the level of handwriting OpenAPIs, which are not only redundant but also not type-safe. So even if a human makes a mistake while writing an OpenAPI spec, it often passes without any compilation error. And the most fatal aspect of this human mistake is that there can be a gap between the actual specifications of the API function and the specifications in the document. LLM function calling may be properly configured with parameters according to the given OpenAPI document specifications, but the actual document specifications may be incorrect, causing LLM function call execution to fail.In contrary, nestia does not need anything to do for OpenAPI document generation. nestia just analyzes the NestJS source code in the compilation level, and builds the OpenAPI document just by that automatically. In such reason, it does not need any duplicated definition, and API functions are always 100% synchronized with the OpenAPI document without any error. Efficiency from no duplicated definition, and safety from compiler level documentation. This is the reason why the connector server project has been adopted nestia for OpenAPI document generation.","test-driven-development#Test Driven Development":"import {\n  ArrayUtil,\n  GaffComparator,\n  RandomGenerator,\n  TestValidator,\n} from \"@nestia/e2e\";\nimport api from \"@ORGANIZATION/PROJECT-api/lib/index\";\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/bbs/IBbsArticle\";\nimport { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/common/IPage\";\nexport async function test_api_bbs_article_index_sort(\n  connection: api.IConnection,\n): Promise<void> {\n  // GENERATE 100 ARTICLES\n  const section: string = \"general\";\n  await ArrayUtil.asyncRepeat(100)(() =>\n    api.functional.bbs.articles.create(connection, section, {\n      writer: RandomGenerator.name(),\n      title: RandomGenerator.paragraph(5)(),\n      body: RandomGenerator.content(8)()(),\n      format: \"txt\",\n      files: [],\n      password: RandomGenerator.alphabets(8),\n    }),\n  );\n  // PREPARE VALIDATOR\n  const validator = TestValidator.sort(\"BbsArticleProvider.index()\")(async (\n    sort: IPage.Sort<IBbsArticle.IRequest.SortableColumns>,\n  ) => {\n    const page: IPage<IBbsArticle.ISummary> =\n      await api.functional.bbs.articles.index(connection, section, {\n        limit: 100,\n        sort,\n      });\n    return page.data;\n  });\n  // DO VALIDATE\n  const components = [\n    validator(\"created_at\")(GaffComparator.dates((x) => x.created_at)),\n    validator(\"updated_at\")(GaffComparator.dates((x) => x.updated_at)),\n    validator(\"title\")(GaffComparator.strings((x) => x.title)),\n    validator(\"writer\")(GaffComparator.strings((x) => x.writer)),\n    validator(\n      \"writer\",\n      \"title\",\n    )(GaffComparator.strings((x) => [x.writer, x.title])),\n  ];\n  for (const comp of components) {\n    await comp(\"+\", false);\n    await comp(\"-\", false);\n  }\n}\nTest Driven Development with strict e2e testing functions.As connector server is the representative product in the \"API Marketplace\", its runtime safety is much important than any other features. To ensure the connector server's runtime safety, \"Wrtn Studio Pro\" team has adopted the TDD (Test Driven Development) with strict e2e testing functions.At first, we never develop the main program first. Our rule is to define the interfaces of DTOs and API functions first. And then, we still do not write the main logic code. We write the e2e test program before the main logic code implementation. The main program development starts after the interface definitions and e2e test programs are completed.Here is the detailed process of our TDD rule for the connector server project.","1-definition#1. Definition":"Before developing the main program, define it before.At first, design the DB architecture on the Prisma Schema file.Writing the schema definitions, don't forget to write the detailed descriptions on each tables and properties. After that, build ERD (Enterprise Relationship Diagram) document through npm run build:prisma command. The ERD document will be generated on the docs/ERD.md path. If you share the ERD document with your companions, your team can enjoy increased productivity by standardizing words and entities.At second, write DTO structures under the src/api/structures directory and declare API endpoint specs under the src/controllers directory. Note that, do not implement the function body of the controller. Just write declaration only. Below code is never pseudo code, but actual code for current step.\n@Controlleer(\"bbs/articles\")\nexport class BbsArticleController {\n  @TypedRoute.Patch()\n  public async index(\n    @TypedBody() input: IBbsArticle.IRequest\n  ): Promise<IPage<IBbsArticle.ISummary>> {\n    input;\n    return null!;\n  }\n}","2-software-development-kit#2. Software Development Kit":"@wrtnio/connectors provides SDK (Software Development Kit) for convenience.SDK library means a collection of fetch functions with proper types, automatically generated by nestia. As you can see from the above gif image, SDK library boosts up client developments, by providing type hints and auto completions.Furthermore, the SDK library supports Mockup Simulator.If client developer configures simulate option to be true, the SDK library will not send HTTP request to your backend server, but simulate the API endpoints by itself. With that feature, frontend developers can directly start the interaction development, even when the main program development has not started.\n# BUILD SDK IN LOCAL\nnpm run build:sdk\n# BUILD SDK AND PUBLISH IT TO THE NPM\nnpm run package:api\nFor reference, if you run npm run benchmark command, your test functions defined in the test/features/api directory would be utilized for performance benchmarking. If you want to see the performance bench result earlier, visit below link please:\ndocs/benchmarks/AMD Ryzen 9 7940HS w Radeon 780M Graphics.md","3-test-automation-program#3. Test Automation Program":"TDD (Test Driven Development)\nAfter the Definition and client SDK generation, you've to design the use-case scenarios and implement a test automation program who represents those use-case scenarios and guarantees the Main Program.To add a new test function in the Test Automation Program, create a new TS file under the test/features directory following the below category and implement the test scenario function with representative function name and export symbol.Note that, the Test Automation Program resets the local DB schema whenever being run. Therefore, you've to be careful if import data has been stored in the local DB server. To avoid the resetting the local DB, configure the reset option like below.Also, the Test Automation Program runs all of the test functions placed into the test/features directory. However, those full testing may consume too much time. Therefore, if you want to reduce the testing time by specializing some test functions, use the include option like below.\nsupported options\ninclude: test only restricted functions who is containing the special keyword.\nexclude: exclude some functions who is containing the special keyword.\nreset: do not reset the DB\n# test without db reset\nnpm run test -- --reset false\n# include or exclude some features\nnpm run test -- --include something\nnpm run test -- --include cart order issue\nnpm run test -- --include cart order issue --exclude index deposit\n# run performance benchmark program\nnpm run benchmark\nFor reference, if you run npm run benchmark command, your test functions defined in the test/features/api directory would be utilized for performance benchmarking. If you want to see the performance bench result earlier, visit below link please:\ndocs/benchmarks/AMD Ryzen 9 7940HS w Radeon 780M Graphics.md","4-main-program#4. Main Program":"After Definition, client SDK building and Test Automation Program are all prepared, finally you can develop the Main Program. Also, when you complete the Main Program implementation, it would better to validate the implementation through the pre-built SDK and Test Automation Program.However, do not commit a mistake that writing source codes only in the src/controllers classes. The API Controller must have a role that only intermediation. The main source code should be write down separately following the directory categorizing. For example, source code about DB I/O should be written into the src/providers directory."}},"/tech-specs/meta/websocket":{"title":"Websocket","data":{"concept#Concept":"WebSocket protocol with RPC paradigm for A.I. chatbot.\"Wrtn Studio Pro\" has developed A.I. chatbot application with WebSocket protocol. Also, in the WebSocket protocol, \"Meta LLM\" has adopted the RPC (Remote Procedure Call) paradigm. By the RPC paradigm, client appliation of \"Meta LLM\" can call the server application's functions remotely. Of course, the server application can remotely call the client functions too.The WebSocket RPC (Remote Procedure Call) module is composed with four components: Communicator, Header, Provider and Driver. The Communicator is a class that taking responsibility of network communication and Provider is a collection of functions that providing to the remote system. At last, Driver is the RPC driver which can remotely call the functions of the remote system's Provider.In our \"Meta LLM\" system, there are two provides; IStudioMetaChatService and IStudioMetaChatListener. IStudioMetaChatService is a type of provider from server to client, and IStudioMetaChatListener is a type of provider from client to server. Also, IStudioMetaChatListener is providing many LLM function call related functions, so that Meta LLM server accomplishes the function call execution by calling the functions of IStudioMetaChatListener remotely.\nReferences\nRemote Procedure Call\nFeatures > RPC Components\nLearn from Examples > Remote Function Call\nProviders\nIStudioMetaChatService\nIStudioMetaChatListener","rpc-components#RPC Components":"Components of the Remote Procedure Call (RPC) paradigm.\nCommunicator: network communication with remote system\nHeader: header value directly delivered after the connection\nProvider: object provided for remote system\nDriver: proxy instance for remotely function calling to Provider","communicator#Communicator":"Communicates with a remote system.Communicator is a class taking full responsibility to network communication with remote system. You can register a Provider, an object would be provided to the remote system, to the Communicator. Also, Driver<Remote>, which can access to the remote system's Provider, is created by this Communicator.In the WebSocket protocol, WebSocketConnector and WebAcceptor are the classes responsible for the network communication. Also, this RPC paradigm is used not only in n the Meta LLM side with WebSocket protocol, but also in the Workflow Studio side with worker protocol.Here is the list of every communicator classes following the RPC paradigm.\nProtocol\tClient\tServer\tWeb Socket\tWebSocketConnector\tWebSocketAcceptor\tDedicated Worker\tWorkerConnector\tWorkerServer\tShared Worker\tSharedWorkerConnector\tSharedWorkerAcceptor","header#Header":"import { Driver, WebSocketConnector } from \"tgrid\";\nimport { ICalcConfig } from \"./interfaces/ICalcConfig\";\nimport { ICalcEvent } from \"./interfaces/ICalcEvent\";\nimport { ICalcEventListener } from \"./interfaces/ICalcEventListener\";\nimport { ICompositeCalculator } from \"./interfaces/ICompositeCalculator\";\nexport const webSocketClientMain = async () => {\n  const stack: ICalcEvent[] = [];\n  const listener: ICalcEventListener = {\n    on: (evt: ICalcEvent) => stack.push(evt),\n  };\n  const connector: WebSocketConnector<\n    ICalcConfig,\n    ICalcEventListener,\n    ICompositeCalculator\n  > = new WebSocketConnector(\n    { precision: 2 }, // header\n    listener, // provider for remote server\n  );\n  await connector.connect(\"ws://127.0.0.1:37000/composite\");\n  const remote: Driver<ICompositeCalculator> = connector.getDriver();\n  console.log(\n    await driver.plus(10, 20), // returns 30\n    await driver.multiplies(3, 4), // returns 12\n    await driver.divides(5, 3), // returns 1.67\n    await driver.scientific.sqrt(2), // returns 1.41\n    await driver.statistics.mean(1, 3, 9), // returns 4.33\n  );\n  await connector.close();\n  console.log(stack);\n};\nimport { Driver, WebSocketServer } from \"tgrid\";\nimport { ICalcConfig } from \"./interfaces/ICalcConfig\";\nimport { ICalcEventListener } from \"./interfaces/ICalcEventListener\";\nimport { CompositeCalculator } from \"./providers/CompositeCalculator\";\nimport { ScientificCalculator } from \"./providers/ScientificCalculator\";\nimport { SimpleCalculator } from \"./providers/SimpleCalculator\";\nimport { StatisticsCalculator } from \"./providers/StatisticsCalculator\";\nexport const webSocketServerMain = async () => {\n  const server: WebSocketServer<\n    ICalcConfig,\n    | CompositeCalculator\n    | SimpleCalculator\n    | StatisticsCalculator\n    | ScientificCalculator,\n    ICalcEventListener\n  > = new WebSocketServer();\n  await server.open(37_000, async (acceptor) => {\n    // LIST UP PROPERTIES\n    const config: ICalcConfig = acceptor.header;\n    const listener: Driver<ICalcEventListener> = acceptor.getDriver();\n    // ACCEPT OR REJECT\n    if (acceptor.path === \"/composite\")\n      await acceptor.accept(new CompositeCalculator(config, listener));\n    else if (acceptor.path === \"/simple\")\n      await acceptor.accept(new SimpleCalculator(config, listener));\n    else if (acceptor.path === \"/statistics\")\n      await acceptor.accept(new StatisticsCalculator(config, listener));\n    else if (acceptor.path === \"/scientific\")\n      await acceptor.accept(new ScientificCalculator(config, listener));\n    else {\n      await acceptor.reject(1002, `WebSocket API endpoint not found.`);\n      return;\n    }\n    // PING REPEATEDLY TO KEEP CONNECTION\n    acceptor.ping(15_000);\n  });\n  return server;\n};\nimport { Driver, WorkerServer } from \"tgrid\";\nimport { ICalcConfig } from \"./interfaces/ICalcConfig\";\nimport { ICalcEventListener } from \"./interfaces/ICalcEventListener\";\nimport { CompositeCalculator } from \"./providers/CompositeCalculator\";\nconst main = async () => {\n  const server: WorkerServer<\n    ICalcConfig,\n    CompositeCalculator,\n    ICalcEventListener\n  > = new WorkerServer();\n  const header: ICalcConfig = await server.getHeader();\n  const listener: Driver<ICalcEventListener> = server.getDriver();\n  const provider: CompositeCalculator = new CompositeCalculator(\n    header,\n    listener,\n  );\n  await server.open(provider);\n};\nmain().catch((exp) => {\n  console.error(exp);\n  process.exit(-1);\n});\nHeader value delivered after the connection.Header is a value, delivered from client to server directly, after the connection.Server can get the Header value through acceptor's header property.\nWebSocketAcceptor.header\nSharedWorkerAcceptor.header\nWorkerServer.getHeader()","provider#Provider":"import { Driver, WebSocketServer } from \"tgrid\";\nimport { ICalcConfig } from \"./interfaces/ICalcConfig\";\nimport { ICalcEventListener } from \"./interfaces/ICalcEventListener\";\nimport { CompositeCalculator } from \"./providers/CompositeCalculator\";\nimport { ScientificCalculator } from \"./providers/ScientificCalculator\";\nimport { SimpleCalculator } from \"./providers/SimpleCalculator\";\nimport { StatisticsCalculator } from \"./providers/StatisticsCalculator\";\nexport const webSocketServerMain = async () => {\n  const server: WebSocketServer<\n    ICalcConfig,\n    | CompositeCalculator\n    | SimpleCalculator\n    | StatisticsCalculator\n    | ScientificCalculator,\n    ICalcEventListener\n  > = new WebSocketServer();\n  await server.open(37_000, async (acceptor) => {\n    // LIST UP PROPERTIES\n    const config: ICalcConfig = acceptor.header;\n    const listener: Driver<ICalcEventListener> = acceptor.getDriver();\n    // ACCEPT OR REJECT\n    if (acceptor.path === \"/composite\")\n      await acceptor.accept(new CompositeCalculator(config, listener));\n    else if (acceptor.path === \"/simple\")\n      await acceptor.accept(new SimpleCalculator(config, listener));\n    else if (acceptor.path === \"/statistics\")\n      await acceptor.accept(new StatisticsCalculator(config, listener));\n    else if (acceptor.path === \"/scientific\")\n      await acceptor.accept(new ScientificCalculator(config, listener));\n    else {\n      await acceptor.reject(1002, `WebSocket API endpoint not found.`);\n      return;\n    }\n    // PING REPEATEDLY TO KEEP CONNECTION\n    acceptor.ping(15_000);\n  });\n  return server;\n};\nObject provided for remote system.Provider is an object provided for the remote system.The remote system can call the Provider's functions through Driver<Remote>.","driver#Driver":"import { Driver, WebSocketConnector } from \"tgrid\";\nimport { ICalcConfig } from \"./interfaces/ICalcConfig\";\nimport { ICalcEvent } from \"./interfaces/ICalcEvent\";\nimport { ICalcEventListener } from \"./interfaces/ICalcEventListener\";\nimport { ICompositeCalculator } from \"./interfaces/ICompositeCalculator\";\nexport const webSocketClientMain = async () => {\n  const stack: ICalcEvent[] = [];\n  const listener: ICalcEventListener = {\n    on: (evt: ICalcEvent) => stack.push(evt),\n  };\n  const connector: WebSocketConnector<\n    ICalcConfig,\n    ICalcEventListener,\n    ICompositeCalculator\n  > = new WebSocketConnector(\n    { precision: 2 }, // header\n    listener, // provider for remote server\n  );\n  await connector.connect(\"ws://127.0.0.1:37000/composite\");\n  const remote: Driver<ICompositeCalculator> = connector.getDriver();\n  console.log(\n    await driver.plus(10, 20), // returns 30\n    await driver.multiplies(3, 4), // returns 12\n    await driver.divides(5, 3), // returns 1.67\n    await driver.scientific.sqrt(2), // returns 1.41\n    await driver.statistics.mean(1, 3, 9), // returns 4.33\n  );\n  await connector.close();\n  console.log(stack);\n};\n$ npm start\n30 12 1.67 1.41 4.33\n[\n  { type: 'plus', input: [ 10, 20 ], output: 30 },\n  { type: 'multiplies', input: [ 3, 4 ], output: 12 },\n  { type: 'divides', input: [ 5, 3 ], output: 1.67 },\n  { type: 'sqrt', input: [ 2 ], output: 1.41 },\n  { type: 'mean', input: [ 1, 3, 9 ], output: 4.33 }\n]\nDriver of RPC (Remote Procedure Call).Driver is a proxy instance designed to call functions of the remote system. It has a generic argument Remote which means the type of remote system's Provider, and you can remotely call the functions of the Provider asynchronously through the Drive<Remote> instance.When you call some function of remote Provider by the Driver<Listener> instance, it hooks the function call expression, and delivers the function name and arguments (parameter values) to the remote system through the Communicator. If the remote system suceeded to reply the result of the function call, Communicator resolves the promise of the function call expression with the result, so that makes Driver<Remote> working.Otherwise exception is thrown in the remote Provider function, Communicator deliveries the exception instance instead to the remote system, so that actual exception being thrown from the Driver<Remote> instance.\n💻 Playground Link","meta-llm-protocol#Meta LLM Protocol":"","istudiometachatservice#IStudioMetaChatService":"/**\n * Set of functions provided by the Meta LLM server to the client.\n * \n * `IStudioMetaChatService` is an interface that defines the set of functions\n * provided by the **server** to the Meta LLM (Large Language Model) client. The Meta \n * LLM client remotely calls the server's `IStudioMetaChatService` functions through \n * this interface with RPC (Remote Procedure Call) paradigm.\n * \n * Note that the client must call the {@link initialize} function immediately\n * after connecting to the Meta LLM server. If the client tries to skip the\n * {@link initialize} function call and directly call {@link talk}, the function\n * call will fail, so that exception would be thrown.\n */\nexport interface IStudioMetaChatService {\n  /**\n   * Publish/restore/initialize the chat session.\n   * \n   * The client must call this function once after connecting to the Meta LLM\n   * server to publish a new chat session or restore an existing session. If\n   * the client tries to skip the {@link initialize} function call and directly\n   * call {@link talk}, the function call will fail, so that exception would be\n   * thrown.\n   * \n   * Also, the returned session would be a new chat session if the client connected\n   * to the server via the new chat session API, and the existing session would be\n   * restored if the client connected to the server via the continue chat session\n   * API.\n   *\n   * - {@link HubApi.functional.studio.customers.meta.chat.sessions.start}\n   * - {@link HubApi.functional.studio.customers.meta.chat.sessions.restart}\n   */\n  initialize(): Promise<IStudioMetaChatSession>;\n  /**\n   * User talks to Meta LLM.\n   * \n   * A function called by the client to talk to the Meta LLM server.\n   * \n   * @param dialogue Dialogue information\n   */\n  talk(dialogue: IStudioMetaChatDialogue): Promise<void>;\n}\nProvider from server to client for chatting.\np\n\"Meta LLM\" server is providing an IStudioMetaChatService typed instane to the client.It provides only two functions: initialize() and talk(). At first, initialize() is a function that the client must call once after connecting to the Meta LLM server to publish a new chat session or restore an existing session. If the client tries to skip the initialize() function call and directly call talk(), the function call will fail, so that exception would be thrown.The other talk() is a function called by the client to talk to the Meta LLM server. When client talks to the Meta LLM server, LLM reads and analyzes the message, and do something proper behavior calling the remotely provided functions of IStudioMetaChatListener.","istudiometachatlistener#IStudioMetaChatListener":"/**\n * Set of functions provided by the Meta LLM client to the server.\n * \n * `IStudioMetaChatListener` is an interface that defines the set of functions\n * provided by the **client** to the Meta LLM (Large Language Model) server. The Meta \n * LLM server remotely calls the client's `IStudioMetaChatListener` functions through\n * this interface with RPC (Remote Procedure Call) paradigm.\n */\nexport interface IStudioMetaChatListener {\n  /**\n   * Meta LLM server talks to the user.\n   * \n   * A function called by the Meta LLM server to talk to the user.\n   *\n   * @param dialogue Dialogue information\n   */\n  talk(dialogue: IStudioMetaChatDialogue): Promise<void>;\n  /**\n   * Notify the client of the server's listenability.\n   * \n   * The Meta LLM server notifies the client whether it is possible to listen.\n   *  \n   * In other words, this function informs the client whether it can call\n   * {@link IStudioMetaChatService.talk} immediately or not.\n   * \n   * Note that when the client calls the server's RPC function\n   * {@link IStudioMetaChatService.talk}, the value `false` is passed to this\n   * function {@link IStudioMetaChatListener.listenable} immediately. On the\n   * other hand, the value `true` is passed to this function in various cases.\n   *\n   * @param status Listenability status\n   */\n  listenable(status: boolean): Promise<void>;\n  /**\n   * Explain the function call plan.\n   * \n   * The Meta LLM server explains the function call plan to the user.\n   * \n   * The function call plan provided includes a list of functions that LLM\n   * wants to execute in order, and a description of the entire plan and the\n   * purpose of each function call.\n   * \n   * The client can read this and decide whether to proceed with the LLM\n   * function call execution. If `true` is returned, the Meta LLM will call\n   * the functions according to the plan. Otherwise `false` be returned, the plan\n   * would be withdrawn.\n   * \n   * @param plan Function call plan\n   * @returns Whether to proceed with the plan or not\n   */\n  explainFunctionCall(plan: IStudioMetaChatFunctionCallPlan): Promise<boolean>;\n  /**\n   * Select a function to call.\n   * \n   * A function called by the Meta LLM server when LLM (Large Language Model) has\n   * determined the target function to call during the conversation with the user.\n   * \n   * After this function be called, the server will call the {@link fillArguments} \n   * functionns remotely to commpose parameter values, and then call the \n   * {@link completeFunction} function after the function call execution.\n   *\n   * @param props Information of the target function\n   */\n  selectFunction(props: IStudioMetaChatFunctionCall.ISelect): Promise<void>;\n  /**\n   * Fill in the argument of the function call.\n   * \n   * A function called by the Meta LLM server when the user needs to fill in \n   * some of the argument for the LLM function call. For example, when the user\n   * needs to enter an authentication key for a Google account, or upload a file\n   * manually.\n   * \n   * `IStudioMetaFunctionCall.arguments` is a function called when the user needs\n   * to compose some (or all) of the arguments to be used in the function call\n   * directly. The returned value means the value that the client has composed.\n   * \n   * The only cases where the client receives input separately from the server\n   * in our service are as follows:\n   *\n   * - {@link IOpenAiSchema.IString[\"x-wrtn-secret-key\"]}\n   * - {@link IOpenAiSchema.IString.contentMediaType}\n   *\n   * @param props Information of the target function and argument types\n   * @returns The value composed by the client, or rejection by hin/her\n   */\n  fillArgument(\n    props: IStudioMetaChatFunctionCall.IFillArgument,\n  ): Promise<IStudioMetaChatListener.IFillArgumentResult>;\n  /**\n   * Complete the function call.\n   * \n   * A function called by the Meta LLM server to inform the client of the \n   * completion of the LLM function call execution. \n   * \n   * It embodies the `Try<T, E>` structure, so that contains whether the function call \n   * was successful or not. Also, it contains the return value when suceeded, and the\n   * exception information when failed.\n   *\n   * @param props Information of the execution result\n   */\n  completeFunction(props: IStudioMetaChatFunctionCall.IComplete): Promise<void>;\n  /**\n   * Workflow has been prepared.\n   * \n   * A function called by the Meta LLM server when the workflow creation is ready.\n   * Client can decide whether to save the {@link IStudioWorkflow workflow document} \n   * based on the {@link IStudioWorkflowData.ICreate creation information} received \n   * from the server.\n   * \n   * If client returns a {@link IStudioMetaChatWorkflowConfirm} instance in this \n   * function, the server will create the workflow at the specified \n   * {@link IStudioRepository repository} location. Otherwise the client returns\n   * `null`, the server will not create the workflow.\n   *\n   * @param data Workflow creation information\n   * @param plan Workflow configuration plan including detailed descriptions\n   * @returns Whether to create the workflow document or not\n   */\n  prepareWorkflow(\n    data: IStudioWorkflowData.ICreate,\n    plan: IStudioMetaChatWorkflowPlan,\n  ): Promise<IStudioMetaChatWorkflowConfirm | null>;\n  /**\n   * Workflow has been created/updated.\n   * \n   * A function called by the Meta LLM server when an {@link IStudioWorkflow workflow}\n   * has been newly created or updated by the client had returned a non-null value from\n   * the {@link prepareWorkflow} function.\n   * \n   * Whether the server creates or updates the workflow depends on the return value of\n   * the {@link prepareWorkflow} function. If the client orders a new workflow document,\n   * it would be created by the server. Otherwise the client directed the existing\n   * workflow document, it would be updated.\n   * \n   * The provided parameter object is the detailed information of the workflow\n   * {@link IStudioWorkflow} and its location information with {@link IStudioRepository}, \n   * so that the client can check it and enter the workflow editor or provide \n   * a preview image.\n   *\n   * @param workflow Newly created or updated workflow\n   * @param related Account and repository information related to the workflow\n   */\n  completeWorkflow(\n    workflow: IStudioWorkflow,\n    related: Pick<IStudioMetaChatWorkflowConfirm, \"account\" | \"repository\">,\n  ): Promise<void>;\n  /**\n   * Meta LLM server requests the client to terminate.\n   * \n   * When the Meta LLM session suddenly died due to the bug from LLM \n   * (Large Language Model) like OpenAI, the server requests the client to terminate \n   * the connection, and retry it again a little bit later.\n   *\n   * @param error Error from the LLM module\n   */\n  kill(error?: any): Promise<void>;\n}\nProvider from client to server for chatting.\"Meta LLM\" client is providing an IStudioMetaChatListener typed instance to the server.It provides many listener methods for the server for interaction. At first, it providers talk() and listenable() methods. The talk() method is designed to listen what the LLM server is saying, and the listenable() method informs the client to whether the server is ready to listen client's talk or not. If server has delivered false value to the listenable() method, the client must not call the talk() method until the server delivers true value to the listenable() method.When user writes a chatting text, so that client remotely calls IStudioMetaChatService.talk() method, LLM (Large Language Model) analyzes the chatting text. Sometimes, the LLM predicates the chatting text indicates the LLM function call. In that case, LLM server starts the function call execution process by calling the explainFunctionCall() method remotely. In the process, server fills the LLM side parameters by user's chatting text, and fill Human side parameters by calling fillArgument() method.At last, if client request to create a reusable program function about the chatting by text input delivered by remotely calling IStudioMetaChatService.talk() method, LLM server composes the Workflow document with SWL language, and delivers it to the client by calling the prepareWorkflow() function remotely. If client returns the IStudioMetaChatWorkflowConfirm instance, LLM server actually creates the Workflow document at the specified repository location, and then delivers the created Workflow document to the completeWorkflow() method.","parameter-structures#Parameter Structures":"","dialogue#Dialogue":"/**\n * Conversion in the Meta LLM chat.\n * \n * `IStudioMetaChatDialogue` is a union type that represents the \n * conversation information occured in the Meta LLM (A.I. chatbot).\n * \n * Currently, only text conversation type exists, but in the future, it \n * may be possible to add voice, image, or composite types. It's because \n * OpenAI GPT-4o model has started supporting the voice input.\n */\nexport type IStudioMetaChatDialogue = IStudioMetaChatDialogue.IText;\nexport namespace IStudioMetaChatDialogue {\n  /**\n   * Text conversation information.\n   */\n  export interface IText {\n    /**\n     * Discriminator of union type.\n     */\n    kind: \"text\";\n    /**\n     * The text input by Human or LLM.\n     */\n    text: string;\n  }\n}\nChat dialogue information.When Human or LLM sends chatting text to the other, client or server remotely call the IStudioMetaChatListener.talk() or IStudioMetaChatService.talk() method, and their sole parameter type is IStudioMetaChatDialogue of above.","functioncallplan#FunctionCallPlan":"/**\n * Explanation of the function call plan.\n * \n * `IStudioMetaChatFunctionCallPlan` is an interface that describes the plan\n * of function calls in the Meta LLM chat session when the server explains the\n * plan to the client. \n * \n * It contains the list of functions to be called, the overall/development-level \n * description of the plan, and the description list for each function call.\n * \n * In the RPC (Remote Procedure Call) context, this structure \n * `IStudioMetaChatFunctionCallPlan` is used in the\n * {@link IStudioMetaChatListener.explainFunctionCall} method. After the method be\n * called, each function in the plan would be excuted by below sequence:\n * \n * 1. {@link IStudioMetaChatListener.selectFunction} to inform function metadata\n * 2. {@link IStudioMetaChatListener.fillArgument} per each argument of Human side\n * 3. {@link IStudioMetaChatListener.completeFunction} after function call execution\n */\nexport interface IStudioMetaChatFunctionCallPlan {\n  /**\n   * List of functions to call.\n   * \n   * Do not provide all metadata of the functions, but only identifier \n   * ({@link method} and {@link path}) of the function, and its {@link summary} and \n   * {@link descriptions}.\n   */\n  functions: IStudioMetaChatFunctionCallPlan.IFunction[];\n  /**\n   * General description of the entire plan.\n   */\n  general: string;\n  /**\n   * Individual description list for each function call.\n   */\n  steps: string[];\n}\nexport namespace IStudioMetaChatFunctionCallPlan {\n  export interface IFunction {\n    method: \"get\" | \"post\" | \"patch\" | \"put\" | \"delete\";\n    path: string;\n    summary?: string;\n    description?: string;\n    icon?: string & tags.Format<\"uri\">;\n  }\n}\nDescription of the function call plan.IStudioMetaChatFunctionCallPlan is an interface that describes the plan of function calls in the Meta LLM chat session when the server explains the plan to the client. It contains the list of functions to be called, the overall/development-level description of the plan, and the description list for each function call.In the RPC (Remote Procedure Call) context, this structure IStudioMetaChatFunctionCallPlan is used in the IStudioMetaChatListener.explainFunctionCall() method. After the method be called, each function in the plan would be excuted by below sequence:\nIStudioMetaChatListener.selectFunction() to inform function metadata\nIStudioMetaChatListener.fillArgument() per each argument of Human side\nIStudioMetaChatListener.completeFunction() after function call execution","functioncall#FunctionCall":"import { IOpenAiFunction, IOpenAiSchema } from \"@wrtnio/openai-function-schema\";\nimport { Primitive, tags } from \"typia\";\nimport { OmitNever } from \"typia/lib/typings/OmitNever\";\nexport namespace IStudioMetaChatFunctionCall {\n  /**\n   * Selection information of the function to call.\n   * \n   * `IStudioMetaChatFunctionCall.ISelect` is an interface that providing metadata\n   * of the target function to call when the Meta LLM server selects a proper function \n   * to call during the conversation with the user.\n   * \n   * In the context of RPC (Remote Procedure Call), this `IStudioMetaChatFunctionCall`\n   * structure is used in the {@link IStudioMetaChatListener.selectFunction} method.\n   * Also after delivering this information. the server will step below sequence:\n   * \n   * 1. {@link IStudioMetaChatListener.fillArgument} to compose Human side parameters\n   * 2. {@link IStudioMetaChatListener.completeFunction} after function call execution\n   */\n  export interface ISelect {\n    /**\n     * Primary Key.\n     */\n    id: string & tags.Format<\"uuid\">;\n    /**\n     * Metadata of the target function to call.\n     */\n    function: OmitNever<Primitive<IOpenAiFunction>>;\n  }\n  /**\n   * Request of arguments filling of Human side parameter.\n   * \n   * `IStudioMetaChatFunctionCall.IFillArgument` is an interface that providing\n   * the request to client for composing some of the arguments of the target\n   * function that must be filled by Human side, intead of LLM (Large Language Model).\n   * \n   * As a case of the values that must be filled by Human side, there are secret key\n   * and file upload. In the context of {@link IOpenAiSchema}, those typed values\n   * must be filled by Human:\n   * \n   * - {@link IOpenAiSchema.IString[\"x-wrtn-secret-key\"]}\n   * - {@link IOpenAiSchema.IString.contentMediaType}\n   */\n  export interface IFillArgument {\n    /**\n     * Identifier of the target function.\n     * \n     * It is same with the {@link IStudioMetaChatFunctionCall.ISelect.id}.\n     */\n    id: string & tags.Format<\"uuid\">;\n    /**\n     * Index of the parameter to fill.\n     */\n    index: number & tags.Type<\"uint32\">;\n    /**\n     * Schema information that must be composed by Human.\n     */\n    schema: IOpenAiSchema;\n    /**\n     * Metadata of the parameter that can be filled by LLM.\n     * \n     * If this value is `null`, it means that the parameter must be filled only by \n     * Human. Otherwise, LLM (Large Language Model) also can fill the parameter value\n     * by analyzing the client's conversation, and Meta LLM merges it with the \n     * Human composed.\n     */\n    llm: null | {\n      /**\n       * SChema information that can be filled by LLM.\n       */\n      schema: IOpenAiSchema;\n      /**\n       * Actual value filled by LLM.\n       */\n      value: any;\n    };\n  }\n  /**\n   * Result of the function call execution.\n   * \n   * `IStudioMetaChatFunctionCall.IComplete` is an interface that providing the\n   * result of the function call execution.\n   * \n   * In the RPC (Remote Procedure Call) context, this `IStudioMetaChatFunctionCall`\n   * structure is used in the {@link IStudioMetaChatListener.completeFunction} method.\n   */\n  export interface IComplete {\n    /**\n     * Primary Key.\n     * \n     * It is same with the {@link IStudioMetaChatFunctionCall.ISelect.id}.\n     */\n    id: string & tags.Format<\"uuid\">;\n    /**\n     * Arguments list used in the function call.\n     */\n    arguments: any[];\n    /**\n     * Whether the function call was successful or not.\n     */\n    success: boolean;\n    /**\n     * Returned value as a result of the function call.\n     * \n     * If the function call has been failed, this value would be exception instance \n     * thrown by the target function.\n     */\n    value: any;\n    /**\n     * Time of the function call start.\n     */\n    created_at: string & tags.Format<\"date-time\">;\n    /**\n     * Time of the function call completion.\n     * \n     * If this value is `null`, it means that the connection to the target function\n     * (API operation) itself has failed. On the other hand, if the connection has been\n     * succeeded but exception has been thrown during the function call, this time\n     * would be the time when the exception has been thrown.\n     */\n    completed_at: null | (string & tags.Format<\"date-time\">);\n    /**\n     * Status of the response.\n     * \n     * The HTTP protocol response status if the connection has been succeeded.\n     * Otherwise the connection has been failed, this value would be `null`.\n     */\n    status: number | null;\n  }\n}\nStructure for function call execution.After the Meta LLM server has explained the function call plan to the client by remotely calling the IStudioMetaChatListener.explainFunctionCall() method with IStudioMetaChatFunctionCallPlan typed parameter, the Meta LLM server steps the function call execution process by calling below methods.\nIStudioMetaChatListener.selectFunction() to inform function metadata\nIStudioMetaChatListener.fillArgument() per each argument of Human side\nIStudioMetaChatListener.completeFunction() after function call execution\nAt first, IStudioMetaChatFunctionCall.ISelect is an interface that providing metadata of the target function to call with IStudioMetaChatListener.selectFunction() method, when the Meta LLM server selects a proper function to call during the conversation with the user.At next, IStudioMetaChatFunctionCall.IFillArgument is an interface that providing the request to client for composing some of the arguments of the target function that must be filled by Human side, intead of LLM (Large Language Model), by IStudioMetaChatListener.selectFunction() method. As a case of the values that must be filled by Human side, there are secret key and file uploading.At last. IStudioMetaChatFunctionCall.IComplete is an interface that providing the result of the function call execution by IStudioMetaChatListener.completeFunction() method. It contains the argument values used for function call execution, and the result value from target function. If the function call has been failed, the result value would be exception instance thrown by the target function.","workflowplan#WorkflowPlan":"/**\n * Description of workflow composition plan.\n * \n * `IStudioMetaChatWorkflowPlan` is an interface that describes the plan of\n * the workflow composition in the Meta LLM chat session. The server explains\n * how to compose the workflow document in the general level, and also provides\n * the detailed description of each step.\n * \n * In the RPC (Remote Procedure Call) context, this structure \n * `IStudioMetaChatWorkflowPlan` is used in the \n * `IStudioMetaChatListener.prepareWorkflow` function, and the client determines\n * whether to actually build the workflow document or not based on this plan.\n */\nexport interface IStudioMetaChatWorkflowPlan {\n  /**\n   * General description of the entire plan.\n   */\n  general: string;\n  /**\n   * Detailed description list for each step.\n   */\n  steps: string[];\n  /**\n   * Title of the workflow.\n   */\n  title: string;\n  /**\n   * Summary of the workflow.\n   * \n   * This `summary` is different with the {@link general} description. The \n   * {@link general} description is the overall description of the entire plan,\n   * and this `summary` would be written in the workflow document when it compiled\n   * to a resuable program function.\n   * \n   * In other words, this `summary` would be assigned to \n   * {@link OpenApi.IOperation.summary} in the API level, and written on the \n   * programming comment in the source code level.\n   */\n  summary: string;\n  /**\n   * Description of the workflow.\n   * \n   * This `description` is different with the {@link general} description. The\n   * {@link general} description is the overall description of the entire plan,\n   * and this `description` would be written in the workflow document when it \n   * compiled to a resuable program function.\n   * \n   * In other words, this `description` would be assigned to \n   * {@link OpenApi.IOperation.description} in the API level, and written on the\n   * programming comment in the source code level.\n   */\n  description: string;\n}\nDescription of the workflow composition plan.When user requests to create a reusable program function from a chatting session, Meta LLM collects entire function call histories, and introduces the workflow composition plan before the actual workflow document creation. IStudioMetaChatWorkflowPlan is the interface providing the workflow composition plan with IStudoMetaCatListener.prepareWorkflow() method.In the IStudoMetaCatListener.prepareWorkflow() method, if client accepts the workflow composition plan and returns somewhere place to save the workflow document, the server actually creates the workflow document bypass SWL language, and delivers the created workflow document to the IStudioMetaChatListener.completeWorkflow() method.","workflowconfirm#WorkflowConfirm":"/**\n * Confirmation of the workflow creation.\n * \n * `IStudioMetaChatWorkflowConfirm` is an interface that accepting the \n * workflow creation with location to save the workflow document\n * including target {@link IStudioAccount account}, \n * {@link IStudioRepository repository}, {@link IStudioRepositoryCommit commit} \n * and {@link IStudioWorkflow.path path} information.\n * \n * In the RPC (Remote Procedure Call) context, this structure\n * `IStudioMetaChatWorkflowConfirm` is used in the \n * {@link IStudioMetaChatListener.prepareWorkflow} function, and the client\n * returns this typed instance acceptinng the workflow creation\n */\nexport interface IStudioMetaChatWorkflowConfirm {\n  /**\n   * Belonged account's {@link IStudioAccount.code}.\n   */\n  account: string;\n  /**\n   * Belonged repository's {@link IStudioRepository.code}.\n   */\n  repository: string;\n  /**\n   * Target commit.\n   * \n   * Create a new commit or update to an existing commit.\n   */\n  commit:\n    | IStudioMetaChatWorkflowConfirm.ICommitCreate\n    | IStudioMetaChatWorkflowConfirm.ICommitUpdate;\n  /**\n   * Workflow to create.\n   * \n   * Information of workflow where to save, including path and file name.\n   */\n  workflow: Omit<\n    IStudioWorkflow.ICreate,\n    \"data\" | \"title\" | \"summary\" | \"description\"\n  >;\n}\nexport namespace IStudioMetaChatWorkflowConfirm {\n  /**\n   * Create new commit.\n   */\n  export interface ICommitCreate\n    extends Omit<\n      IStudioRepositoryCommit.ICreate,\n      \"creates\" | \"updates\" | \"erases\"\n    > {\n    /**\n     * Discriminator of union type.\n     */\n    kind: \"create\";\n  }\n  /**\n   * Update to existing commit.\n   */\n  export interface ICommitUpdate\n    extends Omit<\n      IStudioRepositoryCommit.IUpdate,\n      \"creates\" | \"updates\" | \"erases\"\n    > {\n    /**\n     * Discriminator of union type.\n     */\n    kind: \"update\";\n    /**\n     * Target commit's {@link IStudioRepositoryCommit.id}.\n     */\n    commit_id: \"latest\" | (string & tags.Format<\"uuid\">);\n  }\n}\nConfirmation of workflow document creation.When Meta LLM server explains the workflow composition plan to the client by remotely calling IStudioMetaChatListener.prepareWorkflow() method, the client can decide whether to actually build the workflow document or not based on the plan. If client returns IStudioMetaChatWorkflowConfirm typed instance in the method, the server actually builds the workflow document through SWL language, and inform the completion by calling IStudioMetaChatListener.completeWorkflow() method.IStudioMetaChatWorkflowConfirm is such an interface that accepting the workflow creation. The IStudioMetaChatWorkflowConfirm contains somewhere location to save the workflow document including target account, repository, commit and file path.","function-call-execution#Function Call Execution":"/**\n * Set of functions provided by the Meta LLM server to the client.\n * \n * `IStudioMetaChatService` is an interface that defines the set of functions\n * provided by the **server** to the Meta LLM (Large Language Model) client. The Meta \n * LLM client remotely calls the server's `IStudioMetaChatService` functions through \n * this interface with RPC (Remote Procedure Call) paradigm.\n * \n * Note that the client must call the {@link initialize} function immediately\n * after connecting to the Meta LLM server. If the client tries to skip the\n * {@link initialize} function call and directly call {@link talk}, the function\n * call will fail, so that exception would be thrown.\n */\nexport interface IStudioMetaChatService {\n  /**\n   * Publish/restore/initialize the chat session.\n   * \n   * The client must call this function once after connecting to the Meta LLM\n   * server to publish a new chat session or restore an existing session. If\n   * the client tries to skip the {@link initialize} function call and directly\n   * call {@link talk}, the function call will fail, so that exception would be\n   * thrown.\n   * \n   * Also, the returned session would be a new chat session if the client connected\n   * to the server via the new chat session API, and the existing session would be\n   * restored if the client connected to the server via the continue chat session\n   * API.\n   *\n   * - {@link HubApi.functional.studio.customers.meta.chat.sessions.start}\n   * - {@link HubApi.functional.studio.customers.meta.chat.sessions.restart}\n   */\n  initialize(): Promise<IStudioMetaChatSession>;\n  /**\n   * User talks to Meta LLM.\n   * \n   * A function called by the client to talk to the Meta LLM server.\n   * \n   * @param dialogue Dialogue information\n   */\n  talk(dialogue: IStudioMetaChatDialogue): Promise<void>;\n}\n/**\n * Set of functions provided by the Meta LLM client to the server.\n * \n * `IStudioMetaChatListener` is an interface that defines the set of functions\n * provided by the **client** to the Meta LLM (Large Language Model) server. The Meta \n * LLM server remotely calls the client's `IStudioMetaChatListener` functions through\n * this interface with RPC (Remote Procedure Call) paradigm.\n */\nexport interface IStudioMetaChatListener {\n  /**\n   * Meta LLM server talks to the user.\n   * \n   * A function called by the Meta LLM server to talk to the user.\n   *\n   * @param dialogue Dialogue information\n   */\n  talk(dialogue: IStudioMetaChatDialogue): Promise<void>;\n  /**\n   * Notify the client of the server's listenability.\n   * \n   * The Meta LLM server notifies the client whether it is possible to listen.\n   *  \n   * In other words, this function informs the client whether it can call\n   * {@link IStudioMetaChatService.talk} immediately or not.\n   * \n   * Note that when the client calls the server's RPC function\n   * {@link IStudioMetaChatService.talk}, the value `false` is passed to this\n   * function {@link IStudioMetaChatListener.listenable} immediately. On the\n   * other hand, the value `true` is passed to this function in various cases.\n   *\n   * @param status Listenability status\n   */\n  listenable(status: boolean): Promise<void>;\n  /**\n   * Explain the function call plan.\n   * \n   * The Meta LLM server explains the function call plan to the user.\n   * \n   * The function call plan provided includes a list of functions that LLM\n   * wants to execute in order, and a description of the entire plan and the\n   * purpose of each function call.\n   * \n   * The client can read this and decide whether to proceed with the LLM\n   * function call execution. If `true` is returned, the Meta LLM will call\n   * the functions according to the plan. Otherwise `false` be returned, the plan\n   * would be withdrawn.\n   * \n   * @param plan Function call plan\n   * @returns Whether to proceed with the plan or not\n   */\n  explainFunctionCall(plan: IStudioMetaChatFunctionCallPlan): Promise<boolean>;\n  /**\n   * Select a function to call.\n   * \n   * A function called by the Meta LLM server when LLM (Large Language Model) has\n   * determined the target function to call during the conversation with the user.\n   * \n   * After this function be called, the server will call the {@link fillArguments} \n   * functionns remotely to commpose parameter values, and then call the \n   * {@link completeFunction} function after the function call execution.\n   *\n   * @param props Information of the target function\n   */\n  selectFunction(props: IStudioMetaChatFunctionCall.ISelect): Promise<void>;\n  /**\n   * Fill in the argument of the function call.\n   * \n   * A function called by the Meta LLM server when the user needs to fill in \n   * some of the argument for the LLM function call. For example, when the user\n   * needs to enter an authentication key for a Google account, or upload a file\n   * manually.\n   * \n   * `IStudioMetaFunctionCall.arguments` is a function called when the user needs\n   * to compose some (or all) of the arguments to be used in the function call\n   * directly. The returned value means the value that the client has composed.\n   * \n   * The only cases where the client receives input separately from the server\n   * in our service are as follows:\n   *\n   * - {@link IOpenAiSchema.IString[\"x-wrtn-secret-key\"]}\n   * - {@link IOpenAiSchema.IString.contentMediaType}\n   *\n   * @param props Information of the target function and argument types\n   * @returns The value composed by the client, or rejection by hin/her\n   */\n  fillArgument(\n    props: IStudioMetaChatFunctionCall.IFillArgument,\n  ): Promise<IStudioMetaChatListener.IFillArgumentResult>;\n  /**\n   * Complete the function call.\n   * \n   * A function called by the Meta LLM server to inform the client of the \n   * completion of the LLM function call execution. \n   * \n   * It embodies the `Try<T, E>` structure, so that contains whether the function call \n   * was successful or not. Also, it contains the return value when suceeded, and the\n   * exception information when failed.\n   *\n   * @param props Information of the execution result\n   */\n  completeFunction(props: IStudioMetaChatFunctionCall.IComplete): Promise<void>;\n  /**\n   * Workflow has been prepared.\n   * \n   * A function called by the Meta LLM server when the workflow creation is ready.\n   * Client can decide whether to save the {@link IStudioWorkflow workflow document} \n   * based on the {@link IStudioWorkflowData.ICreate creation information} received \n   * from the server.\n   * \n   * If client returns a {@link IStudioMetaChatWorkflowConfirm} instance in this \n   * function, the server will create the workflow at the specified \n   * {@link IStudioRepository repository} location. Otherwise the client returns\n   * `null`, the server will not create the workflow.\n   *\n   * @param data Workflow creation information\n   * @param plan Workflow configuration plan including detailed descriptions\n   * @returns Whether to create the workflow document or not\n   */\n  prepareWorkflow(\n    data: IStudioWorkflowData.ICreate,\n    plan: IStudioMetaChatWorkflowPlan,\n  ): Promise<IStudioMetaChatWorkflowConfirm | null>;\n  /**\n   * Workflow has been created/updated.\n   * \n   * A function called by the Meta LLM server when an {@link IStudioWorkflow workflow}\n   * has been newly created or updated by the client had returned a non-null value from\n   * the {@link prepareWorkflow} function.\n   * \n   * Whether the server creates or updates the workflow depends on the return value of\n   * the {@link prepareWorkflow} function. If the client orders a new workflow document,\n   * it would be created by the server. Otherwise the client directed the existing\n   * workflow document, it would be updated.\n   * \n   * The provided parameter object is the detailed information of the workflow\n   * {@link IStudioWorkflow} and its location information with {@link IStudioRepository}, \n   * so that the client can check it and enter the workflow editor or provide \n   * a preview image.\n   *\n   * @param workflow Newly created or updated workflow\n   * @param related Account and repository information related to the workflow\n   */\n  completeWorkflow(\n    workflow: IStudioWorkflow,\n    related: Pick<IStudioMetaChatWorkflowConfirm, \"account\" | \"repository\">,\n  ): Promise<void>;\n  /**\n   * Meta LLM server requests the client to terminate.\n   * \n   * When the Meta LLM session suddenly died due to the bug from LLM \n   * (Large Language Model) like OpenAI, the server requests the client to terminate \n   * the connection, and retry it again a little bit later.\n   *\n   * @param error Error from the LLM module\n   */\n  kill(error?: any): Promise<void>;\n}\nimport { IOpenAiFunction, IOpenAiSchema } from \"@wrtnio/openai-function-schema\";\nimport { Primitive, tags } from \"typia\";\nimport { OmitNever } from \"typia/lib/typings/OmitNever\";\nexport namespace IStudioMetaChatFunctionCall {\n  /**\n   * Selection information of the function to call.\n   * \n   * `IStudioMetaChatFunctionCall.ISelect` is an interface that providing metadata\n   * of the target function to call when the Meta LLM server selects a proper function \n   * to call during the conversation with the user.\n   * \n   * In the context of RPC (Remote Procedure Call), this `IStudioMetaChatFunctionCall`\n   * structure is used in the {@link IStudioMetaChatListener.selectFunction} method.\n   * Also after delivering this information. the server will step below sequence:\n   * \n   * 1. {@link IStudioMetaChatListener.fillArgument} to compose Human side parameters\n   * 2. {@link IStudioMetaChatListener.completeFunction} after function call execution\n   */\n  export interface ISelect {\n    /**\n     * Primary Key.\n     */\n    id: string & tags.Format<\"uuid\">;\n    /**\n     * Metadata of the target function to call.\n     */\n    function: OmitNever<Primitive<IOpenAiFunction>>;\n  }\n  /**\n   * Request of arguments filling of Human side parameter.\n   * \n   * `IStudioMetaChatFunctionCall.IFillArgument` is an interface that providing\n   * the request to client for composing some of the arguments of the target\n   * function that must be filled by Human side, intead of LLM (Large Language Model).\n   * \n   * As a case of the values that must be filled by Human side, there are secret key\n   * and file upload. In the context of {@link IOpenAiSchema}, those typed values\n   * must be filled by Human:\n   * \n   * - {@link IOpenAiSchema.IString[\"x-wrtn-secret-key\"]}\n   * - {@link IOpenAiSchema.IString.contentMediaType}\n   */\n  export interface IFillArgument {\n    /**\n     * Identifier of the target function.\n     * \n     * It is same with the {@link IStudioMetaChatFunctionCall.ISelect.id}.\n     */\n    id: string & tags.Format<\"uuid\">;\n    /**\n     * Index of the parameter to fill.\n     */\n    index: number & tags.Type<\"uint32\">;\n    /**\n     * Schema information that must be composed by Human.\n     */\n    schema: IOpenAiSchema;\n    /**\n     * Metadata of the parameter that can be filled by LLM.\n     * \n     * If this value is `null`, it means that the parameter must be filled only by \n     * Human. Otherwise, LLM (Large Language Model) also can fill the parameter value\n     * by analyzing the client's conversation, and Meta LLM merges it with the \n     * Human composed.\n     */\n    llm: null | {\n      /**\n       * SChema information that can be filled by LLM.\n       */\n      schema: IOpenAiSchema;\n      /**\n       * Actual value filled by LLM.\n       */\n      value: any;\n    };\n  }\n  /**\n   * Result of the function call execution.\n   * \n   * `IStudioMetaChatFunctionCall.IComplete` is an interface that providing the\n   * result of the function call execution.\n   * \n   * In the RPC (Remote Procedure Call) context, this `IStudioMetaChatFunctionCall`\n   * structure is used in the {@link IStudioMetaChatListener.completeFunction} method.\n   */\n  export interface IComplete {\n    /**\n     * Primary Key.\n     * \n     * It is same with the {@link IStudioMetaChatFunctionCall.ISelect.id}.\n     */\n    id: string & tags.Format<\"uuid\">;\n    /**\n     * Arguments list used in the function call.\n     */\n    arguments: any[];\n    /**\n     * Whether the function call was successful or not.\n     */\n    success: boolean;\n    /**\n     * Returned value as a result of the function call.\n     * \n     * If the function call has been failed, this value would be exception instance \n     * thrown by the target function.\n     */\n    value: any;\n    /**\n     * Time of the function call start.\n     */\n    created_at: string & tags.Format<\"date-time\">;\n    /**\n     * Time of the function call completion.\n     * \n     * If this value is `null`, it means that the connection to the target function\n     * (API operation) itself has failed. On the other hand, if the connection has been\n     * succeeded but exception has been thrown during the function call, this time\n     * would be the time when the exception has been thrown.\n     */\n    completed_at: null | (string & tags.Format<\"date-time\">);\n    /**\n     * Status of the response.\n     * \n     * The HTTP protocol response status if the connection has been succeeded.\n     * Otherwise the connection has been failed, this value would be `null`.\n     */\n    status: number | null;\n  }\n}\nLLM function call execution with RPC paradigm.Until now, we have learned principle of RPC (Remote Procedure Call), and how Meta LLM (A.I. chatbot) is utilizing the paradigm with detailed structures. Now, let's see how the LLM (Large Language Model) function call execution is being done with the RPC paradigm. Above sequence diagram would be helpful to understand the entire process.The Meta LLM starts by client's IStudioMetaChatService.initialize() remotely method calling, so that the chatting session be published (or restored). After that, the client may sends some conversation text to the server by calling IStudioMetaChatService.talk() method. This is the start of every function call execution step.When Meta LLM server listens the client's chatting text, it analyzes the text and predicts whether the conversation indicates a function call or not. If the conversation is suspicious to requesting some action, Meta LLM server finds proper functions to call. If suceeded to find some functions which can accomplish the user's request, Meta LLM makes a function call execution plan, and explains the plan to the client by calling IStudioMetaChatListener.explainFunctionCall() method. If client accepts the plan, so that returns tue value in the method, the Meta LLM server starts the function call execution process.For each functions to call, at first, Meta LLM server delivers the metadata information of the target function to call to the client by calling IStudioMetaChatListener.selectFunction() method. Also, Meta LLM server requests the client to fill parameter arguments. Such request and response would be done by chatting text through IStudioMetaChatService.talk() and IStudioMetaChatListener.talk() methods. Meta LLM analyzes user replied chatting text, and fill arguments of the target function by itself.By the way, some functions may have special arguments that only Human can compose. Secret key and file uploading cases would be such examples. In that case, Meta LLM requests client to fill the Human side arguments by calling IStudioMetaChatListener.fillArgument() method per each parameter argument. In the method, client manually composes the argument through Inspector component, and returns it. Meta LLM merges the Human composed argument with the LLM composed, and executes the function.After the function call execution, Meta LLM server informs the function call result by calling IStudioMetaChatListener.completeFunction() method. Parameter of the method (IStudioMetaChatFunctionCall.IComplete type) contains everything about the function call result, including whether to suceeded or not, and return value from the target function or thrown exception information. If the returned value is simple, Meta LLM server will describe the result as conversation text. Otherwise, client side Meta LLM application may provide a return value viewer to show the result."}},"/tech-specs/workflow/backend":{"title":"Backend","data":{"summary#Summary":"When you've succeded to complete the workflow document composing, or Meta LLM (A.I. Chatbot) has generated the workflow document by analyzing the LLM function call histories, the workflow document will be delivered to the compiler backend part of the workflow engine.The compiler backend of the workflow engine generates TypeScript code. And the typescript code is served by a Worker instance, and the main system of the \"Wrtn Studio Pro\" executes the compiled Worker instance with RPC (Remote Procedure Call) protocol.Also, you can enroll the compiled workflow programs to the API marketplace, so that it is possible to let Meta LLM (A.I. Chatbot) to perform LLM function calling to your workflow programs. It's because \"Wrtn Studio Pro\" provides the OpenAPI document from the workflow programs.\nWhat compiler backend is?The backend of a compiler plays a crucial role in transforming source code into machine code. A compiler typically consists of three main stages, and the backend is responsible for converting intermediate representations (IR) into final machine code. Here are the key functions and components of the backend:\nIntermediate Representation (IR):\nThe backend uses an intermediate representation generated from the analysis of the source code. IR serves as an abstract form between the source code and machine code, facilitating optimization and code generation.\nOptimization:\nThe backend applies various optimization techniques to enhance the performance of the code. This includes eliminating unnecessary code, loop optimizations, and register allocation optimizations. Optimization helps improve execution speed and reduce memory usage.\nCode Generation:\nBased on the optimized IR, the backend generates actual machine code. This process involves using the instruction set specific to the CPU architecture to write the final code. It includes tasks such as register allocation, instruction selection, and memory address calculation.\nTarget Architecture:\nThe backend generates code tailored to a specific hardware architecture. This can vary based on different CPU architectures (e.g., x86, ARM), requiring different implementations.\nError Handling:\nThe backend also includes functionality for handling errors that may occur during the code generation process. This encompasses issues like incorrect instruction usage or memory access errors.\nThe backend is a critical part of the compiler that significantly influences its performance and efficiency, requiring a deep understanding of various optimization techniques and architecture-specific details.","typescript-generator#TypeScript Generator":"Transform workflow document to TypeScript code.Compiler backend of the workflow engine generates TypeScript code by converting the workflow statements and their children expressions to the correspond TypeScript statements and expressions. By generating the TypeScript code from the workflow document, the workflow document actual can be an executable program in the JavaScript runtime with rollup bundling.Here is an example workflow document sending an email by using the Gmail connector, and its TypeScript code by the compilation (in the compiler backend side). As you can see, in generated TypeScript code composing the workflow program, the main function of the workflow program (Workflow.main()) is asserting the parameter types by typia.assert() function.And then, the Workflow.main() function is calling the connector APIf function, and asserting the result of the API function call too. About the connector API function, it is also generated by the compiler backend including its DTO (Data Transfer Object) types and metadata of the API operation.\nimport { IConnection } from '@nestia/fetcher';\nimport { PlainFetcher } from '@nestia/fetcher/lib/PlainFetcher';\nimport typia, { tags } from 'typia';\nimport { WorkerServer } from 'tgrid';\nimport { __StudioWorkflowDebugger } from './__StudioWorkflowDebugger';\nimport { __StudioWorkflowGlobal } from './__StudioWorkflowGlobal';\nimport { __StudioWorkflowUtil } from './__StudioWorkflowUtil';\nimport { IStudioWorkflowDebugger } from './IStudioWorkflowDebugger';\nexport namespace Workflow {\n  export async function main(\n    _param_0: string,\n    _param_1: string,\n    _param_2: string\n  ) {\n    typia.assert(_param_0);\n    typia.assert(_param_1);\n    typia.assert(_param_2);\n    const fetcher = __StudioWorkflowUtil.fetch({\n      retry: Number(__StudioWorkflowUtil.getEnvironment('FETCH_RETRY_COUNT')),\n      limit: Number(__StudioWorkflowUtil.getEnvironment('FETCH_LIMIT_COUNT')),\n      debug: true,\n    });\n    await fetcher({\n      statement_id: 'dbfc3a59-14b0-409b-a692-76f4be01e36b',\n      task: _namespace_swlmc_builtin.__swager_endpoint_post_connector_gmail_draft,\n      connection: {\n        host: 'https://studio-connector-poc.dev.wrtn.club',\n        options: {\n          referrer: __StudioWorkflowGlobal.referrer,\n        },\n      },\n      arguments: [\n        {\n          to: [_param_0],\n          subject: _param_1,\n          body: '<html><body>' + _param_2 + '</body></html>',\n          secretKey: 'your_secret_key_here',\n        },\n      ],\n    });\n    const : _namespace_swlmc_builtin.IGmail.ISendMailOutput =\n      await fetcher({\n        statement_id: 'e806c8da-44bb-47da-a311-3ec03b473b84',\n        task: _namespace_swlmc_builtin.__swager_endpoint_post_connector_gmail_send,\n        connection: {\n          host: 'https://studio-connector-poc.dev.wrtn.club',\n          options: {\n            referrer: __StudioWorkflowGlobal.referrer,\n          },\n        },\n        arguments: [\n          {\n            to: [_param_0],\n            subject: _param_1,\n            body: '<html><body>' + _param_2 + '</body></html>',\n            secretKey: await __StudioWorkflowDebugger.listener.sandbox(\n              'google'\n            ),\n          },\n        ],\n      });\n    typia.assert();\n  }\n}\nexport namespace _namespace_swlmc_builtin {\n  /**\n   * GMAIL 전송.\n   * \n   * 메일을 전송합니다.\n   *\n   * 지메일(gmail)은 Google에서 제공하는 무료 웹 기반 이메일 서비스입니다.\n   *\n   * 이 커넥터는 이메일 보내는 용도이며,\n   * 단순 텍스트로 보낼 경우에는 문장이 한 줄로 길게 보여지기 때문에 줄바꿈 문자를 넣어주셔야 합니다.\n   * 현재 형식은 content-type으로 `text/html; charset=utf-8`을 사용하고 있습니다.\n   * 경우에 따라 html 형식을 사용할 수도 있습니다.\n   *\n   * @param body 메일을 보내기 위해 필요한 정보.\n   * @path connector/gmail/send\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  export async function __swager_endpoint_post_connector_gmail_send(\n    connection: IConnection,\n    body: __swager_endpoint_post_connector_gmail_send.Input\n  ): Promise<__swager_endpoint_post_connector_gmail_send.Output> {\n    return PlainFetcher.fetch(\n      {\n        ...connection,\n        headers: {\n          ...connection.headers,\n          'Content-Type': 'application/json',\n        },\n      },\n      {\n        ...__swager_endpoint_post_connector_gmail_send.METADATA,\n        path: __swager_endpoint_post_connector_gmail_send.path(),\n        status: null,\n      },\n      body\n    );\n  }\n  export namespace __swager_endpoint_post_connector_gmail_send {\n    export type Input = _namespace_swlmc_builtin.IGmail.ICreateMailInput;\n    export type Output = _namespace_swlmc_builtin.IGmail.ISendMailOutput;\n    export const METADATA = {\n      method: 'POST',\n      path: '/connector/gmail/send',\n      request: {\n        type: 'application/json',\n        encrypted: false,\n      },\n      response: {\n        type: 'application/json',\n        encrypted: false,\n      },\n    } as const;\n    export const path = () => '/connector/gmail/send';\n  }\n}\nexport namespace _namespace_swlmc_builtin {\n  export namespace IGmail {\n    /**\n     * @title 메일 전송 결과\n     */\n    export type ISendMailOutput = {\n      /**\n       * 보낸 메일의 id.\n       *\n       * @title 보낸 메일의 id.\n       */\n      id: string;\n    };\n    /**\n     * @title 메일을 보내기 위해 필요한 정보\n     */\n    export type ICreateMailInput = {\n      /**\n       * 메일을 받는 사람의 이메일 주소.\n       *\n       * @title 받는 사람 이메일 주소.\n       */\n      to: string[];\n      /**\n       * 보낼 메일의 제목.\n       *\n       * @title 이메일 제목.\n       */\n      subject: string;\n      /**\n       * 보낼 메일의 본문.\n       *\n       * html로 작성해야 합니다. 그렇지 않으면 본문이 제대로 표시되지 않을 수 있습니다.\n       *\n       * gmail에서 적용가능한 css 형식을 적용해주세요.\n       *\n       * html 길이가 너무 길지 않게 작성해주세요. 길이가 너무 길면 전송이 되지 않을 수 있습니다.\n       *\n       * @title 이메일 본문.\n       */\n      body: string;\n      /**\n       * 참조할 사람 이메일 주소.\n       *\n       * @title 참조할 사람 이메일.\n       */\n      cc?: string[];\n      /**\n       * 숨은참조할 사람 이메일 주소.\n       *\n       * @title 숨은참조할 사람 이메일.\n       */\n      Bcc?: string[];\n      /**\n       * secret key.\n       *\n       * @title 인증 정보 선택\n       */\n      secretKey: string &\n        tags.JsonSchemaPlugin<{\n          'x-wrtn-secret-key': 'google';\n          'x-wrtn-secret-scopes': ['https://mail.google.com/'];\n        }>;\n    };\n  }\n}\nconst main = async () => {\n  const worker = new WorkerServer<typeof __StudioWorkflowGlobal, any, any>();\n  Object.assign(__StudioWorkflowGlobal, await worker.getHeader());\n  __StudioWorkflowDebugger.listener =\n    worker.getDriver<IStudioWorkflowDebugger.__IExecutionListener>();\n  await worker.open(Workflow);\n};\nmain();\n//--------------------------------------------------------------------\n// __StudioWorkflowDebugger.ts\n//--------------------------------------------------------------------\nimport { Driver } from \"tgrid\";\nimport { IStudioWorkflowDebugger } from \"./IStudioWorkflowDebugger\";\nexport const __StudioWorkflowDebugger = {\n  listener: null! as Driver<IStudioWorkflowDebugger.__IExecutionListener>,\n};\n//--------------------------------------------------------------------\n// __StudioWorkflowGlobal.ts\n//--------------------------------------------------------------------\nexport const __StudioWorkflowGlobal = {\n  environments: {} as Record<string, string>,\n  secrets: {} as Record<string, string[]>,\n  referrer: undefined as string | undefined,\n  metadata: {} as Record<string, any>,\n};\n//--------------------------------------------------------------------\n// __StudioWorkflowUtil.ts\n//--------------------------------------------------------------------\nimport { IConnection } from '@nestia/fetcher';\nimport { __StudioWorkflowDebugger } from './__StudioWorkflowDebugger';\nimport { __StudioWorkflowGlobal } from './__StudioWorkflowGlobal';\nexport namespace __StudioWorkflowUtil {\n  export const fetch = (config: {\n    retry: number;\n    limit: number;\n    debug: boolean;\n  }) => {\n    let count: number = 0;\n    return async <Arguments extends any[], Output>(props: {\n      statement_id: string;\n      task: (connection: IConnection, ...args: Arguments) => Promise<Output>;\n      connection: IConnection;\n      arguments: Arguments;\n    }): Promise<Output> => {\n      if (config.debug === true)\n        __StudioWorkflowDebugger.listener\n          .on({\n            statement_id: props.statement_id,\n            type: 'call-start',\n            arguments: props.arguments,\n            time: new Date().toISOString(),\n          })\n          .catch(() => {});\n      if (++count > config.limit)\n        throw new Error(`Reached to API function call limit: ${count}.`);\n      const execute = async () => {\n        const value: Output = await props.task(\n          props.connection,\n          ...props.arguments\n        );\n        if (config.debug === true)\n          __StudioWorkflowDebugger.listener\n            .on({\n              statement_id: props.statement_id,\n              type: 'call-complete',\n              value,\n              time: new Date().toISOString(),\n            })\n            .catch(() => {});\n        return value;\n      };\n      for (let i: number = 1; i < config.retry; ++i)\n        try {\n          return await execute();\n        } catch {\n          continue;\n        }\n      try {\n        return await execute();\n      } catch (exp) {\n        if (config.debug === true)\n          __StudioWorkflowDebugger.listener\n            .on({\n              statement_id: props.statement_id,\n              type: 'call-error',\n              error: exp,\n              time: new Date().toISOString(),\n            })\n            .catch(() => {});\n        throw exp;\n      }\n    };\n  };\n  export const getEnvironment = (key: string): string => {\n    const value: string | undefined = __StudioWorkflowGlobal.environments[key];\n    if (value === undefined)\n      throw new Error(\n        `Studio system has not confiured the environment variable: (key: ${JSON.stringify(\n          key\n        )}).`\n      );\n    return value;\n  };\n  export const getMetadata = (key: string): any =>\n    __StudioWorkflowGlobal.metadata[key];\n}\nimport { tags } from \"typia\";\n/**\n * Collection of workflow debugger interfaces.\n *\n * @author Samchon\n */\nexport namespace IStudioWorkflowDebugger {\n  /**\n   * 무언가를 실행한 결과값.\n   */\n  export type IResult<T> = ISuccess<T> | IFailure;\n  export interface ISuccess<T> {\n    success: true;\n    value: T;\n  }\n  export interface IFailure {\n    success: false;\n    error: any;\n  }\n  // @todo -> add breakpoint features on props and method as real-time\n  export interface IExecutor {\n    /**\n     * 워크플로우를 컴파일한다.\n     *\n     * 이미 컴파일한 경우, 다시 컴파일하지 않고, 그대로 반환한다.\n     */\n    compile(): Promise<IResult<undefined>>;\n    /**\n     * 워크플로우를 실행한다.\n     *\n     * 대상 {@link IStudioWorkflow 워크플로우} 함수를 디버깅 모드로 실행하며,\n     * 워크플로우의 진행 과정을 기 등록한 {@link IListener} 를 통하여 전달받는다.\n     *\n     * 참고로 {@link execute} 함수는 반복하여 재 실행할 수 있다. 다만, 기 실행한\n     * 워크플로우가 아직 진행 중인 상황에서는 그리할 수 없으며, 이 경우에는 에러가\n     * 발생한다. 따라서 기 실행한 워크플로우가 있거든, 그것이 끝날 때까지 기다리던가,\n     * 아니면 {@link terminate} 함수를 통하여 강제로 중단시키고 다시 실행해야 한다.\n     *\n     * @param props 함수 실행에 필요한 인자값들\n     * @returns 실행 결과값\n     */\n    execute(props: IExecutor.IProps): Promise<IResult<any>>;\n    /**\n     * 워크플로우 실행을 중단한다.\n     *\n     * 대상 {@link IStudioWorkflow 워크플로우}에 대한 {@link execute 실행}을 중단한다.\n     *\n     * 만일 기존에 실행한 워크플로우 함수가 이미 완료되었거나, 또는 이미 취소한 바\n     * 있다면, 이 함수는 에러를 발생시킨다.\n     *\n     * @returns 중단 결과값\n     */\n    terminate(): Promise<IResult<undefined>>;\n  }\n  export namespace IExecutor {\n    /**\n     * 워크플로우 실행에 필요한 인자값들.\n     */\n    export interface IProps {\n      /**\n       * 파라미터 값 리스트.\n       */\n      arguments: any[];\n    }\n  }\n  /**\n   * @internal\n   */\n  export interface __IExecutionListener extends IListener {\n    sandbox(key: string, index?: number): string;\n  }\n  /**\n   * 이벤트 수신기.\n   *\n   * {@link IExecutor.execute} 함수를 통하여 실행되는 워크플로우의 디버깅 과정을\n   * 수신하는 수신기 인터페이스.\n   *\n   * 프론트 엔드에서 이 인터페이스를 구현함으로써, 워크플로우 실행 과정을 실시간으로\n   * 확인할 수 있다.\n   */\n  export interface IListener {\n    /**\n     * 이벤트를 수신한다.\n     *\n     * @param event 이벤트 객체\n     */\n    on(event: IListener.IEvent): void;\n  }\n  export namespace IListener {\n    export type IEvent =\n      | IBranchEvent\n      | IBreakEvent\n      | ICallCompleteEvent\n      | ICallErrorEvent\n      | ICallStartEvent\n      | IContinueEvent\n      | IForEachCompleteEvent\n      | IForEachStepEvent\n      | IRepeatCompleteEvent\n      | IRepeatStepEvent\n      | IReturnEvent\n      | ISetEvent\n      | IWhileCompleteEvent\n      | IWhileStepEvent;\n    export interface IBranchEvent extends IEventBase<\"branch\"> {\n      condition: boolean;\n    }\n    export interface IBreakEvent extends IEventBase<\"break\"> {}\n    export interface ICallStartEvent extends IEventBase<\"call-start\"> {\n      arguments: unknown[];\n    }\n    export interface ICallCompleteEvent extends IEventBase<\"call-complete\"> {\n      value: any;\n    }\n    export interface ICallErrorEvent extends IEventBase<\"call-error\"> {\n      error: unknown;\n    }\n    export interface IContinueEvent extends IEventBase<\"continue\"> {}\n    export interface IForEachStepEvent extends IEventBase<\"for-each-step\"> {\n      i: number;\n      length: number | undefined;\n    }\n    export interface IForEachCompleteEvent\n      extends IEventBase<\"for-each-complete\"> {}\n    export interface IRepeatStepEvent extends IEventBase<\"repeat-step\"> {\n      i: number;\n      length: number;\n    }\n    export interface IRepeatCompleteEvent\n      extends IEventBase<\"repeat-complete\"> {}\n    export interface IReturnEvent extends IEventBase<\"return\"> {\n      value: unknown;\n    }\n    export interface ISetEvent extends IEventBase<\"set\"> {\n      value: unknown;\n    }\n    export interface IWhileStepEvent extends IEventBase<\"while-step\"> {\n      i: number;\n    }\n    export interface IWhileCompleteEvent extends IEventBase<\"while-complete\"> {}\n    interface IEventBase<Type extends string> {\n      type: Type;\n      statement_id: string;\n      time: string & tags.Format<\"date-time\">;\n    }\n  }\n}","workflow-executor#Workflow Executor":"RPC (Remote Procedure Call) in Worker.If you look at the example TypeScript code generated from the workflow document again, you may find that the workflow program is running on an Worker instance by creating the WorkerServer instance. Also, the WorkerServer is opening itself with the Workflow namespace for the client application (master application/thread).The Workflow instance would be provided to the master thread of the \"Wrtn Studio Pro\", and the master application/thread of the \"Wrtn Studio Pro\" will remotely call the Workflow.main() function through the RPC (Remote Procedure Call) protocol, just like WebSocket RPC did.For reference, the master application does not mean only backend system of the \"Wrtn Studio Pro\". The actual client/frontend application can be the master application too, so that the workflow program can be executed in the client application's runtime environment. The client application will open an Worker instance and remotely call the Workflow.main() function through the RPC (Remote Procedure Call) protocol.\nReferences\nRemote Procedure Call\nFeatures > RPC Components\nFeatures > Worker Protocol\nimport { IConnection } from '@nestia/fetcher';\nimport { PlainFetcher } from '@nestia/fetcher/lib/PlainFetcher';\nimport typia, { tags } from 'typia';\nimport { WorkerServer } from 'tgrid';\nimport { __StudioWorkflowDebugger } from './__StudioWorkflowDebugger';\nimport { __StudioWorkflowGlobal } from './__StudioWorkflowGlobal';\nimport { __StudioWorkflowUtil } from './__StudioWorkflowUtil';\nimport { IStudioWorkflowDebugger } from './IStudioWorkflowDebugger';\nnamespace Workflow {\n  export async function main(\n    _param_0: string,\n    _param_1: string,\n    _param_2: string\n  ): Promise<void>;\n}\nconst main = async () => {\n  const worker = new WorkerServer<typeof __StudioWorkflowGlobal, any, any>();\n  Object.assign(__StudioWorkflowGlobal, await worker.getHeader());\n  __StudioWorkflowDebugger.listener =\n    worker.getDriver<IStudioWorkflowDebugger.__IExecutionListener>();\n  await worker.open(Workflow);\n};","openapi-provider#OpenAPI Provider":"Workflow programs to OpenAPI document.You can register your workflow programs to the API marketplace which is following the OpenAPI specification. It's because \"Wrtn Studio Pro\" supports the OpenAPI document generation from the workflow programs, actually serving them through a RestAPI operation with specific URL (path) pattern.In means that, you can let Meta LLM (A.I. Chatbot) to perform LLM function calling to your workflow programs. The story is still valid even if you've registered workflow programs are borned from the Meta LLM with SWL language."}}}