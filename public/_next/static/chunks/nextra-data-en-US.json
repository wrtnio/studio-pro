{"/docs":{"title":"Index","data":{}},"/docs/introduction":{"title":"Introduction","data":{}},"/docs/marketplace/application":{"title":"Application","data":{}},"/docs/marketplace/community":{"title":"Community","data":{}},"/docs/marketplace/purchase":{"title":"Purchase","data":{}},"/docs/marketplace/concepts":{"title":"Concepts","data":{}},"/docs/marketplace/seller":{"title":"Seller","data":{}},"/docs/membership/account":{"title":"Account","data":{}},"/docs/membership/enterprise":{"title":"Enterprise","data":{}},"/docs/membership/join":{"title":"Join","data":{}},"/docs/membership/seller":{"title":"Seller","data":{}},"/docs/repository/bucket":{"title":"Bucket","data":{}},"/docs/repository/concepts":{"title":"Concepts","data":{}},"/docs/repository/release":{"title":"Release","data":{}},"/docs/repository/settings":{"title":"Settings","data":{}},"/docs/workflow/concepts":{"title":"Concepts","data":{}},"/docs/workflow/editor":{"title":"Editor","data":{}},"/docs/workflow/examples":{"title":"Examples","data":{}},"/tech-specs":{"title":"Index","data":{"":"\"Wrtn Studio Pro\" is a service providing an evolved Meta LLM (A.I. chatbot) than ever.\"Wrtn Studio Pro\" provides a Meta LLM (A.I. Chatbot) which can perform various function callings obtained from API marketplace sales of OpenAPI specification. Furthermore, \"Wrtn Studio Pro\" provides an Workflow Compiler (+SWL language) which automates the Meta LLM scenario to an re-usable and executable program function with visual diagrams.In here technical document, you can learn how the \"Wrtn Studio Pro\" has developed the Meta LLM (A.I. chatbot) and how it obtains the function calling schemas from the API marketplace. Also, you can learn how the user utternance and LLM function call histories are reborn as reusable programs through the workflow compiler.Let's see the \"Wrtn Studio Pro\" in the technical apsects.\nOpenAPI Specification\nMeta LLM (A.I. Chatbot)\nWorkflow Engine\nSWL Language\nAPI Marketplace"}},"/docs/workflow/execution":{"title":"Execution","data":{}},"/tech-specs/marketplace/application":{"title":"Application","data":{"new-era-of-ai-chatbot#New Era of A.I. Chatbot":"The days of creating full page applications that took a long time and effort are over. It's the age of A.I. Chatbot. When user inputs a conversation to an A.I. Chatbot, A.I. Chatbot will do everything.And if you come to our \"Wrtn Studio Pro\", you can create that A.I. Chatbot with just a few mouse clicks. Visit our API Marketplace, select the features you want, and click the \"Launch my A.I. App\" button. An A.I. Chatbot Application that can be ported immediately will be created.Through \"Application Creator\" of \"Wrtn Studio Pro\", you can turn your business into a product and launch it faster than anyone else. We will make your bright idea come true right now.","application-creator#Application Creator":"\"Application Creator\" is a service providing Meta LLM (A.I. Chatbot) as an embeddable application.When a customer purchases some OpenAPI goods from the \"API marketplace\" and publish them as a \"Application Creator\", the purchased OpenAPI operations would be utilized by the A.I. Chatbot's LLM (Large Language Model) function calling. It is the way to make a custom A.I. Chatbot with isolated sandbox environment.Also, the \"Application Creator\" is an embeddable application that can be ported to the user's website or application. Therefore, the \"Application Creator\" is the superfast way to make a custom A.I. Chatbot. Considering the fact that the A.I. Chatbot is the most popular and useful application in the current era, the \"Application Creator\" is the most valuable service in the \"Wrtn Studio Pro\" saving costs and times for business development.","pricing-model#Pricing Model":"When configuring the \"Application Creator\" and building up a \"custom A.I. Chatbot\", if there are some OpenAPI goods that is not free but commercial, the customer who've created the A.I. Chatbot must pay every fees occured in the \"custom A.I. Chatbot\" by the API calls.Considering aspects of the marketplace schema and pricing model of the \"API marketplace\", the fee structure will be determined based on the stock and price band selected by the customer when making the final purchase, and actual charges will be made based on the number of API calls made by LLM (Large Language Model) function calling in the A.I. chatbot.For reference, the custom A.I. chatbot applications created by \"Application Creator\" can be resold without licensing restrictions, so if the cost of purchased OpenAPI products is burdensome for you, consider a way to pass this on to end customers.\nNo\tFixed Cost\tVariable cost\t1\t$500 for 100 calls\t$10 per a call for the rest\t2\t$1,000 for 250 calls\t$5 per a call for the rest\t3\t$1,500 for 600 calls\t$2 per a call for the rest\t4\t$2,000 for 900 calls\t$1 per a call for the rest"}},"/tech-specs/marketplace/preface":{"title":"Preface","data":{"openapi-marketplace#OpenAPI Marketplace":"Marketplace of OpenAPI documents for Meta LLM.\"Wrtn Studio Pro\" operates an \"OpenAPI Marketplace\" to provide OpenAPI documents for the \"Meta LLM (A.I. Chatbot)\" from the market. Participants of the \"OpenAPI Marketplace\" can trade the OpenAPI document, so that customers can obtain functions to call by LLM (Large Language Model). And the providers can earn money by selling the OpenAPI documents.For reference, when seller uploads an OpenAPI document, \"Wrtn Studio Pro\" converts it to the OpenAPI v3.1 (emended) format. It is to unify the OpenAPI document to the latest version, and make the specification more concise by emendation. The emended OpenAPI v3.1 document would be utilized for LLM function calling bypass the migration process.","marketplace-schema#Marketplace Schema":"Descrition of the marketplace schema.Here is the summary of some entities written in the marketplace schema chapter.The schema of marketplace sale has defined SKU (Stock Keepting Unit) structured OpenAPI produces. It starts from the hub_sales (or hub_sale_snapshots) entity, and its final goal is to reaching to the target stock by configuring each candidate value for each option of each unit. After reaching to the target stock record, the customer may purchase the product with price model specification.When customer wants to buy a sale from the marketplace, he or she may specify the stocks from the sale and put them into the cart as a commodity. After that, customer can proceed the order from the prepared cart. When the cart is submitted as an order, its children commodities are changed to goods. When customer wants to complete the order as a formal contract, the order be published.","pricing-model#Pricing Model":"Step pricing model with fixed/variable const combinations.\"Wrtn Studio Pro\" has adopted step pricing model for the marketplace with fixed/variable cost combinations.It means that there are many fixed and variable combinated costs into a product (especially into a stock). For example, let's imagine that there is a stock that has 4 steps of pricing model as below. As you can see, if you pay $500 fixed cost, you can call 100 times of the API without any additional cost. However, if the number of API calls overs the 100, you should pay $10 per a call for the rest.Such stepping but fixed/variable separated pricing model is what \"Wrtn Stdio Pro\" has adopted. Also, the fixed and variable costs are inversely proportional. If a customer selects a higher fixed cost, the variable cost will be lower. Otherwise a customer selects a lower fixed cost, the variable cost would be higher. Of course, the quantity that can be used without additional charges is proportional to the fixed cost.\nNo\tFixed Cost\tVariable cost\t1\t$500 for 100 calls\t$10 per a call for the rest\t2\t$1,000 for 250 calls\t$5 per a call for the rest\t3\t$1,500 for 600 calls\t$2 per a call for the rest\t4\t$2,000 for 900 calls\t$1 per a call for the rest","application-creator#Application Creator":"Make A.I. Chatbot superfast from the API marketplace.\"Wrtn Studio Pro\" provides an Application Creator, which can make a custom A.I. Chatbot performing the LLM function calling that is obtained by the API Marketplace. The A.I. Chatbot can be embedded to the user's website or application, so that it is the superfast way to make an A.I. Chatbot.This is the agenda of the \"Application Creator\":\nThe days of creating full page applications that took a long time and effort are over. It's the age of A.I. Chatbot. When user inputs a conversation to an A.I. Chatbot, A.I. Chatbot will do everything.And if you come to our \"Wrtn Studio Pro\", you can create that A.I. Chatbot with just a few mouse clicks. Visit our API Marketplace, select the features you want, and click the \"Launch my A.I. App\" button. An A.I. Chatbot Application that can be ported immediately will be created.Through \"Application Creator\" of \"Wrtn Studio Pro\", you can turn your business into a product and launch it faster than anyone else. We will make your bright idea come true right now.","example-projects#Example Projects":"\"Wrtn Studio Pro\" provides some example OpenAPI projects/products.The connector is an example project made by \"Wrtn Studio Pro\" team. It is a representative and default OpenAPI product in the marketplace. If a new customer has not purchased anything in the API marketplace, only the connector belonged API functions would be utilized in the \"Meta LLM (A.I. Chatbot)\".Also, the connector is a good example to learn how to make a well-structured OpenAPI based project disclosured in the Github repository with open source license. The connector has been  developed with NestJS framework, and its Restful API functions are always 100% synchronized with the OpenAPI document without any type error.\nGithub Repository: https://github.com/wrtnio/connectors\nSwagger UI: https://wrtnio.github.io/connectors/swagger/"}},"/tech-specs/marketplace/price":{"title":"Price","data":{"step-pricing-model#Step Pricing Model":"Step pricing model with fixed/variable const combinations.\"Wrtn Studio Pro\" has adopted step pricing model for the marketplace with fixed/variable cost combinations.It means that there are many fixed and variable combinated costs into a product (especially into a stock). For example, let's imagine that there is a stock that has 4 steps of pricing model as below. As you can see, if you pay $500 fixed cost, you can call 100 times of the API without any additional cost. However, if the number of API calls overs the 100, you should pay $10 per a call for the rest.Such stepping but fixed/variable separated pricing model is what \"Wrtn Stdio Pro\" has adopted. Also, the fixed and variable costs are inversely proportional. If a customer selects a higher fixed cost, the variable cost will be lower. Otherwise a customer selects a lower fixed cost, the variable cost would be higher. Of course, the quantity that can be used without additional charges is proportional to the fixed cost.\nNo\tFixed Cost\tVariable cost\t1\t$500 for 100 calls\t$10 per a call for the rest\t2\t$1,000 for 250 calls\t$5 per a call for the rest\t3\t$1,500 for 600 calls\t$2 per a call for the rest\t4\t$2,000 for 900 calls\t$1 per a call for the rest","price-on-the-stock#Price on the Stock":"The stepping pricing model is defined in the stock level.Do you remember? \"API Marketplace\" supports the SKU (Stock Keeping Unit) concept, so that the final good to purchase by the customer is the stock. Here is the concept of the stock in the \"API Marketplace\". If you have not read the previous Marketplace Schema chapter or have forgotten it, read the below summarized paragraph.\nAs you can see, the schema of the marketplace starts from the Marketplace Schema > Sales section. In the Marketplace Schema > Sales section, it has defined SKU (Stock Keeping Unit) structured OpenAPI products. It starts from the hub_sales (or hub_sale_snapshots) entity, and its final goal is to reaching to the target stock by configuring each candidate value for each option of each unit. After reaching to the target stock record, the customer may purchase the product with price model specification.\nAlso, the stepping pricing model is defined in the stock level. It means that a sale unit can have multiple stepping pricing models per each stock. Each stock can have different pricing models, even though they are in the same sale unit with the same OpenAPI document.The represenative example case of multiple stocks in a sale unit (in a same OpenAPI document) is the different device environments. Let's imagine that there is a sale unit that has (CPU, GPU, RAM) options like below. Every customeres who has purchased the sale unit may have the same API specification, but the price of the API call must be different according to the device environments.High-end stock buyers pay more, that's the pricing model of the \"API Marketplace\".\nCPU: (i5, i7, i9)\nGPU: (GTX 2050, GTX 3060, GTX 4070)\nRAM: (8GB, 16GB, 32GB)","predication#Predication":"Only 2xx status codes are valid and will be payed.When a seller uploads an OpenAPI product, and customer buys it and calls the API, the marketplace proxy server intermediates the request and response between the client and the server. In the intermediation process, the proxy server checks the status code of the response.If the status code is not 2xx, the proxy server will not count the API call and will not charge from the customer. Only the 2xx status code responses are valid and will be payed. By the way, do not abuse the 2xx status code. If a seller abuses the 2xx status code even when the actual error case, the seller will be punished by the marketplace."}},"/tech-specs/meta/execution":{"title":"Execution","data":{"summary#Summary":"Summarize LLM function call execution principles.In this technical documents, the concept of LLM (Large Language Model) funtion call execution is the most important part. Therefore, even though the LLM function call execution concept has been explained detaily in the previous chapters, it would be better to summarize again for the readers who want to understand the concept at a glance.\nConvert to specific and emended OpenAPI specification\nNormalize the OpenAPI specification to the migration schema\nTransform migration schema to the LLM function schema\nPerform the function call execution through WebSocket RPC communication\nLLM Function CallingLLM selects proper function and fill arguments.In nowadays, most LLM (Large Language Model) like OpenAI are supporting \"function calling\" feature. The \"function calling\" means that LLM automatically selects a proper function and compose parameter values from the user's chatting text.https://platform.openai.com/docs/guides/function-calling","openapi-emension#OpenAPI Emension":"Convert to a specific and emended OpenAPI version.To accomplish the LLM (Large Language Model) function call execution mission, \"Wrtn Studio Pro\" starts from converting the OpenAPI document to a specific version (v3.1) with emension for clarity and consistency.The reason of conversion is, there're many versions in the OpenAPI document specification, and there're too many synonym expression ways even in the same version. By unifying a specific version and emending every synonym types, \"Wrtn Studio Pro\" acquires consistent API structures, so that get a change to compose the LLM function schema easier and safer than any others.Also, as \"Wrtn Studio Pro\" operates API Marketplace to supply API operations (functions to call by LLM) to the Meta LLM (A.I. Chatbot), such standardization is essential to provide a stable and reliable service.\nOpenAPI v3.1 emended\nOpenAPI v3.1\nOpenAPI v3.0\nSwagger v2.0","migration-process#Migration Process":"Before converting OpenAPI operations to LLM function calling schemas, \"Wrtn Studio Pro\" transforms the OpenAPI operations to an intermediate structure. The intermediate structure is called migration schema, and normalizes parameters/reponses of the OpenAPI opertion.In other words, the migration schema is called to a helper schema for RPC (Remote Procedure Call) function conversion from OpenAPI operation. By providing noramlized definitions close to the RPC function, \"Wrtn Studio Pro\" can easily convert to the LLM function calling schema from the OpenAPI document.For example, migration schema forces path parameters to have their own names, and combines query/headers to be a single object. Also, separates the response body to success and exceptional cases, and provides a description comment for the RPC function.\nIMigrateDocument\nIMigrateRoute","llm-function-schema#LLM Function Schema":"/**\r\n * Document of OpenAI function call metadata.\r\n *\r\n * `IOpenAiDocument` is a data structure representing content of\r\n * {@link IOpenAiDocument.functions OpenAI function call metadata}, composed by\r\n * {@link OpenAiComposer} from the {@link ISwagger} document, with\r\n * {@link IOpenAiDocument.errors} and adjusted {@link IOpenAiDocument.options}.\r\n *\r\n * The different between `IOpenAiDocument` and its origin source {@link ISwagger}\r\n * is, `IOpenAiDocument` has converted every {@link ISwaggerOperation API endpoints}\r\n * to {@link IOpenAiFunction function metadata}. You can execute the function call\r\n * with OpenAI constructed arguments by using the {@link OpenAiFetcher.execute}\r\n * function with the function metadata.\r\n *\r\n * Also, every type schema informations are casted from {@link ISwaggerSchema} to\r\n * {@link IOpenAiSchema} to escape {@link ISwaggerSchema.IReference reference types},\r\n * and downgrade the version of the JSON schema to OpenAPI 3.0. It's because\r\n * OpenAI function call feature cannot understand both reference types and\r\n * OpenAPI 3.1 specification.\r\n *\r\n * Additionally, if you've composed `IOpenAiDocument` with\r\n * {@link IOpenAiDocument.IOptions.keyword} configuration (as `true`), number of\r\n * {@link IOpenAiFunction.parameters} are always 1 and the first parameter's type is\r\n * always {@link IOpenAiSchema.IObject}. The properties' rule is:\r\n *\r\n * - `pathParameters`: Path parameters of {@link ISwaggerMigrateRoute.parameters}\r\n * - `query`: Query parameter of {@link ISwaggerMigrateRoute.query}\r\n * - `body`: Body parameter of {@link ISwaggerMigrateRoute.body}\r\n *\r\n * ```typescript\r\n * {\r\n *   ...pathParameters,\r\n *   query,\r\n *   body,\r\n * }\r\n * ```\r\n *\r\n * Otherwise, the parameters would be multiple, and the sequence of the parameters\r\n * are following below rules:\r\n *\r\n * ```typescript\r\n * [\r\n *   ...pathParameters,\r\n *   ...(query ? [query] : []),\r\n *   ...(body ? [body] : []),\r\n * ]\r\n * ```\r\n */\r\nexport interface IOpenAiDocument {\r\n  /**\r\n   * Version of OpenAPI.\r\n   *\r\n   * OpenAI function call schemas are based on OpenAPI 3.0.3.\r\n   */\r\n  openapi: \"3.0.3\";\r\n\r\n  /**\r\n   * List of function metadata.\r\n   *\r\n   * List of function metadata that can be used for the OpenAI function call.\r\n   *\r\n   * When you want to execute the function with OpenAI constructed arguments,\r\n   * you can do it through {@link OpenAiFetcher.execute} function.\r\n   */\r\n  functions: IOpenAiFunction[];\r\n\r\n  /**\r\n   * List of errors occurred during the composition.\r\n   */\r\n  errors: IOpenAiDocument.IError[];\r\n\r\n  /**\r\n   * Options for the document.\r\n   *\r\n   * Adjusted options when composing the document through {@link OpenAiComposer}.\r\n   */\r\n  options: IOpenAiDocument.IOptions;\r\n}\r\nexport namespace IOpenAiDocument {\r\n  /**\r\n   * Error occurred in the composition.\r\n   */\r\n  export interface IError {\r\n    /**\r\n     * HTTP method of the endpoint.\r\n     */\r\n    method: \"get\" | \"post\" | \"put\" | \"patch\" | \"delete\" | \"head\";\r\n\r\n    /**\r\n     * Path of the endpoint.\r\n     */\r\n    path: string;\r\n\r\n    /**\r\n     * Error messsages.\r\n     */\r\n    messages: string[];\r\n\r\n    /**\r\n     * Get the Swagger operation metadata.\r\n     *\r\n     * Get the Swagger operation metadata, of the source.\r\n     */\r\n    operation: () => ISwaggerOperation;\r\n\r\n    /**\r\n     * Get the migration route metadata.\r\n     *\r\n     * Get the migration route metadata, of the source.\r\n     *\r\n     * If the property returns `undefined`, it means that the error has been\r\n     * occured in the migration level, not of OpenAI document composition.\r\n     *\r\n     * @returns Migration route metadata.\r\n     */\r\n    route: () => ISwaggerMigrateRoute | undefined;\r\n  }\r\n\r\n  /**\r\n   * Options for composing the OpenAI document.\r\n   */\r\n  export interface IOptions {\r\n    /**\r\n     * Whether the parameters are keyworded or not.\r\n     *\r\n     * If this property value is `true`, length of the\r\n     * {@link IOpenAiDocument.IFunction.parameters} is always 1, and type of the\r\n     * pararameter is always {@link IOpenAiSchema.IObject} type. Also, its\r\n     * properties are following below rules:\r\n     *\r\n     * - `pathParameters`: Path parameters of {@link ISwaggerMigrateRoute.parameters}\r\n     * - `query`: Query parameter of {@link ISwaggerMigrateRoute.query}\r\n     * - `body`: Body parameter of {@link ISwaggerMigrateRoute.body}\r\n     *\r\n     * ```typescript\r\n     * {\r\n     *   ...pathParameters,\r\n     *   query,\r\n     *   body,\r\n     * }\r\n     * ```\r\n     *\r\n     * Otherwise (this property value is `false`), length of the\r\n     * {@link IOpenAiDocument.IFunction.parameters} is variable, and sequence of the\r\n     * parameters are following below rules.\r\n     *\r\n     * ```typescript\r\n     * [\r\n     *   ...pathParameters,\r\n     *   ...(query ? [query] : []),\r\n     *   ...(body ? [body] : []),\r\n     * ]\r\n     * ```\r\n     *\r\n     * @default false\r\n     */\r\n    keyword: boolean;\r\n\r\n    /**\r\n     * Separator function for the parameters.\r\n     *\r\n     * When composing parameter arguments through OpenAI function call,\r\n     * there can be a case that some parameters must be composed by human, or\r\n     * LLM cannot understand the parameter. For example, if the parameter type\r\n     * has configured {@link IOpenAiSchema.IString[\"x-wrtn-secret-key\"]}, the\r\n     * secret key value must be composed by human, not by LLM (Large Language Model).\r\n     *\r\n     * In that case, if you configure this property with a function that\r\n     * predicating whether the schema value must be composed by human or not,\r\n     * the parameters would be separated into two parts.\r\n     *\r\n     * - {@link IOpenAiFunction.separated.llm}\r\n     * - {@link IOpenAiFunction.separated.human}\r\n     *\r\n     * When writing the function, note that returning value `true` means to be\r\n     * a human composing the value, and `false` means to LLM composing the value.\r\n     * Also, when predicating the schema, it would better to utilize the\r\n     * {@link OpenAiTypeChecker} features.\r\n     *\r\n     * @param schema Schema to be separated.\r\n     * @returns Whether the schema value must be composed by human or not.\r\n     * @default null\r\n     */\r\n    separate: null | ((schema: IOpenAiSchema) => boolean);\r\n  }\r\n}\n/**\r\n * OpenAI function metadata.\r\n *\r\n * `IOpenAiFunction` is a data structure representing a function,\r\n * which is provided by Restful API, and used for the OpenAI function call.\r\n *\r\n * If you provide this `IOpenAiFunction` instance to the OpenAI, the OpenAI\r\n * will construct arguments by conversating with the user. Also, you can\r\n * execute the function call with the OpenAI constructed arguments by using\r\n * {@link OpenAiFetcher.execute}.\r\n *\r\n * For reference, different between `IOpenAiFunction` and its origin source\r\n * {@link ISwaggerOperation} is, `IOpenAiFunction` has converted every type schema\r\n * informations from {@link ISwaggerSchema} to {@link IOpenAiSchema} to escape\r\n * {@link ISwaggerSchema.IReference reference types}, and downgrade the version of\r\n * the JSON schema to OpenAPI 3.0. It's because OpenAI function call feature cannot\r\n * understand both reference types and OpenAPI 3.1 specification.\r\n *\r\n * Additionally, if you've composed `IOpenAiFunction` with\r\n * {@link IOpenAiDocument.IOptions.keyword} configuration (as `true`), number of\r\n * {@link IOpenAiFunction.parameters} are always 1 and the first parameter's type is\r\n * always {@link IOpenAiSchema.IObject}. The properties' rule is:\r\n *\r\n * - `pathParameters`: Path parameters of {@link ISwaggerMigrateRoute.parameters}\r\n * - `query`: Query parameter of {@link ISwaggerMigrateRoute.query}\r\n * - `body`: Body parameter of {@link ISwaggerMigrateRoute.body}\r\n *\r\n * ```typescript\r\n * {\r\n *   ...pathParameters,\r\n *   query,\r\n *   body,\r\n * }\r\n * ```\r\n *\r\n * Otherwise, the parameters would be multiple, and the sequence of the parameters\r\n * are following below rules:\r\n *\r\n * ```typescript\r\n * [\r\n *   ...pathParameters,\r\n *   ...(query ? [query] : []),\r\n *   ...(body ? [body] : []),\r\n * ]\r\n * ```\r\n */\r\nexport interface IOpenAiFunction {\r\n  /**\r\n   * HTTP method of the endpoint.\r\n   */\r\n  method: \"get\" | \"post\" | \"patch\" | \"put\" | \"delete\";\r\n\r\n  /**\r\n   * Path of the endpoint.\r\n   */\r\n  path: string;\r\n\r\n  /**\r\n   * Representative name of the function.\r\n   *\r\n   * The `name` is a repsentative name identifying the function in the\r\n   * {@link IOpenAiDocument}. The `name` value is just composed by joining the\r\n   * {@link IMigrateRoute.accessor} by underscore `_` character.\r\n   *\r\n   * Here is the composition rule of the  {@link IMigrateRoute.accessor}:\r\n   *\r\n   * > The `accessor` is composed with the following rules. At first, namespaces\r\n   * > are composed by static directory names in the {@link path}. Parametric\r\n   * > symbols represented by `:param` or `{param}` cannot be a part of the\r\n   * > namespace.\r\n   * >\r\n   * > Instead, they would be a part of the function name. The function\r\n   * > name is composed with the {@link method HTTP method} and parametric symbols\r\n   * > like `getByParam` or `postByParam`. If there are multiple path parameters,\r\n   * > they would be concatenated by `And` like `getByParam1AndParam2`.\r\n   * >\r\n   * > For refefence, if the {@link operation}'s {@link method} is `delete`, the\r\n   * > function name would be replaced to `erase` instead of `delete`. It is\r\n   * > the reason why the `delete` is a reserved keyword in many programming\r\n   * > languages.\r\n   * >\r\n   * > - Example 1\r\n   * >   - path: `POST /shopping/sellers/sales`\r\n   * >   - accessor: `shopping.sellers.sales.post`\r\n   * > - Example 2\r\n   * >   - endpoint: `GET /shoppings/sellers/sales/:saleId/reviews/:reviewId/comments/:id\r\n   * >   - accessor: `shoppings.sellers.sales.reviews.getBySaleIdAndReviewIdAndCommentId`\r\n   */\r\n  name: string;\r\n\r\n  /**\r\n   * Whether the function schema types are strict or not.\r\n   *\r\n   * Newly added specification at 2024-08-07.\r\n   *\r\n   * @reference https://openai.com/index/introducing-structured-outputs-in-the-api/\r\n   */\r\n  strict: true;\r\n\r\n  /**\r\n   * List of parameter schemas.\r\n   *\r\n   * If you've configured {@link IOpenAiDocument.IOptions.keyword} (as `true`),\r\n   * number of {@link IOpenAiFunction.parameters} are always 1 and the first parameter's\r\n   * type is always {@link IOpenAiSchema.IObject}. The properties' rule is:\r\n   *\r\n   * - `pathParameters`: Path parameters of {@link IMigrateRoute.parameters}\r\n   * - `query`: Query parameter of {@link IMigrateRoute.query}\r\n   * - `body`: Body parameter of {@link IMigrateRoute.body}\r\n   *\r\n   * ```typescript\r\n   * {\r\n   *   ...pathParameters,\r\n   *   query,\r\n   *   body,\r\n   * }\r\n   * ```\r\n   *\r\n   * Otherwise, the parameters would be multiple, and the sequence of the parameters\r\n   * are following below rules:\r\n   *\r\n   * ```typescript\r\n   * [\r\n   *   ...pathParameters,\r\n   *   ...(query ? [query] : []),\r\n   *   ...(body ? [body] : []),\r\n   * ]\r\n   * ```\r\n   */\r\n  parameters: IOpenAiSchema[];\r\n\r\n  /**\r\n   * Collection of separated parameters.\r\n   *\r\n   * Filled only when {@link IOpenAiDocument.IOptions.separate} has been configured.\r\n   */\r\n  separated?: IOpenAiFunction.ISeparated;\r\n\r\n  /**\r\n   * Expected return type.\r\n   *\r\n   * If the function returns nothing (`void`), then the output is `undefined`.\r\n   */\r\n  output?: IOpenAiSchema | undefined;\r\n\r\n  /**\r\n   * Description of the function.\r\n   *\r\n   * Composed by such rule:\r\n   *\r\n   * 1. Starts from the {@link OpenApi.IOperation.summary} paragraph.\r\n   * 2. The next paragraphs are filled with the {@link OpenApi.IOperation.description}.\r\n   *    By the way, if the first paragraph of {@link OpenApi.IOperation.description} is same\r\n   *    with the {@link OpenApi.IOperation.summary}, it would not be duplicated.\r\n   * 3. Parameters' descriptions are added with `@param` tag.\r\n   * 4. {@link OpenApi.IOperation.security Security requirements} are added with `@security` tag.\r\n   * 5. Tag names are added with `@tag` tag.\r\n   * 6. If {@link OpenApi.IOperation.deprecated}, `@deprecated` tag is added.\r\n   */\r\n  description?: string;\r\n\r\n  /**\r\n   * Get the Swagger operation metadata.\r\n   *\r\n   * Get the Swagger operation metadata, of the source.\r\n   *\r\n   * @returns Swagger operation metadata.\r\n   */\r\n  operation: () => ISwaggerOperation;\r\n\r\n  /**\r\n   * Get the migration route metadata.\r\n   *\r\n   * Get the migration route metadata, of the source.\r\n   *\r\n   * @returns Migration route metadata.\r\n   */\r\n  route: () => ISwaggerMigrateRoute;\r\n}\r\nexport namespace IOpenAiFunction {\r\n  /**\r\n   * Collection of separated parameters.\r\n   */\r\n  export interface ISeparated {\r\n    /**\r\n     * Parameters that would be composed by the OpenAI.\r\n     */\r\n    llm: ISeparatedParameter[];\r\n\r\n    /**\r\n     * Parameters that would be composed by the human.\r\n     */\r\n    human: ISeparatedParameter[];\r\n  }\r\n\r\n  /**\r\n   * Separated parameter.\r\n   */\r\n  export interface ISeparatedParameter {\r\n    /**\r\n     * Index of the parameter.\r\n     */\r\n    index: number;\r\n\r\n    /**\r\n     * Type schema info of the parameter.\r\n     */\r\n    schema: IOpenAiSchema;\r\n  }\r\n}\n/**\r\n * Type schema info of OpenAI function call.\r\n *\r\n * `IOpenAiSchema` is a type schema info of OpenAI function call.\r\n *\r\n * `IOpenAiSchema` is basically follows the JSON schema definition of\r\n * OpenAI v3.0: {@link OpenApiV3.IJsonSchema}. However, `IOpenAiSchema` does not\r\n * have the reference type {@link OpenApiV3.IJsonSchema.IReference}. It's because\r\n * the OpenAI cannot compose\r\n * {@link OpenAiFetcher.IProps.arguments function call arguments} of\r\n * the reference type.\r\n *\r\n * For reference, the OpenAPI v3.0 based JSON schema definition can't express\r\n * the tuple array type. It has been supported since OpenAPI v3.1. Therefore,\r\n * it would better to avoid using the tuple array type.\r\n */\r\nexport type IOpenAiSchema =\r\n  | IOpenAiSchema.IBoolean\r\n  | IOpenAiSchema.IInteger\r\n  | IOpenAiSchema.INumber\r\n  | IOpenAiSchema.IString\r\n  | IOpenAiSchema.IArray\r\n  | IOpenAiSchema.IObject\r\n  | IOpenAiSchema.IUnknown\r\n  | IOpenAiSchema.INullOnly\r\n  | IOpenAiSchema.IOneOf;\r\nexport namespace IOpenAiSchema {\r\n  /**\r\n   * Boolean type schema info.\r\n   */\r\n  export interface IBoolean extends __ISignificant<\"boolean\"> {\r\n    /**\r\n     * Default value.\r\n     */\r\n    default?: boolean;\r\n\r\n    /**\r\n     * Enumeration values.\r\n     */\r\n    enum?: boolean[];\r\n  }\r\n\r\n  /**\r\n   * Integer type schema info.\r\n   */\r\n  export interface IInteger extends __ISignificant<\"integer\"> {\r\n    /**\r\n     * Default value.\r\n     *\r\n     * @type int64\r\n     */\r\n    default?: number;\r\n\r\n    /**\r\n     * Enumeration values.\r\n     *\r\n     * @type int64\r\n     */\r\n    enum?: number[];\r\n\r\n    /**\r\n     * Minimum value restriction.\r\n     *\r\n     * @type int64\r\n     */\r\n    minimum?: number;\r\n\r\n    /**\r\n     * Maximum value restriction.\r\n     *\r\n     * @type int64\r\n     */\r\n    maximum?: number;\r\n\r\n    /**\r\n     * Exclusive minimum value restriction.\r\n     *\r\n     * For reference, even though your Swagger (or OpenAPI) document has\r\n     * defined the `exclusiveMinimum` value as `number`, {@link OpenAiComposer}\r\n     * forcibly converts it to `boolean` type, and assign the numeric value to\r\n     * the {@link minimum} property.\r\n     */\r\n    exclusiveMinimum?: boolean;\r\n\r\n    /**\r\n     * Exclusive maximum value restriction.\r\n     *\r\n     * For reference, even though your Swagger (or OpenAPI) document has\r\n     * defined the `exclusiveMaximum` value as `number`, {@link OpenAiComposer}\r\n     * forcibly converts it to `boolean` type, and assign the numeric value to\r\n     * the {@link maximum} property.\r\n     */\r\n    exclusiveMaximum?: boolean;\r\n\r\n    /**\r\n     * Multiple of value restriction.\r\n     *\r\n     * @type uint64\r\n     * @exclusiveMinimum 0\r\n     */\r\n    multipleOf?: number;\r\n  }\r\n\r\n  /**\r\n   * Number type schema info.\r\n   */\r\n  export interface INumber extends __ISignificant<\"number\"> {\r\n    /**\r\n     * Default value.\r\n     */\r\n    default?: number;\r\n\r\n    /**\r\n     * Enumeration values.\r\n     */\r\n    enum?: number[];\r\n\r\n    /**\r\n     * Minimum value restriction.\r\n     */\r\n    minimum?: number;\r\n\r\n    /**\r\n     * Maximum value restriction.\r\n     */\r\n    maximum?: number;\r\n\r\n    /**\r\n     * Exclusive minimum value restriction.\r\n     *\r\n     * For reference, even though your Swagger (or OpenAPI) document has\r\n     * defined the `exclusiveMinimum` value as `number`, {@link OpenAiComposer}\r\n     * forcibly converts it to `boolean` type, and assign the numeric value to\r\n     * the {@link minimum} property.\r\n     */\r\n    exclusiveMinimum?: boolean;\r\n\r\n    /**\r\n     * Exclusive maximum value restriction.\r\n     *\r\n     * For reference, even though your Swagger (or OpenAPI) document has\r\n     * defined the `exclusiveMaximum` value as `number`, {@link OpenAiComposer}\r\n     * forcibly converts it to `boolean` type, and assign the numeric value to\r\n     * the {@link maximum} property.\r\n     */\r\n    exclusiveMaximum?: boolean;\r\n\r\n    /**\r\n     * Multiple of value restriction.\r\n     *\r\n     * @exclusiveMinimum 0\r\n     */\r\n    multipleOf?: number;\r\n  }\r\n\r\n  /**\r\n   * String type schema info.\r\n   */\r\n  export interface IString extends __ISignificant<\"string\"> {\r\n    /**\r\n     * Default value.\r\n     */\r\n    default?: string;\r\n\r\n    /**\r\n     * Enumeration values.\r\n     */\r\n    enum?: string[];\r\n\r\n    /**\r\n     * Format restriction.\r\n     */\r\n    format?:\r\n      | \"binary\"\r\n      | \"byte\"\r\n      | \"password\"\r\n      | \"regex\"\r\n      | \"uuid\"\r\n      | \"email\"\r\n      | \"hostname\"\r\n      | \"idn-email\"\r\n      | \"idn-hostname\"\r\n      | \"iri\"\r\n      | \"iri-reference\"\r\n      | \"ipv4\"\r\n      | \"ipv6\"\r\n      | \"uri\"\r\n      | \"uri-reference\"\r\n      | \"uri-template\"\r\n      | \"url\"\r\n      | \"date-time\"\r\n      | \"date\"\r\n      | \"time\"\r\n      | \"duration\"\r\n      | \"json-pointer\"\r\n      | \"relative-json-pointer\"\r\n      | (string & {});\r\n\r\n    /**\r\n     * Pattern restriction.\r\n     */\r\n    pattern?: string;\r\n\r\n    /**\r\n     * Minimum length restriction.\r\n     *\r\n     * @type uint64\r\n     */\r\n    minLength?: number;\r\n\r\n    /**\r\n     * Maximum length restriction.\r\n     *\r\n     * @type uint64\r\n     */\r\n    maxLength?: number;\r\n\r\n    /**\r\n     * Content media type restriction.\r\n     */\r\n    contentMediaType?: string;\r\n\r\n    /**\r\n     * Secret key for the schema.\r\n     *\r\n     * `x-wrtn-secret-key` is a property means a secret key that is required\r\n     * for the target API endpoint calling. If the secret key is not filled,\r\n     * the API call would be failed.\r\n     */\r\n    \"x-wrtn-secret-key\"?: string;\r\n\r\n    /**\r\n     * Secret scopes for the schema.\r\n     *\r\n     * `x-wrtn-secret-scopes` is a property means a list of secret scopes that\r\n     * are required for the target API endpoint calling. If the secret scopes\r\n     * are not satisfied, the API call would be failed.\r\n     */\r\n    \"x-wrtn-secret-scopes\"?: string[];\r\n  }\r\n\r\n  /**\r\n   * Array type schema info.\r\n   */\r\n  export interface IArray extends __ISignificant<\"array\"> {\r\n    /**\r\n     * Items type schema info.\r\n     *\r\n     * The `items` means the type of the array elements. In other words, it is\r\n     * the type schema info of the `T` in the TypeScript array type `Array<T>`.\r\n     */\r\n    items: IOpenAiSchema;\r\n\r\n    /**\r\n     * Unique items restriction.\r\n     *\r\n     * If this property value is `true`, target array must have unique items.\r\n     */\r\n    uniqueItems?: boolean;\r\n\r\n    /**\r\n     * Minimum items restriction.\r\n     *\r\n     * Restriction of minumum number of items in the array.\r\n     *\r\n     * @type uint64\r\n     */\r\n    minItems?: number;\r\n\r\n    /**\r\n     * Maximum items restriction.\r\n     *\r\n     * Restriction of maximum number of items in the array.\r\n     *\r\n     * @type uint64\r\n     */\r\n    maxItems?: number;\r\n  }\r\n\r\n  /**\r\n   * Object type schema info.\r\n   */\r\n  export interface IObject extends __ISignificant<\"object\"> {\r\n    /**\r\n     * Properties of the object.\r\n     *\r\n     * The `properties` means a list of key-value pairs of the object's\r\n     * regular properties. The key is the name of the regular property,\r\n     * and the value is the type schema info.\r\n     *\r\n     * If you need additional properties that is represented by dynamic key,\r\n     * you can use the {@link additionalProperties} instead.\r\n     */\r\n    properties?: Record<string, IOpenAiSchema>;\r\n\r\n    /**\r\n     * List of key values of the required properties.\r\n     *\r\n     * The `required` means a list of the key values of the required\r\n     * {@link properties}. If some property key is not listed in the `required`\r\n     * list, it means that property is optional. Otherwise some property key\r\n     * exists in the `required` list, it means that the property must be filled.\r\n     *\r\n     * Below is an example of the {@link properties} and `required`.\r\n     *\r\n     * ```typescript\r\n     * interface SomeObject {\r\n     *   id: string;\r\n     *   email: string;\r\n     *   name?: string;\r\n     * }\r\n     * ```\r\n     *\r\n     * As you can see, `id` and `email` {@link properties} are {@link required},\r\n     * so that they are listed in the `required` list.\r\n     *\r\n     * ```json\r\n     * {\r\n     *   \"type\": \"object\",\r\n     *   \"properties\": {\r\n     *     \"id\": { \"type\": \"string\" },\r\n     *     \"email\": { \"type\": \"string\" },\r\n     *     \"name\": { \"type\": \"string\" }\r\n     *   },\r\n     *   \"required\": [\"id\", \"email\"]\r\n     * }\r\n     * ```\r\n     */\r\n    required?: string[];\r\n\r\n    /**\r\n     * Additional properties' info.\r\n     *\r\n     * The `additionalProperties` means the type schema info of the additional\r\n     * properties that are not listed in the {@link properties}.\r\n     *\r\n     * If the value is `true`, it means that the additional properties are not\r\n     * restricted. They can be any type. Otherwise, if the value is\r\n     * {@link IOpenAiSchema} type, it means that the additional properties must\r\n     * follow the type schema info.\r\n     *\r\n     * - `true`: `Record<string, any>`\r\n     * - `IOpenAiSchema`: `Record<string, T>`\r\n     */\r\n    additionalProperties?: boolean | IOpenAiSchema;\r\n  }\r\n\r\n  /**\r\n   * Unknown type schema info.\r\n   *\r\n   * It means the type of the value is `any`.\r\n   */\r\n  export interface IUnknown extends __IAttribute {\r\n    /**\r\n     * Type is never be defined.\r\n     */\r\n    type?: undefined;\r\n  }\r\n\r\n  /**\r\n   * Null only type schema info.\r\n   */\r\n  export interface INullOnly extends __IAttribute {\r\n    /**\r\n     * Type is always `null`.\r\n     */\r\n    type: \"null\";\r\n  }\r\n\r\n  /**\r\n   * One of type schema info.\r\n   *\r\n   * `IOneOf` represents an union type of the TypeScript (`A | B | C`).\r\n   *\r\n   * For reference, even though your Swagger (or OpenAPI) document has\r\n   * defined `anyOf` instead of the `oneOf`, {@link OpenAiComposer} forcibly\r\n   * converts it to `oneOf` type.\r\n   */\r\n  export interface IOneOf extends __IAttribute {\r\n    /**\r\n     * List of the union types.\r\n     */\r\n    oneOf: IOpenAiSchema[];\r\n  }\r\n\r\n  /**\r\n   * Significant attributes that can be applied to the most types.\r\n   */\r\n  export interface __ISignificant<Type extends string> extends __IAttribute {\r\n    /**\r\n     * Discriminator value of the type.\r\n     */\r\n    type: Type;\r\n\r\n    /**\r\n     * Whether to allow `null` value or not.\r\n     */\r\n    nullable?: boolean;\r\n  }\r\n\r\n  /**\r\n   * Common attributes that can be applied to all types.\r\n   */\r\n  export interface __IAttribute {\r\n    /**\r\n     * Title of the schema.\r\n     */\r\n    title?: string;\r\n\r\n    /**\r\n     * Detailed description of the schema.\r\n     */\r\n    description?: string;\r\n\r\n    /**\r\n     * Whether the type is deprecated or not.\r\n     */\r\n    deprecated?: boolean;\r\n\r\n    /**\r\n     * Placeholder value for frontend application.\r\n     *\r\n     * Placeholder means the value to be shown in the input field as a hint.\r\n     * For example, when an email input field exists, the placeholder value\r\n     * would be \"Insert your email address here\".\r\n     */\r\n    \"x-wrtn-placeholder\"?: string;\r\n\r\n    /**\r\n     * Prerequisite API endpoint for the schema.\r\n     *\r\n     * `x-wrtn-prerequisite` is a property representing the prerequisite API\r\n     * interaction. It means that, the endpoint API should be called before\r\n     * calling the target API, for composing some argument value.\r\n     *\r\n     * @reference https://github.com/wrtnio/decorators/blob/main/src/Prerequisite.ts\r\n     */\r\n    \"x-wrtn-prerequisite\"?: {\r\n      /**\r\n       * HTTP method to call the endpoint.\r\n       */\r\n      method: \"get\" | \"post\" | \"patch\" | \"put\" | \"delete\";\r\n\r\n      /**\r\n       * Path of the endpoint.\r\n       */\r\n      path: string;\r\n\r\n      /**\r\n       * Function returning transformed values using JMESPath expression.\r\n       *\r\n       * `Prerequisite.Props.jmesPath` is a string typed property that extracts desired values\r\n       * from the prerequisite API response using a JMESPath expression. This property simplifies\r\n       * and replaces the `label`, `value`, and `array` properties.\r\n       *\r\n       * JMESPath expressions are used to extract the desired data based on the API response.\r\n       * The expression must always be a valid JMESPath syntax.\r\n       *\r\n       * - Type: `jmesPath: string`\r\n       * - Example: `\"members[*].data.title\"`\r\n       * - Usage: `jmespath.search(response, jmesPath)`\r\n       *\r\n       * Note: The `label`, `value`, and `array` properties are no longer in use.\r\n       */\r\n      jmesPath: string;\r\n    }\r\n  }\r\n}\nTransform to the LLM function calling schema.After converting to OpenAPI v3.1 emended specification, and normalizing to the migration schema, we can finally transform to the LLM function calling schema. The LLM function calling schema is a typical RPC (Remote Procedure Call) structure representing a function which has its own name, description, parameters and return value types.About the type schema, it is similar with OpenAPI v3.0 speicified JSON schema, however, it does not have reference type ($ref). Therefore, LLM function calling schema cannot express recursive types, so that only flat structured OpenAPI operation can be transformed to the LLM function schema.Additionally, \"Wrtn Studio Pro\" is separating the parameters of LLM function schema into two parts; Human and LLM. The Human side parameters mean that, the value must be composed by human, not by LLM. For example, secret key value for identifying user or file uploading feature must be composed by Human, and such parameters are separated from the LLM side parameters.","meta-llm-ai-chatbot#Meta LLM (A.I. Chatbot)":"/**\r\n * Set of functions provided by the Meta LLM server to the client.\r\n * \r\n * `IStudioMetaChatService` is an interface that defines the set of functions\r\n * provided by the **server** to the Meta LLM (Large Language Model) client. The Meta \r\n * LLM client remotely calls the server's `IStudioMetaChatService` functions through \r\n * this interface with RPC (Remote Procedure Call) paradigm.\r\n * \r\n * Note that the client must call the {@link initialize} function immediately\r\n * after connecting to the Meta LLM server. If the client tries to skip the\r\n * {@link initialize} function call and directly call {@link talk}, the function\r\n * call will fail, so that exception would be thrown.\r\n */\r\nexport interface IStudioMetaChatService {\r\n  /**\r\n   * Publish/restore/initialize the chat session.\r\n   * \r\n   * The client must call this function once after connecting to the Meta LLM\r\n   * server to publish a new chat session or restore an existing session. If\r\n   * the client tries to skip the {@link initialize} function call and directly\r\n   * call {@link talk}, the function call will fail, so that exception would be\r\n   * thrown.\r\n   * \r\n   * Also, the returned session would be a new chat session if the client connected\r\n   * to the server via the new chat session API, and the existing session would be\r\n   * restored if the client connected to the server via the continue chat session\r\n   * API.\r\n   *\r\n   * - {@link HubApi.functional.studio.customers.meta.chat.sessions.start}\r\n   * - {@link HubApi.functional.studio.customers.meta.chat.sessions.restart}\r\n   */\r\n  initialize(): Promise<IStudioMetaChatSession>;\r\n\r\n  /**\r\n   * User talks to Meta LLM.\r\n   * \r\n   * A function called by the client to talk to the Meta LLM server.\r\n   * \r\n   * @param dialogue Dialogue information\r\n   */\r\n  talk(dialogue: IStudioMetaChatDialogue): Promise<void>;\r\n}\n/**\r\n * Set of functions provided by the Meta LLM client to the server.\r\n * \r\n * `IStudioMetaChatListener` is an interface that defines the set of functions\r\n * provided by the **client** to the Meta LLM (Large Language Model) server. The Meta \r\n * LLM server remotely calls the client's `IStudioMetaChatListener` functions through\r\n * this interface with RPC (Remote Procedure Call) paradigm.\r\n */\r\nexport interface IStudioMetaChatListener {\r\n  /**\r\n   * Meta LLM server talks to the user.\r\n   * \r\n   * A function called by the Meta LLM server to talk to the user.\r\n   *\r\n   * @param dialogue Dialogue information\r\n   */\r\n  talk(dialogue: IStudioMetaChatDialogue): Promise<void>;\r\n\r\n  /**\r\n   * Notify the client of the server's listenability.\r\n   * \r\n   * The Meta LLM server notifies the client whether it is possible to listen.\r\n   *  \r\n   * In other words, this function informs the client whether it can call\r\n   * {@link IStudioMetaChatService.talk} immediately or not.\r\n   * \r\n   * Note that when the client calls the server's RPC function\r\n   * {@link IStudioMetaChatService.talk}, the value `false` is passed to this\r\n   * function {@link IStudioMetaChatListener.listenable} immediately. On the\r\n   * other hand, the value `true` is passed to this function in various cases.\r\n   *\r\n   * @param status Listenability status\r\n   */\r\n  listenable(status: boolean): Promise<void>;\r\n\r\n  /**\r\n   * Explain the function call plan.\r\n   * \r\n   * The Meta LLM server explains the function call plan to the user.\r\n   * \r\n   * The function call plan provided includes a list of functions that LLM\r\n   * wants to execute in order, and a description of the entire plan and the\r\n   * purpose of each function call.\r\n   * \r\n   * The client can read this and decide whether to proceed with the LLM\r\n   * function call execution. If `true` is returned, the Meta LLM will call\r\n   * the functions according to the plan. Otherwise `false` be returned, the plan\r\n   * would be withdrawn.\r\n   * \r\n   * @param plan Function call plan\r\n   * @returns Whether to proceed with the plan or not\r\n   */\r\n  explainFunctionCall(plan: IStudioMetaChatFunctionCallPlan): Promise<boolean>;\r\n\r\n  /**\r\n   * Select a function to call.\r\n   * \r\n   * A function called by the Meta LLM server when LLM (Large Language Model) has\r\n   * determined the target function to call during the conversation with the user.\r\n   * \r\n   * After this function be called, the server will call the {@link fillArguments} \r\n   * functionns remotely to commpose parameter values, and then call the \r\n   * {@link completeFunction} function after the function call execution.\r\n   *\r\n   * @param props Information of the target function\r\n   */\r\n  selectFunction(props: IStudioMetaChatFunctionCall.ISelect): Promise<void>;\r\n\r\n  /**\r\n   * Fill in the argument of the function call.\r\n   * \r\n   * A function called by the Meta LLM server when the user needs to fill in \r\n   * some of the argument for the LLM function call. For example, when the user\r\n   * needs to enter an authentication key for a Google account, or upload a file\r\n   * manually.\r\n   * \r\n   * `IStudioMetaFunctionCall.arguments` is a function called when the user needs\r\n   * to compose some (or all) of the arguments to be used in the function call\r\n   * directly. The returned value means the value that the client has composed.\r\n   * \r\n   * The only cases where the client receives input separately from the server\r\n   * in our service are as follows:\r\n   *\r\n   * - {@link IOpenAiSchema.IString[\"x-wrtn-secret-key\"]}\r\n   * - {@link IOpenAiSchema.IString.contentMediaType}\r\n   *\r\n   * @param props Information of the target function and argument types\r\n   * @returns The value composed by the client, or rejection by hin/her\r\n   */\r\n  fillArgument(\r\n    props: IStudioMetaChatFunctionCall.IFillArgument,\r\n  ): Promise<IStudioMetaChatListener.IFillArgumentResult>;\r\n\r\n  /**\r\n   * Complete the function call.\r\n   * \r\n   * A function called by the Meta LLM server to inform the client of the \r\n   * completion of the LLM function call execution. \r\n   * \r\n   * It embodies the `Try<T, E>` structure, so that contains whether the function call \r\n   * was successful or not. Also, it contains the return value when suceeded, and the\r\n   * exception information when failed.\r\n   *\r\n   * @param props Information of the execution result\r\n   */\r\n  completeFunction(props: IStudioMetaChatFunctionCall.IComplete): Promise<void>;\r\n\r\n  /**\r\n   * Workflow has been prepared.\r\n   * \r\n   * A function called by the Meta LLM server when the workflow creation is ready.\r\n   * Client can decide whether to save the {@link IStudioWorkflow workflow document} \r\n   * based on the {@link IStudioWorkflowData.ICreate creation information} received \r\n   * from the server.\r\n   * \r\n   * If client returns a {@link IStudioMetaChatWorkflowConfirm} instance in this \r\n   * function, the server will create the workflow at the specified \r\n   * {@link IStudioRepository repository} location. Otherwise the client returns\r\n   * `null`, the server will not create the workflow.\r\n   *\r\n   * @param data Workflow creation information\r\n   * @param plan Workflow configuration plan including detailed descriptions\r\n   * @returns Whether to create the workflow document or not\r\n   */\r\n  prepareWorkflow(\r\n    data: IStudioWorkflowData.ICreate,\r\n    plan: IStudioMetaChatWorkflowPlan,\r\n  ): Promise<IStudioMetaChatWorkflowConfirm | null>;\r\n\r\n  /**\r\n   * Workflow has been created/updated.\r\n   * \r\n   * A function called by the Meta LLM server when an {@link IStudioWorkflow workflow}\r\n   * has been newly created or updated by the client had returned a non-null value from\r\n   * the {@link prepareWorkflow} function.\r\n   * \r\n   * Whether the server creates or updates the workflow depends on the return value of\r\n   * the {@link prepareWorkflow} function. If the client orders a new workflow document,\r\n   * it would be created by the server. Otherwise the client directed the existing\r\n   * workflow document, it would be updated.\r\n   * \r\n   * The provided parameter object is the detailed information of the workflow\r\n   * {@link IStudioWorkflow} and its location information with {@link IStudioRepository}, \r\n   * so that the client can check it and enter the workflow editor or provide \r\n   * a preview image.\r\n   *\r\n   * @param workflow Newly created or updated workflow\r\n   * @param related Account and repository information related to the workflow\r\n   */\r\n  completeWorkflow(\r\n    workflow: IStudioWorkflow,\r\n    related: Pick<IStudioMetaChatWorkflowConfirm, \"account\" | \"repository\">,\r\n  ): Promise<void>;\r\n\r\n  /**\r\n   * Meta LLM server requests the client to terminate.\r\n   * \r\n   * When the Meta LLM session suddenly died due to the bug from LLM \r\n   * (Large Language Model) like OpenAI, the server requests the client to terminate \r\n   * the connection, and retry it again a little bit later.\r\n   *\r\n   * @param error Error from the LLM module\r\n   */\r\n  kill(error?: any): Promise<void>;\r\n}\nimport { IOpenAiFunction, IOpenAiSchema } from \"@wrtnio/openai-function-schema\";\r\nimport { Primitive, tags } from \"typia\";\r\nimport { OmitNever } from \"typia/lib/typings/OmitNever\";\r\n\r\nexport namespace IStudioMetaChatFunctionCall {\r\n  /**\r\n   * Selection information of the function to call.\r\n   * \r\n   * `IStudioMetaChatFunctionCall.ISelect` is an interface that providing metadata\r\n   * of the target function to call when the Meta LLM server selects a proper function \r\n   * to call during the conversation with the user.\r\n   * \r\n   * In the context of RPC (Remote Procedure Call), this `IStudioMetaChatFunctionCall`\r\n   * structure is used in the {@link IStudioMetaChatListener.selectFunction} method.\r\n   * Also after delivering this information. the server will step below sequence:\r\n   * \r\n   * 1. {@link IStudioMetaChatListener.fillArgument} to compose Human side parameters\r\n   * 2. {@link IStudioMetaChatListener.completeFunction} after function call execution\r\n   */\r\n  export interface ISelect {\r\n    /**\r\n     * Primary Key.\r\n     */\r\n    id: string & tags.Format<\"uuid\">;\r\n\r\n    /**\r\n     * Metadata of the target function to call.\r\n     */\r\n    function: OmitNever<Primitive<IOpenAiFunction>>;\r\n  }\r\n\r\n  /**\r\n   * Request of arguments filling of Human side parameter.\r\n   * \r\n   * `IStudioMetaChatFunctionCall.IFillArgument` is an interface that providing\r\n   * the request to client for composing some of the arguments of the target\r\n   * function that must be filled by Human side, intead of LLM (Large Language Model).\r\n   * \r\n   * As a case of the values that must be filled by Human side, there are secret key\r\n   * and file upload. In the context of {@link IOpenAiSchema}, those typed values\r\n   * must be filled by Human:\r\n   * \r\n   * - {@link IOpenAiSchema.IString[\"x-wrtn-secret-key\"]}\r\n   * - {@link IOpenAiSchema.IString.contentMediaType}\r\n   */\r\n  export interface IFillArgument {\r\n    /**\r\n     * Identifier of the target function.\r\n     * \r\n     * It is same with the {@link IStudioMetaChatFunctionCall.ISelect.id}.\r\n     */\r\n    id: string & tags.Format<\"uuid\">;\r\n\r\n    /**\r\n     * Index of the parameter to fill.\r\n     */\r\n    index: number & tags.Type<\"uint32\">;\r\n\r\n    /**\r\n     * Schema information that must be composed by Human.\r\n     */\r\n    schema: IOpenAiSchema;\r\n\r\n    /**\r\n     * Metadata of the parameter that can be filled by LLM.\r\n     * \r\n     * If this value is `null`, it means that the parameter must be filled only by \r\n     * Human. Otherwise, LLM (Large Language Model) also can fill the parameter value\r\n     * by analyzing the client's conversation, and Meta LLM merges it with the \r\n     * Human composed.\r\n     */\r\n    llm: null | {\r\n      /**\r\n       * SChema information that can be filled by LLM.\r\n       */\r\n      schema: IOpenAiSchema;\r\n\r\n      /**\r\n       * Actual value filled by LLM.\r\n       */\r\n      value: any;\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Result of the function call execution.\r\n   * \r\n   * `IStudioMetaChatFunctionCall.IComplete` is an interface that providing the\r\n   * result of the function call execution.\r\n   * \r\n   * In the RPC (Remote Procedure Call) context, this `IStudioMetaChatFunctionCall`\r\n   * structure is used in the {@link IStudioMetaChatListener.completeFunction} method.\r\n   */\r\n  export interface IComplete {\r\n    /**\r\n     * Primary Key.\r\n     * \r\n     * It is same with the {@link IStudioMetaChatFunctionCall.ISelect.id}.\r\n     */\r\n    id: string & tags.Format<\"uuid\">;\r\n\r\n    /**\r\n     * Arguments list used in the function call.\r\n     */\r\n    arguments: any[];\r\n\r\n    /**\r\n     * Whether the function call was successful or not.\r\n     */\r\n    success: boolean;\r\n\r\n    /**\r\n     * Returned value as a result of the function call.\r\n     * \r\n     * If the function call has been failed, this value would be exception instance \r\n     * thrown by the target function.\r\n     */\r\n    value: any;\r\n\r\n    /**\r\n     * Time of the function call start.\r\n     */\r\n    created_at: string & tags.Format<\"date-time\">;\r\n\r\n    /**\r\n     * Time of the function call completion.\r\n     * \r\n     * If this value is `null`, it means that the connection to the target function\r\n     * (API operation) itself has failed. On the other hand, if the connection has been\r\n     * succeeded but exception has been thrown during the function call, this time\r\n     * would be the time when the exception has been thrown.\r\n     */\r\n    completed_at: null | (string & tags.Format<\"date-time\">);\r\n\r\n    /**\r\n     * Status of the response.\r\n     * \r\n     * The HTTP protocol response status if the connection has been succeeded.\r\n     * Otherwise the connection has been failed, this value would be `null`.\r\n     */\r\n    status: number | null;\r\n  }\r\n}\nFunction call execution through remotely procedure calls in WebSocket protocol.\"Wrtn Studio Pro\" is serving Meta LLM (A.I. Chatbot) with WebSocket Protocol. Also, have implemented interaction logic between client and server as RPC (Remote Procedure Call) paradigm. With the RPC paradigm, client can remote call procedures of server provided like its own function, and server also can remotely call procedures of client provided like its own.\nReferences\nRemote Procedure Call\nFeatures > RPC Components\nLearn from Examples > Remote Function Call\nProviders\nIStudioMetaChatService\nIStudioMetaChatListener\nIn such RPC background, \"Wrtn Studio Pro\" has accomplished the LLM function calling A.I. chatbot like below:\nThe Meta LLM starts by client's IStudioMetaChatService.initialize() remotely method calling, so that the chatting session be published (or restored). After that, the client may sends some conversation text to the server by calling IStudioMetaChatService.talk() method. This is the start of every function call execution step.When Meta LLM server listens the client's chatting text, it analyzes the text and predicts whether the conversation indicates a function call or not. If the conversation is suspicious to requesting some action, Meta LLM server finds proper functions to call. If suceeded to find some functions which can accomplish the user's request, Meta LLM makes a function call execution plan, and explains the plan to the client by calling IStudioMetaChatListener.explainFunctionCall() method. If client accepts the plan, so that returns tue value in the method, the Meta LLM server starts the function call execution process.For each functions to call, at first, Meta LLM server delivers the metadata information of the target function to call to the client by calling IStudioMetaChatListener.selectFunction() method. Also, Meta LLM server requests the client to fill parameter arguments. Such request and response would be done by chatting text through IStudioMetaChatService.talk() and IStudioMetaChatListener.talk() methods. Meta LLM analyzes user replied chatting text, and fill arguments of the target function by itself.By the way, some functions may have special arguments that only Human can compose. Secret key and file uploading cases would be such examples. In that case, Meta LLM requests client to fill the Human side arguments by calling IStudioMetaChatListener.fillArgument() method per each parameter argument. In the method, client manually composes the argument through Inspector component, and returns it. Meta LLM merges the Human composed argument with the LLM composed, and executes the function.After the function call execution, Meta LLM server informs the function call result by calling IStudioMetaChatListener.completeFunction() method. Parameter of the method (IStudioMetaChatFunctionCall.IComplete type) contains everything about the function call result, including whether to suceeded or not, and return value from the target function or thrown exception information. If the returned value is simple, Meta LLM server will describe the result as conversation text. Otherwise, client side Meta LLM application may provide a return value viewer to show the result."}},"/tech-specs/marketplace/schema":{"title":"Schema","data":{"summary#Summary":"In here chapter, we will learn about the schema of the marketplace.As you can see, the schema of the marketplace starts from the Sales section. In the Sales section, it has defined SKU (Stock Keeping Unit) structured OpenAPI products. It starts from the hub_sales (or hub_sale_snapshots) entity, and its final goal is to reaching to the target stock by configuring each candidate value for each option of each unit. After reaching to the target stock record, the customer may purchase the product with price model specification.In the next Audit section, we will learn about the audit process of the sale. Whenever seller newly creates a sale or updates ordinary one, administrator may write an audit article issuing the audit process. In the audit process, both administrator and seller can emend the sale content, and administrator may determine to approve or reject the sale. When adminnistrator approves it, the sale would be started and the customer may purchase it. Also, even though administrator has rejected it, seller can request re-audit by comment, so that it can be reversely approved in sometimes.When customer wants to buy a sale from the marketplace, he or she may specify the stocks from the sale and put them into the cart as a commodity. After that, customer can proceed the order from the prepared cart. When the cart is submitted as an order, its children commodities are changed to goods. When customer wants to complete the order as a formal contract, the order be published.By the way, if administrator or seller hopes to take a discount event, how should do? In this case, Coupon is the answer. Administrator and seller can design a discount coupon, and customer take advantage of it by issuing a ticket of the coupon and paying it to the order. You can limit the total amount of the coupon by configuring inventory, and also possible to restrict variable conditions such as the minimum amount of the order or the expiration date of the coupon.At last, there can be a customer who wants after service about the purchased product. For example, some customer requests additional features to the OpenAPI product seller. In that case, customer can write an issue about the order good to requesting the new features. Communicating with reply comments, seller can charge a fee to the issue, because the new features need additional labor cost. If customer accepts the fee charge, the seller must do his/her job and close the issue with completion flag. Otherwise, customer can reject the fee charge and close the issue with cancellation flag.","sale#Sale":"IHubSale\nIHubSaleSnapshot\nIHubSaleUnit\nIHubSaleUnitOption\nIHubSaleUnitOptionCandidate\nIHubSaleUnitStock\nIHubSaleUnitStockChoice\nIHubSaleUnitStockPrice","hub_sales#hub_sales":"Seller sales products (API).hub_sales    \"API  \" ()\r\n  .     hub_sales  ,   hub_sale_snapshots \r\n.     ,  hub_sales   \r\n,     .    \r\n ,   \r\n   ,  \r\n    . ,     \r\n    ,  A/B      \r\n.Properties\nid: Primary Key.\nhub_section_id:   hub_sections.id\nhub_customer_id:     hub_customers.id\ncreated_at:   .\nopened_at\n  .  NULL ,     .\nclosed_at\n  .  NULL ,   .\npaused_at\n  .   API    .          ,\r\n  \"   \"   .\nsuspended_at\n .     .          .\r\n  soft delete  ,     \r\n  ,       .","hub_sale_snapshots#hub_sale_snapshots":"  .hub_sale_snapshots    \r\n.  hub_sale_snapshots     \r\n    .   (   )  ,\r\n  \r\n .     ,\r\n    .Properties\nid:\nhub_sale_id:   hub_sales.id\nversion\n.ISwaggerInfo.version      .,   ( )  ,     .\nversion_description\n .      .\ncreated_at:   .\nactivated_at\n  .    ,   . hub_sale_audit_approvals     ,\r\n     .\nexpired_at:    API   .","hub_sale_snapshot_units#hub_sale_snapshot_units":"    .hub_sale_snapshot_units    \" \" \r\n .    \" \" ,  \r\n  ,     . hub_sale_snapshot_units  hub_sale_snapshots \r\n1: N     ,      \r\n  .  \" \"   .\n    ( )\n\n\n\n  ( A/S )\n    ( AI )\n \n  \n/  \n hub_sale_snapshot_units  ,     \r\n   .\r\n    \r\n  \r\n,     .    ,    (CPU / RAM / SSD)  \r\n  ,    .Properties\nid:\nhub_sale_snapshot_id:   hub_sale_snapshots.id\nstudio_repository_release_id\n  studio_repository_release.id@format uuid\r\n    Unit Workflow  API  .\nparent_id\n  hub_sale_snapshot_units.id   ,   API     .\nname:   .\nhost_real:   .\nhost_dev:   .\nswagger\n  .OpenAPI v3.1    .\nprimary\n/ .  .\nrequired\n .  ,     .\nsequence:     .","hub_sale_snapshot_unit_parameters#hub_sale_snapshot_unit_parameters":"   .      .Properties\nid:\nhub_sale_snapshot_unit_id:   hub_sale_snapshot_units.id\nin\n .        .\nquery\nheader\nkey: Key ,  .\nvalue: Value ,  .\ndescription:\nsequence:\ncreated_at:\nupdated_at:\ndeleted_at:","hub_sale_snapshot_unit_options#hub_sale_snapshot_unit_options":"    .hub_sale_snapshot_unit_options      \r\nhub_sale_snapshot_units   ,  \r\n      .\n \n \n : CPU, GPU, RAM \n  AI:  ,  ,  \n \n\n  ()\n   select   , \r\n  ,\r\n    \r\n. select  ,  select ,   ,\r\n       .    \r\n    ,        .Properties\nid:\nhub_sale_snapshot_unit_id:   hub_sale_snapshot_units.id\nname:  .\ntype\n .\nselect:      \nboolean\nnumber\nstring\nvariable\n .   \"select\"  ,    ,\r\n    .\nsequence:     .","hub_sale_snapshot_unit_option_candidates#hub_sale_snapshot_unit_option_candidates":"     .hub_sale_snapshot_unit_option_candidates  \"select\" \r\n   ,\r\n   .\n\n) RAM: 8GB, 16GB, 32GB\n) GPU: RTX 3060, RTX 4080, TESLA\n)  : , , \n    \"select\"  ,    .Properties\nid:\nhub_sale_snapshot_unit_option_id:   hub_sale_snapshot_unit_options.id\nname:   .\nsequence:     .","hub_sale_snapshot_unit_stocks#hub_sale_snapshot_unit_stocks":"    .hub_sale_snapshot_unit_stocks      \r\nhub_sale_snapshot_units   ,    \r\n ( \"select\" )  \r\n \r\n ,   .     \"\"\r\n  .\n)  \n\nCPU: { i3, i5, i7, i9 }\nRAM: { 8GB, 16GB, 32GB, 64GB, 96GB }\nSSD: { 256GB, 512GB, 1TB }\n  : 4 * 5 * 3 = 60 \n    hub_sale_snapshot_unit_stocks   \r\n  (Cartesian Sale)    . ,  ( \"select\" )\r\n          ,  \r\n    . ,    \"select\"   ,\r\n      1  .Properties\nid:\nhub_sale_snapshot_unit_id:   hub_sale_snapshot_units.id\nname:   .\nsequence:     .","hub_sale_snapshot_unit_stock_choices#hub_sale_snapshot_unit_stock_choices":"   .hub_sale_snapshot_unit_stock_choices  \r\n    select \r\n ,    \r\n  \r\n  .,      ,\r\n    .Properties\nid:\nhub_sale_snapshot_unit_stock_id:   hub_sale_snapshot_unit_stocks.id\nhub_sale_snapshot_unit_option_candidate_id:   hub_sale_snapshot_unit_option_candidates.id\nsequence:     .","hub_sale_snapshot_unit_stock_prices#hub_sale_snapshot_unit_stock_prices":"  .hub_sale_snapshot_unit_stock_prices       .\r\n    ,     ,  \r\n   .   ,        .\n 50,000  API 1,000  ,  1 100 \n 100,000  API 2,500  ,  1 75 \n 150,000  API 4,000  ,  1 50 \nProperties\nid:\nhub_sale_snapshot_unit_stock_id:   hub_sale_snapshot_unit_stocks\nthreshold:     .\nfixed:  .\nvariable\n .   API     .","hub_sale_snapshot_contents#hub_sale_snapshot_contents":"   .hub_sale_snapshot_contents   \r\n   .  ,    \r\n    .       ,    \r\n   .    API   \r\n ,       , \r\n         \r\n. API         ,\r\n     1: N   1: 1    .Properties\nid: Primary Key.\nhub_sale_snapshot_id:   hub_sale_snapshots.id\ntitle: .\nsummary:  \nformat\n ,  .txt  html  md .\nbody:  .","audit#Audit":"IHubSaleAudit\nIHubSaleAuditEmendation\nIHubSaleAuditRejection\nIHubSaleAuditApproval\nIHubSaleAuditComment","hub_sale_audits#hub_sale_audits":"    .       \r\n(     ),\r\n   ,    \r\n   . hub_sale_audits      \r\n .        ,\r\n     ,        .\r\n  hub_sale_audits  bbs_articles    .,       ,     \r\n       .     \r\n  ,       .    \r\n       .        ,  \r\n     .      \r\n .Properties\nid:\nhub_sale_snapshot_id:    hub_sale_snapshots.id\nhub_customer_id:     hub_customers.id","hub_sale_audit_emendations#hub_sale_audit_emendations":"   .  hub_sellers    \r\n  \r\n .    \r\n   ,\r\n     .  hub_sale_audit_emendations     ,\r\n      \r\n,         .        ,    \r\n   ,      . ,\r\n      ,    \r\n     .      , \r\n    . \r\n     ,\r\n   ,     .Properties\nid:\nhub_sale_audit_id:   hub_sale_audits.id\nhub_customer_id:    hub_customers.id.\nprevious_hub_sale_snapshot_id\n    hub_sale_snapshots.id.  ,       . \r\n      ,   \r\n    .\nafter_hub_sale_snapshot_id\n   hub_sale_snapshots.id.        .\nactor_type\n   \nadministrator: \nseller: \ndescription\n   .       .\ncreated_at:   .","hub_sale_audit_rejections#hub_sale_audit_rejections":"    .hub_sale_auditsRejection  \r\n     .     ,  \r\n     . , \r\n   ,  \r\n   .Properties\nid:\nhub_sale_audit_id:   hub_sale_audits.id.\nhub_customer_id:    hub_customers.id.\nreversible\n  .   ,   .,     ,     \r\n    .    ,\r\n     .\ncreated_at:   .","hub_sale_audit_approvals#hub_sale_audit_approvals":"    .hub_sale_audit_approvals  \r\n     .     ,       \r\n. ,      . ,  \r\n     . \r\n    .Properties\nid:\nhub_sale_audit_id:   hub_sale_audits.id.\nhub_sale_snapshot_id\n    hub_sale_snapshots.id.  ,   \r\n   .     ,   \r\n  .\nhub_customer_id:    hub_customers.id.\nfee_ratio: .\ncreated_at:   .","hub_sale_audit_comments#hub_sale_audit_comments":"   .hub_sale_audit_comments  bbs_article_comments   ,\r\n  \r\n,      .    ,       , \r\n    . ,       \r\n    .Properties\nid:\nhub_customer_id:    hub_customers.id.\nactor_type\n   .\nadministrator: \nseller: ","order#Order":"IHubCartCommodity\nIHubOrder\nIHubOrderGood\nIHubOrderPrice\nIHubOrderPublish","hub_carts#hub_carts":". hub_carts   ,  \r\n    .,  hub_carts         \r\n.     \r\n   ,        ,\r\n       .Properties\nid:\nhub_customer_id:    hub_customers.id\nactor_type:   .\ncreated_at:   .\ndeleted_at:   .","hub_cart_commodities#hub_cart_commodities":"   ().hub_cart_commodities   \r\n ,      .\r\n      ,   \r\nhub_cart_commodities  hub_order_goods  .    ,      \r\n \r\n    .\r\n        hub_cart_commodity_stocks \r\n.Properties\nid:\nhub_cart_id:   hub_carts.id\nhub_sale_snapshot_id:    hub_sale_snapshots\ncreated_at:   .\ndeleted_at:   .\npublished\n .     .  ,          .  ,    ,   .","hub_cart_commodity_stocks#hub_cart_commodity_stocks":"     .hub_cart_commodity_stocks   \r\n    hub_cart_commodities\r\n  ,       \r\n        ./           ,\r\n hub_cart_commodities    \r\nhub_cart_commodity_stocks   .Properties\nid:\nhub_cart_commodity_id:    hub_cart_commodities\nhub_sale_snapshot_unit_id:   hub_sale_snapshot_units.id\nhub_sale_snapshot_unit_stock_id:    hub_sale_snapshot_unit_stocks\nhub_sale_snapshot_unit_stock_price_id:    hub_sale_snapshot_unit_stock_prices\nsequence:      .","hub_cart_commodity_stock_choices#hub_cart_commodity_stock_choices":"      .hub_cart_commodity_stock_choices  hub_cart_commodity_stocks  \r\n,  \r\n   \r\n  ) ,  \r\n) ,    \r\n   \r\n . hub_cart_commodity_stock_choices \r\n)   ,\r\n     \r\n  ,  ) \r\nselect   \r\n  ,\r\n       .Properties\nid:\nhub_cart_commodity_stock_id:     hub_cart_commodity_stocks.id\nhub_sale_snapshot_unit_option_id:   hub_sale_snapshot_unit_options.id\nhub_sale_snapshot_unit_option_candidate_id\n     \r\nhub_sale_snapshot_unit_option_candidates.id\nvalue:      .\nsequence:      .","hub_orders#hub_orders":" .hub_orders      .    ,   \r\n    \r\n, hub_orders   hub_order_goods   .,           ,   \r\n  hub_order_goods  .Properties\nid:\nhub_customer_id:   hub_customers.id\ncreated_at:   .\ncancelled_at:   .","hub_order_goods#hub_order_goods":"    .hub_order_goods      \r\n,    ,\r\n        \r\n. hub_order_goods  hub_cart_commodities  ,\r\n    . hub_order_goods    ,    (A/S)     \r\n.       ,\r\n     hub_order_goods .Properties\nid:\nhub_order_id:   hub_orders.id\nhub_cart_commodity_id:    hub_cart_commodities.id\nhub_seller_id\n  hub_sellers.id   ,       .\nopened_at\n  .   ,        .\r\n    ,   ,    .\r\n   ,     .   API   ,    \r\n,           \r\n .\nclosed_at\n  .,        .    ,\r\n 1      .    \r\n,  1     .\nsequence:     .","hub_order_publishes#hub_order_publishes":"  .hub_order_publishes      . \r\n   , \r\n     .,  ,     .  \r\n     ,  \r\n API   ,     ,\r\n        .    ,    ,   \r\n   . ,      \r\n,    .Properties\nid: Primary Key.\nhub_order_id:   hub_orders.id\ncreated_at:   .","hub_order_good_calls#hub_order_good_calls":"   API  .    , API     .Properties\nid:\nhub_order_good_id:    hub_order_goods.id\nhub_sale_snapshot_unit_id:  API    hub_sale_snapshot_units.id\narguments:   .\noutput:   .\nmethod: API  .\npath: API  .\nstatus:    .\ncreated_at:   .\nrespond_at: API   .","coupon#Coupon":"IHubCoupon\nIHubCouponCriteria\nIHubCouponCriteriaOfChannel\nIHubCouponCriteriaOfFunnel\nIHubCouponCriteriaOfSale\nIHubCouponCriteriaOfSection\nIHubCouponCriteriaOfSeller\nIHubCouponInventory\nIHubCouponTicket\nIHubCouponTicketPayment","hub_coupons#hub_coupons":" .hub_coupons      ., hub_coupons       ()   \r\n.      hub_coupon_tickets \r\n   hub_coupon_ticket_payments  \r\n,    .     ,  \r\n  .  \r\n   ,  \r\n     \r\n     .       \r\n,       .    ,      \r\n     .       ,\r\n         .         .Properties\nid:\nhub_customer_id:        hub_customers.id\nactor_type\n    .\r\nf\nseller: \nadministrator: \nname:    .\naccess\n     .\npublic:       \nprivate:   \n    \n    \nexclusive\n .  ,       ,  \r\n     . ,    \r\n,   \r\n ,     \r\n   .\nunit\n .     , \r\n \r\n1 ,        \r\n  .\namount:  \npercent: \nvalue\n .    0 ~ 100,     .\nthreshold\n    .  ,      ( )  \r\n     .    NULL ,  \r\n   .\nlimit\n   .  ,     ,    .\nvolume\n  .    ,      .,   N    .\nvolume_per_citizen\n1    .1     ,      \r\n1  ,     NULL    . N  ,       .\nexpired_in\n  .    , N    .    ,  N    .\nexpired_at\n  .    , YYYY-MM-DD    .hub_coupons.expired_in     .\nopened_at:   .\nclosed_at\n  .      .     \r\n   .\ncreated_at:   .\nupdated_at\n   .    .\ndeleted_at:    .","hub_coupon_criterias#hub_coupon_criterias":"      .hub_coupon_criterias        \r\n.          \r\n,   .  ,\r\n       \r\nhub_coupon_criteria_of_sections ,  \r\nhub_coupon_criterias   .    , direction    \r\n ,        .  direction \r\n\"include\" ,         ,\r\n direction  \"exclude\" ,     \r\n    .Properties\nid:\nhub_coupon_id:    hub_coupons.id\ntype\n  .   .\ndirection\n   .\ninclude:  \nexclude:  \nsequence:      .","hub_coupon_criteria_of_sections#hub_coupon_criteria_of_sections":"    .hub_coupon_criteria_of_sections  hub_coupon_criterias \r\n ,  hub_sections      . hub_coupon_criterias.direction  \"include\" \r\n     ,  \"exclude\"   \r\n .     \r\nhub_coupon_criteria_of_sections  ,    \r\n .           .Properties\nid:\nhub_section_id:    hub_coupon_criterias.id","hub_coupon_criteria_of_channels#hub_coupon_criteria_of_channels":"    .hub_coupon_criteria_of_channels  hub_coupon_criterias \r\n ,    \r\n      . hub_coupon_criterias.direction  \"include\" \r\n  ( )    ,  \"exclude\" \r\n   .     \r\nhub_coupon_criteria_of_channels  ,    \r\n .     ,     \r\n  .Properties\nid:\nhub_channel_id:   hub_channels.id\nhub_channel_category_id:    hub_channel_categories.id","hub_coupon_criteria_of_sellers#hub_coupon_criteria_of_sellers":"    .hub_coupon_criteria_of_sellers  hub_coupon_criterias \r\n ,      \r\n. hub_coupon_criterias.direction  \"include\" \r\n     ,  \"exclude\"  \r\n  .    \r\nhub_coupon_criteria_of_sellers  ,    \r\n .           .Properties\nid:\nhub_seller_id:   hub_sellers.id","hub_coupon_criteria_of_sales#hub_coupon_criteria_of_sales":"     .hub_coupon_criteria_of_sales  hub_coupon_criterias \r\n ,      \r\n. hub_coupon_criterias.direction  \"include\" \r\n     ,  \"exclude\"  \r\n  .    \r\nhub_coupon_criteria_of_sales  ,    \r\n .           .Properties\nid:\nhub_sale_id:   hub_sales.id","hub_coupon_criteria_of_funnels#hub_coupon_criteria_of_funnels":"    .hub_coupon_criteria_of_funnels  hub_coupon_criterias \r\n ,     \r\n      .      3   . \r\nhub_customers.referrer ,     \r\nhub_customers.href  ,  URL   \r\n .Properties\nid: PK + FK.\nkind\nWhat kind of funnel is it?\npath\nreferrer\nvariable\nkey:   , kind  \"variable\"   .\nvalue:   .","hub_coupon_tickets#hub_coupon_tickets":"    .hub_coupon_tickets        .         ,\r\n expired_at    ,      .\r\n,      \r\n,  .Properties\nid: Primary Key.\nhub_customer_id:   hub_customers.id\nhub_coupon_id:   hub_coupons.id\nhub_coupon_disposable_id\n   hub_coupon_disposables.id  private        .\ncreated_at:   .\nexpired_at:   .","hub_coupon_ticket_payments#hub_coupon_ticket_payments":"    () .hub_coupon_ticket_payments    \r\nhub_coupon_tickets   \r\n   ,  \r\n   \r\n      . hub_orders       ,\r\n        , \r\nhub_coupon_ticket_payments    \r\n   .   \r\n,      .,          ,\r\n       .Properties\nid: Primary Key.\nhub_coupon_ticket_id:   hub_coupon_tickets.id\nhub_order_id:   hub_orders.id\nsequence:     .\ncreated_at:   .","hub_coupon_disposables#hub_coupon_disposables":"    .          ,\r\n  ( )      ,\r\n  hub_coupon_disposables  .   \"\" . ,       ,\r\n    ,   .   \r\n       ,    \r\n    .Properties\nid: Primary Key.\nhub_coupon_id:    hub_coupons.id\ncode\n .  .\ncreated_at:   .\nexpired_at:    .","issue#Issue":"IHubOrderGoodIssue\nIHubOrderGoodIssueFee\nIHubOrderGoodIssueFeeAccept\nIHubOrderGoodIssueComment","hub_order_good_issues#hub_order_good_issues":"    .hub_order_good_issues  \r\n  \r\n  ,   \r\n      .   ,     ,  \r\n   .,           \r\n   .  ,  \r\n ,    \r\n  .,     ,     \r\n(closed_at)   . ,   ,   \r\n   ,       .Properties\nid: PK + FK.\nhub_order_good_id:    hub_order_goods.id\nhub_customer_id:    hub_customers.id\nactor_type\n  \ncustomer: \nseller: \nclosed_at:     ","hub_order_good_issue_comments#hub_order_good_issue_comments":"  .hub_order_good_issue_comments  bbs_article_comments  \r\n,    \r\n , \r\n    .   ,     .Properties\nid: PK + FK.\nhub_customer_id:    hub_customers.id\nactor_type\n   \ncustomer: \nseller: ","hub_order_good_issue_fees#hub_order_good_issue_fees":"    .HubOrderItemIssueFee ,   \r\n   ,\r\n   .  \r\n          .     \r\n,   ,        . \r\n    ,      \r\n  .Properties\nid:\nhub_order_good_issue_id:   hub_order_good_issues.id\nhub_customer_id:     hub_customers.id\nvalue:  .\ncreated_at:   .\ndeleted_at\n  .     .","hub_order_good_issue_fee_accepts#hub_order_good_issue_fee_accepts":"   .hub_order_good_issue_fee_accepts ,  \r\n , \r\n    .    ,         .\r\n,       ,     ,\r\n      ,      \r\n.Properties\nid:\nhub_order_good_issue_fee_id:\nhub_customer_id:    hub_customers.id\ncreated_at:   .\npublished_at:     .\ncancelled_at\n   .     ."}},"/tech-specs/meta/preface":{"title":"Preface","data":{"ai-chatbot#A.I. Chatbot":"\"Wrtn Studio Pro\" provides an A.I. chatbot service called \"Meta LLM\".The \"Meta LLM\" utilizes LLM (Large Language Model) function calling, and the functions come from the API marketplace sales which is following the OpenAPI specification. Also, when user wants to automate his/her chatting scenario as an automated program, \"Wrtn Studio Pro\" builds it a program function through the Workflow Compiler with SWL language.By the way, LLM function calling schema appears similar to the OpenAPI specification at first glance, but in reality the specifications are quite different. In such reason, \"Wrtn Studio Pro\" has a process of converting OpenAPI to LLM function calling schema, and at this time, it goes through an intermediate conversion process called Migration Schema.Also, \"Wrtn Studio Pro\" has adopted WebSocket protocol when developing the A.I. chatbot service. If explain the WebSocket protocol related story more detaily, \"Wrtn Studio Pro\" has adopted the RPC (Remote Procedure Call) paradigm. It is a structure in which the client and server participating in the chatbot remotely call the functions provided by each other.At last, when performing function call execution in the \"Meta LLM\", \"Wrtn Studio Pro\" separates the parameter arguments composition to both Humand and LLM sides. It's because some arguments must be composed by Human like file uploading or secret key identification.\nLLM Function CallingLLM selects proper function and fill arguments.In nowadays, most LLM (Large Language Model) like OpenAI are supporting \"function calling\" feature. The \"function calling\" means that LLM automatically selects a proper function and compose parameter values from the user's chatting text.https://platform.openai.com/docs/guides/function-calling","migration-schema#Migration Schema":"Intermediate structure for LLM function calling schema conversion.LLM function calling schema is different with OpenAPi specification. Therefore, \"Wrtn Studio Pro\" must convert the OpenAPI spefification to the LLM function calling schema. However, the conversion process is not direct, but through the intermediate structure called \"Migration Schema\".Purpose of the Migration Schema is to normalize parameters and responses of the OpenAPI operation. By providing the normalized definitions close to the RPC (Remote Procedure Call) function, \"Wrtn Studio Pro\" can safely convert to the LLM function calling schema from the OpenAPI document.\nIMigrateDocument\nIMigrateRoute","llm-schema#LLM Schema":"\"Wrtn Studio Pro\" has defined full specification of the LLM function calling schema.It has been converted from the OpenAPI specification bypass the migration process. The OpenAI function calling schema forms a RPC (Remote Procedure Call) structure that can be directly executed by the Meta LLM.Its type schema information is similar with OpenAPI v3.0 specification, but reference type does not exist. Therefore, if there's a recursive referrence type exists in an OpenAPI operation, the operation cannot be converted to the LLM function calling schema.Also, IOpenAiFunction's parameters are separated to two parts; Human and LLM. The Human part is composed by the user's input, and the LLM part is composed by the Meta LLM's output. The reason of such separation is, some parameter values must be composed by Human like file uploading or secret key identification.\nIOpenAiDocument\nIOpenAiFunction\nIOpenAiSchema","websocket-rpc#WebSocket RPC":"WebSocket protocol with RPC paradigm.\"Wrnt Studio Pro\" has adopted WebSocket protocol for the A.I. chatbot service. Also, accepting the WebSocket protocol, \"Wrtn Studio Pro\" is following the RPC (Remote Procedure Call) paradigm. By the RPC paradigm, the client and server participating in the A.I. chatbot are possible to remotely call the functions provided by each other.In the business logic level, the Meta LLM WebSocket server is providing IStudioMetaChatService interface to the client, so that client can remotely call and get return values from the IStudioMetaChatService instance composed by the server. Also, the client is providing IStudioMetaChatListener instance and many LLM function call executions are performed with it.\nRPC (Remote Procedure Call)\nIStudioMetaChatService\nIStudioMetaChatListener","function-call-execution#Function Call Execution":"Function call execution process.The function call execution is processed by utilizing every skills listed up to now, including WebSocket protocol with RPC (Remote Procedure Call) paradigm and function call arguments filling by both Human and LLM (Large Language Model) sides.When the Meta LLM service has been started and it has delivered function calling schemas to the LLM (Large Language Model), the conversation with Human and LLM begins and LLM sometimes selects a function to call, and then the function call execution story begins.\nUser talks something by chatting text.\nLLM analyzes the user text content.\nLLM selects a function, and server informs it to the client.\nLLM requests Human to type the arguments by chatting text\nUser fills the arguments by chatting text.\nServer requests clients to fill the Human side arguments.\nHuman fills the arguments by UI component (inspector).\nServer executes the function and informs the result."}},"/tech-specs/meta/migrate":{"title":"Migrate","data":{"concepts#Concepts":"Convert OpenAPI operations to migration schemas.Before converting OpenAPI operations to LLM function calling schemas, \"Wrtn Studio Pro\" transforms the OpenAPI operations to an intermediate structure. The intermediate structure is called migration schema, and normalizes parameters/reponses of the OpenAPI opertion.In other words, the migration schema is called to a helper schema for RPC (Remote Procedure Call) function conversion from OpenAPI operation. By providing noramlized definitions close to the RPC function, \"Wrtn Studio Pro\" can easily convert to the LLM function calling schema from the OpenAPI document.For example, migration schema forces path parameters to have their own names, and combines query/headers to be a single object. Also, separates the response body to success and exceptional cases, and provides a description comment for the RPC function.\nIMigrateDocument\nIMigrateRoute","document#Document":"/**\r\n * Document of migration.\r\n *\r\n * The `IMigrateDocument` interface is a document of migration from\r\n * {@link OpenAPI.IDocument OpenAPI document} to RPC (Remote Procedure Call)\r\n * functions; {@link IMigrateRoute}.\r\n *\r\n * As the `IMigrateDocument` and {@link IMigrateRoute} have a lot of special\r\n * stories, when you're developing OpenAPI generator library, please read\r\n * their descriptions carefully including the description of properties.\r\n */\r\nexport interface IMigrateDocument<\r\n  Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\r\n  Operation extends OpenApi.IOperation<Schema> = OpenApi.IOperation<Schema>,\r\n> {\r\n  /**\r\n   * List of routes for migration.\r\n   */\r\n  routes: IMigrateRoute<Schema, Operation>[];\r\n\r\n  /**\r\n   * List of errors occurred during the migration.\r\n   */\r\n  errors: IMigrateDocument.IError<Operation>[];\r\n}\r\nexport namespace IMigrateDocument {\r\n  /**\r\n   * Error of migration in the operation level.\r\n   */\r\n  export interface IError<\r\n    Operation extends\r\n      OpenApi.IOperation<any> = OpenApi.IOperation<OpenApi.IJsonSchema>,\r\n  > {\r\n    /**\r\n     * Target operation causing the error.\r\n     */\r\n    operation: () => Operation;\r\n\r\n    /**\r\n     * Method of the operation.\r\n     *\r\n     * If the {@link OpenApi.IOperation.method} is not one of below type\r\n     * values, the operation would be ignored in the migration process for\r\n     * the RPC (Remote Procedure Call) function.\r\n     */\r\n    method: \"head\" | \"get\" | \"post\" | \"put\" | \"patch\" | \"delete\";\r\n\r\n    /**\r\n     * Original path from the OpenAPI document.\r\n     */\r\n    path: string;\r\n\r\n    /**\r\n     * List of error messages (reasons).\r\n     */\r\n    messages: string[];\r\n  }\r\n}\nMigration document contains only two properties.The first property is routes, a list of route schemas that has been succesfully normalized from the OpenAPI operations. The other property is errors, a list of target operation and its error messages occured in the normalization process.For reference, the normalization error means that the target OpenAPI operation is not suitable for the migration process. Here is the list of reasons why the operation could be failed to normalize in the migration process:\nContent type is not supported. Here is the list of supported content types:\nRequest Body\napplication/json\napplication/x-www-form-urlencoded\nmultipart/form-data\ntext/plain\nResponse Body\napplication/json\napplication/x-www-form-urlencoded\ntext/plain\nHeaders or query parameter cannot be combined as an object\nPath parameters is not separated to atomic values\nNumber of path parameters is not matched with the path","route#Route":"import { OpenApi } from \"./OpenApi\";\r\n\r\n/**\r\n * Route information for migration.\r\n *\r\n * The `IMigrateRoute` is a structure representing a route information for\r\n * OpenAPI generated RPC (Remote Procedure Call) function composed from the\r\n * {@link OpenApi.IOperation OpenAPI operation}.\r\n *\r\n * As the `IMigrateRoute` has a lot of speical stories, when you're developing\r\n * OpenAPI generator library, please read its description carefully including\r\n * the description of its properties.\r\n */\r\nexport interface IMigrateRoute<\r\n  Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\r\n  Operation extends OpenApi.IOperation<Schema> = OpenApi.IOperation<Schema>,\r\n> {\r\n  /**\r\n   * Method of the route.\r\n   *\r\n   * If the {@link OpenApi.IOperation.method} is not one of below type\r\n   * values, the operation would be ignored in the migration process for\r\n   * the RPC (Remote Procedure Call) function.\r\n   */\r\n  method: \"head\" | \"get\" | \"post\" | \"put\" | \"patch\" | \"delete\";\r\n\r\n  /**\r\n   * Original path from the OpenAPI document.\r\n   */\r\n  path: string;\r\n\r\n  /**\r\n   * Emended path for OpenAPI generator libraries.\r\n   *\r\n   * The difference between {@link path} is:\r\n   *\r\n   * 1. Path parameters are replaced with `:param` format.\r\n   * 2. Empty sub-paths are removed.\r\n   * 3. Do not starts with `/`.\r\n   */\r\n  emendedPath: string;\r\n\r\n  /**\r\n   * Accessor for the route.\r\n   *\r\n   * The `accessor` is a list of string values that are representing how to\r\n   * access to the OpenAPI generated RPC (Remote Procedure Call) function\r\n   * through namespace(s).\r\n   *\r\n   * The `accessor` is composed with the following rules. At first, namespaces\r\n   * are composed by static directory names in the {@link path}. Parametric\r\n   * symbols represented by `:param` or `{param}` cannot be a part of the\r\n   * namespace.\r\n   *\r\n   * Instead, they would be a part of the function name. The function\r\n   * name is composed with the {@link method HTTP method} and parametric symbols\r\n   * like `getByParam` or `postByParam`. If there are multiple path parameters,\r\n   * they would be concatenated by `And` like `getByParam1AndParam2`.\r\n   *\r\n   * For refefence, if the {@link operation}'s {@link method} is `delete`, the\r\n   * function name would be replaced to `erase` instead of `delete`. It is\r\n   * the reason why the `delete` is a reserved keyword in many programming\r\n   * languages.\r\n   *\r\n   * - Example 1\r\n   *   - path: `POST /shopping/sellers/sales`\r\n   *   - accessor: `shopping.sellers.sales.post`\r\n   * - Example 2\r\n   *   - endpoint: `GET /shoppings/sellers/sales/:saleId/reviews/:reviewId/comments/:id\r\n   *   - accessor: `shoppings.sellers.sales.reviews.getBySaleIdAndReviewIdAndCommentId`\r\n   */\r\n  accessor: string[];\r\n\r\n  /**\r\n   * List of path parameters.\r\n   *\r\n   * Note that, not a list of every parameters, but only path parameters.\r\n   */\r\n  parameters: IMigrateRoute.IParameter<Schema>[];\r\n\r\n  /**\r\n   * Metadata of headers.\r\n   *\r\n   * The `headers` property is a metadata of HTTP request headers for RPC function,\r\n   * including the parameter variable name and schema.\r\n   *\r\n   * Also, its {@link IMigrateRoute.IHeaders.schema} is always object or reference\r\n   * to object. Even though the original {@link OpenApi.IOperation OpenAPI operation}'s\r\n   * headers are separated to atomic typed properties, the `headers` property forcibly\r\n   * combines them into a single object type.\r\n   *\r\n   * For reference, if the `headers` property has been converted to an object type\r\n   * forcibly, its property {@link IMigrateRoute.IHeaders.name name} and\r\n   * {@link IMigrateRoute.IHeaders.key key} are always \"headers\".\r\n   */\r\n  headers: IMigrateRoute.IHeaders<Schema> | null;\r\n\r\n  /**\r\n   * Metadata of query values.\r\n   *\r\n   * The `query` property is a metadata of HTTP request query values for RPC function,\r\n   * including the parameter variable name and schema.\r\n   *\r\n   * Also, its {@link IMigrateRoute.IQuery.schema} is always object or reference\r\n   * to object. Even though the original {@link OpenApi.IOperation OpenAPI operation}'s\r\n   * query parameters are separated to atomic typed properties, the `query` property\r\n   * forcibly combines them into a single object type.\r\n   *\r\n   * For reference, if the `query` property has been converted to an object type\r\n   * forcibly, its property {@link IMigrateRoute.IQuery.name name} and\r\n   * {@link IMigrateRoute.IQuery.key key} are always \"headers\".\r\n   */\r\n  query: IMigrateRoute.IQuery<Schema> | null;\r\n\r\n  /**\r\n   * Metadata of request body.\r\n   *\r\n   * The `body` property is a metadata of HTTP request body for RPC function,\r\n   * including the parameter variable name, content type, and schema.\r\n   *\r\n   * If the `body` property is `null`, it means the operation does not require\r\n   * the request body data.\r\n   */\r\n  body: IMigrateRoute.IBody<Schema> | null;\r\n\r\n  /**\r\n   * Metadata of response body for success case.\r\n   *\r\n   * The `success` property is a metadata of HTTP response body for RPC function,\r\n   * including content type, and schema when status code is `200` or `201`.\r\n   *\r\n   * If the `success` property is `null`, it means the operation does not have\r\n   * the response body data. In other words, the RPC function would return `void`.\r\n   */\r\n  success: IMigrateRoute.IBody<Schema> | null;\r\n\r\n  /**\r\n   * Metadata of response body for exceptional status cases.\r\n   *\r\n   * The `exceptions` property is a metadata of HTTP response body for RPC\r\n   * function, including content type, and schema when status code is not `200`\r\n   * or `201`.\r\n   *\r\n   * The key of the `exceptions` property is the status code. It may be a\r\n   * stringified number, but sometimes it could be a string like \"default\",\r\n   * because the OpenAPI document allows the status code to be a string.\r\n   */\r\n  exceptions: Record<string, IMigrateRoute.IException<Schema>>;\r\n\r\n  /**\r\n   * Description comment for the route function.\r\n   *\r\n   * The `comment` is a function returning description comment for the\r\n   * RPC function of OpenAPI generated. The comment is composed with the\r\n   * following rules:\r\n   *\r\n   * 1. Starts from the {@link OpenApi.IOperation.summary} paragraph.\r\n   * 2. The next paragraphs are filled with {@link OpenApi.IOperation.description}.\r\n   * 3. Parameter descriptions are added with `@param` tag.\r\n   * 4. Security requirements are added with `@security` tag.\r\n   * 5. Tag names are added with `@tag` tag.\r\n   * 6. If {@link OpenApi.IOperation.deprecated}, `@deprecated` tag is added.\r\n   */\r\n  comment: () => string;\r\n\r\n  /**\r\n   * Original operation from the OpenAPI document.\r\n   *\r\n   * The `operation` is a function returning the original\r\n   * {@link OpenApi.IOperation} from the {@link OpenAPI} document.\r\n   */\r\n  operation: () => Operation;\r\n}\r\nexport namespace IMigrateRoute {\r\n  /**\r\n   * Metadata of path parameter.\r\n   */\r\n  export interface IParameter<\r\n    Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\r\n  > {\r\n    /**\r\n     * Name of the path parameter.\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * Key of the path parameter.\r\n     */\r\n    key: string;\r\n\r\n    /**\r\n     * Metadata of path parameter data type.\r\n     */\r\n    schema: Schema;\r\n\r\n    /**\r\n     * Original parameter info from the OpenAPI document.\r\n     *\r\n     * The `parameter` is a function returning the original\r\n     * {@link OpenApi.IOperation.IParameter} from the {@link OpenAPI} document.\r\n     */\r\n    parameter: () => OpenApi.IOperation.IParameter<Schema>;\r\n  }\r\n\r\n  /**\r\n   * Metadata of headers.\r\n   */\r\n  export interface IHeaders<\r\n    Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\r\n  > {\r\n    /**\r\n     * Name of the headers parameter.\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * Key of the headers parameter.\r\n     */\r\n    key: string;\r\n\r\n    /**\r\n     * Metadata of headers data type.\r\n     */\r\n    schema: Schema;\r\n    title: () => string | undefined;\r\n    description: () => string | undefined;\r\n    example: () => any | undefined;\r\n    examples: () => Record<string, any> | undefined;\r\n  }\r\n\r\n  /**\r\n   * Metadata of query values.\r\n   */\r\n  export interface IQuery<\r\n    Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\r\n  > {\r\n    name: string;\r\n    key: string;\r\n    schema: Schema;\r\n    title: () => string | undefined;\r\n    description: () => string | undefined;\r\n    example: () => any | undefined;\r\n    examples: () => Record<string, any> | undefined;\r\n  }\r\n\r\n  /**\r\n   * Metadata of request/response body.\r\n   */\r\n  export interface IBody<\r\n    Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\r\n  > {\r\n    /**\r\n     * Name of the body parameter.\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * Key of the body parameter.\r\n     */\r\n    key: string;\r\n\r\n    /**\r\n     * Content type of the body.\r\n     */\r\n    type:\r\n      | \"text/plain\"\r\n      | \"application/json\"\r\n      | \"application/x-www-form-urlencoded\"\r\n      | \"multipart/form-data\";\r\n\r\n    /**\r\n     * Metadata of response body data type.\r\n     */\r\n    schema: Schema;\r\n\r\n    /**\r\n     * Description comment for the request/response body.\r\n     */\r\n    description: () => string | undefined;\r\n\r\n    /**\r\n     * Media type of the request/response body.\r\n     */\r\n    media: () => OpenApi.IOperation.IMediaType<Schema>;\r\n\r\n    /**\r\n     * Whether the body is encrypted or not.\r\n     */\r\n    \"x-nestia-encrypted\"?: boolean;\r\n  }\r\n\r\n  /**\r\n   * Metadata of response body for exceptional status cases.\r\n   */\r\n  export interface IException<\r\n    Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\r\n  > {\r\n    /**\r\n     * Metadata of response body data type.\r\n     */\r\n    schema: Schema;\r\n\r\n    /**\r\n     * Description comment for the exception.\r\n     */\r\n    response: () => OpenApi.IOperation.IResponse<Schema>;\r\n\r\n    /**\r\n     * Media type of the response body.\r\n     */\r\n    media: () => OpenApi.IOperation.IMediaType<Schema>;\r\n  }\r\n}","description-comment#Description Comment":"When transforming OpenAPI operation to migration schema, description is composed by follwing rules.For reference, the description comment is very important to teach the purpose of the OpenAPI operation to the LLM (Large Language Model), and LLM actually determines which operation to call by the description. Therefore, the description has the highest priority.\nStarts from the summary paragraph of the OpenAPI operation.\nThe next paragraphs are filled with the OpenApi.IOperation.description. By the way, if the first paragraph of description is same with the summary, it would not be duplicated.\nParameters' descriptions are added with @param tag.\nSecurity requirements (OpenApi.IOperation.security) are added with @security tag.\nTag names are added with @tag tag.\nIf OpenApi.IOperation.deprecated, @deprecated tag is added.","path-parameters#Path Parameters":"export interface IMigrateRoute<\r\n  Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\r\n  Operation extends OpenApi.IOperation<Schema> = OpenApi.IOperation<Schema>,\r\n> {\r\n  /**\r\n   * List of path parameters.\r\n   *\r\n   * Note that, not a list of every parameters, but only path parameters.\r\n   */\r\n  parameters: IMigrateRoute.IParameter<Schema>[];\r\n}\r\nexport namespace IMigrateRoute {\r\n  /**\r\n   * Metadata of path parameter.\r\n   */\r\n  export interface IParameter<\r\n    Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\r\n  > {\r\n    /**\r\n     * Name of the path parameter.\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * Key of the path parameter.\r\n     */\r\n    key: string;\r\n\r\n    /**\r\n     * Metadata of path parameter data type.\r\n     */\r\n    schema: Schema;\r\n\r\n    /**\r\n     * Original parameter info from the OpenAPI document.\r\n     *\r\n     * The `parameter` is a function returning the original\r\n     * {@link OpenApi.IOperation.IParameter} from the {@link OpenAPI} document.\r\n     */\r\n    parameter: () => OpenApi.IOperation.IParameter<Schema>;\r\n  }\r\n}\nexport namespace OpenApi {\r\n  export namespace IOperation {\r\n    /**\r\n     * Parameter of the operation.\r\n     */\r\n    export interface IParameter<Schema extends IJsonSchema = IJsonSchema> {\r\n      /**\r\n       * Representative name of the parameter.\r\n       *\r\n       * In the most case, the `name` is equivalent to parameter variable name.\r\n       * Therefore, the `name` must be filled with the significant variable name\r\n       * of the parameter.\r\n       *\r\n       * By the way, only when the {@link in} property is `path`, the `name`\r\n       * can be omitted. In that case, the `name` is automatically deduced from\r\n       * the URL path's positional template argument analyzing.\r\n       */\r\n      name?: string;\r\n\r\n      /**\r\n       * Location of the parameter.\r\n       *\r\n       * The `in` property is a string that determines the location of the parameter.\r\n       *\r\n       * - `path`: parameter is part of the path of the URL.\r\n       * - `query`: parameter is part of the query string.\r\n       * - `header`: parameter is part of the header.\r\n       * - `cookie`: parameter is part of the cookie.\r\n       */\r\n      in: \"path\" | \"query\" | \"header\" | \"cookie\";\r\n\r\n      /**\r\n       * Type info of the parameter.\r\n       */\r\n      schema: Schema;\r\n\r\n      /**\r\n       * Whether the parameter is required for execution or not.\r\n       *\r\n       * If the parameter is required, the value must be filled. Otherwise,\r\n       * it is possible to skip the parameter when executing the APi operation.\r\n       *\r\n       * For reference, the `required` property must be always `true` when the\r\n       * {@link in} property is `path`. Otherwise, the `required` property can\r\n       * be anything of them; `true`, `false` and `undefined`.\r\n       */\r\n      required?: boolean;\r\n\r\n      /**\r\n       * Short title of the parameter.\r\n       */\r\n      title?: string;\r\n\r\n      /**\r\n       * Verbose explanation of the parameter.\r\n       */\r\n      description?: string;\r\n\r\n      /**\r\n       * Example value of the parameter.\r\n       */\r\n      example?: any;\r\n\r\n      /**\r\n       * Collection of example values of the parameter with keys.\r\n       */\r\n      examples?: Record<string, IExample>;\r\n    }\r\n  }\r\n}\nNaming emension.Following the OpenAPI specification, it is possible to omit the path parameter name (IOpenApi.IOperation.IParameter.name) in the operation schema. Furthermore, it is possible to configuring the path parameter to be optional (IOpenApi.IOperation.IParameter.required).However, as the migration schema has been designed for conversion to the RPC (Remote Procedure Call) function implementation, the parameter name must be. Also, considerinng the aspects of the RestAPI, path parameter cannot be optional.Considering such aspects, the migration process forces the path parameter to have its own name and to be required. If the OpenApi.IOperation.IParameter.name is not defined, the migration process automatically deduces the name from the URL path's positional template argument analyzing.In the same reason, if path parameter name and actual operation's path is not matched, the migration process will emend the path parameter name by referencing the sequence of the path parameter in the URL path. Also, if path parameter name is out of variable name scope in the programming language, migration process also emends it to be a valid variable name.","headers-and-query#Headers and Query":"export interface IMigrateRoute<\r\n  Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\r\n  Operation extends OpenApi.IOperation<Schema> = OpenApi.IOperation<Schema>,\r\n> {\r\n  /**\r\n   * Metadata of headers.\r\n   *\r\n   * The `headers` property is a metadata of HTTP request headers for RPC function,\r\n   * including the parameter variable name and schema.\r\n   *\r\n   * Also, its {@link IMigrateRoute.IHeaders.schema} is always object or reference\r\n   * to object. Even though the original {@link OpenApi.IOperation OpenAPI operation}'s\r\n   * headers are separated to atomic typed properties, the `headers` property forcibly\r\n   * combines them into a single object type.\r\n   *\r\n   * For reference, if the `headers` property has been converted to an object type\r\n   * forcibly, its property {@link IMigrateRoute.IHeaders.name name} and\r\n   * {@link IMigrateRoute.IHeaders.key key} are always \"headers\".\r\n   */\r\n  headers: IMigrateRoute.IHeaders<Schema> | null;\r\n\r\n  /**\r\n   * Metadata of query values.\r\n   *\r\n   * The `query` property is a metadata of HTTP request query values for RPC function,\r\n   * including the parameter variable name and schema.\r\n   *\r\n   * Also, its {@link IMigrateRoute.IQuery.schema} is always object or reference\r\n   * to object. Even though the original {@link OpenApi.IOperation OpenAPI operation}'s\r\n   * query parameters are separated to atomic typed properties, the `query` property\r\n   * forcibly combines them into a single object type.\r\n   *\r\n   * For reference, if the `query` property has been converted to an object type\r\n   * forcibly, its property {@link IMigrateRoute.IQuery.name name} and\r\n   * {@link IMigrateRoute.IQuery.key key} are always \"headers\".\r\n   */\r\n  query: IMigrateRoute.IQuery<Schema> | null;\r\n}\r\nexport namespace IMigrateRoute {\r\n  /**\r\n   * Metadata of headers.\r\n   */\r\n  export interface IHeaders<\r\n    Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\r\n  > {\r\n    /**\r\n     * Name of the headers parameter.\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * Key of the headers parameter.\r\n     */\r\n    key: string;\r\n\r\n    /**\r\n     * Metadata of headers data type.\r\n     */\r\n    schema: Schema;\r\n    title: () => string | undefined;\r\n    description: () => string | undefined;\r\n    example: () => any | undefined;\r\n    examples: () => Record<string, any> | undefined;\r\n  }\r\n\r\n  /**\r\n   * Metadata of query values.\r\n   */\r\n  export interface IQuery<\r\n    Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\r\n  > {\r\n    name: string;\r\n    key: string;\r\n    schema: Schema;\r\n    title: () => string | undefined;\r\n    description: () => string | undefined;\r\n    example: () => any | undefined;\r\n    examples: () => Record<string, any> | undefined;\r\n  }\r\n}\nexport namespace OpenApi {\r\n  export namespace IOperation {\r\n    /**\r\n     * Parameter of the operation.\r\n     */\r\n    export interface IParameter<Schema extends IJsonSchema = IJsonSchema> {\r\n      /**\r\n       * Representative name of the parameter.\r\n       *\r\n       * In the most case, the `name` is equivalent to parameter variable name.\r\n       * Therefore, the `name` must be filled with the significant variable name\r\n       * of the parameter.\r\n       *\r\n       * By the way, only when the {@link in} property is `path`, the `name`\r\n       * can be omitted. In that case, the `name` is automatically deduced from\r\n       * the URL path's positional template argument analyzing.\r\n       */\r\n      name?: string;\r\n\r\n      /**\r\n       * Location of the parameter.\r\n       *\r\n       * The `in` property is a string that determines the location of the parameter.\r\n       *\r\n       * - `path`: parameter is part of the path of the URL.\r\n       * - `query`: parameter is part of the query string.\r\n       * - `header`: parameter is part of the header.\r\n       * - `cookie`: parameter is part of the cookie.\r\n       */\r\n      in: \"path\" | \"query\" | \"header\" | \"cookie\";\r\n\r\n      /**\r\n       * Type info of the parameter.\r\n       */\r\n      schema: Schema;\r\n\r\n      /**\r\n       * Whether the parameter is required for execution or not.\r\n       *\r\n       * If the parameter is required, the value must be filled. Otherwise,\r\n       * it is possible to skip the parameter when executing the APi operation.\r\n       *\r\n       * For reference, the `required` property must be always `true` when the\r\n       * {@link in} property is `path`. Otherwise, the `required` property can\r\n       * be anything of them; `true`, `false` and `undefined`.\r\n       */\r\n      required?: boolean;\r\n\r\n      /**\r\n       * Short title of the parameter.\r\n       */\r\n      title?: string;\r\n\r\n      /**\r\n       * Verbose explanation of the parameter.\r\n       */\r\n      description?: string;\r\n\r\n      /**\r\n       * Example value of the parameter.\r\n       */\r\n      example?: any;\r\n\r\n      /**\r\n       * Collection of example values of the parameter with keys.\r\n       */\r\n      examples?: Record<string, IExample>;\r\n    }\r\n  }\r\n}\nTo be a single object.Considering the HTTP specification of headers and query parameters, they are always a key-value paired object. However, in the OpenAPI specification, it is possible to define headers and query parameters as separated parameters with their property names.In the migration process, the headers and query parameters are forcibly combined to be a single object. Their object casted name is always \"headers\" and \"query\" respectively, and archived into the IMigrateRoute.headers and IMigrateRoute.query properties.If no headers or query parameters in the OpenAPI operation, these properties would be null.","requestresponse-body#Request/Response Body":"export interface IMigrateRoute<\r\n  Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\r\n  Operation extends OpenApi.IOperation<Schema> = OpenApi.IOperation<Schema>,\r\n> {\r\n  /**\r\n   * Metadata of request body.\r\n   *\r\n   * The `body` property is a metadata of HTTP request body for RPC function,\r\n   * including the parameter variable name, content type, and schema.\r\n   *\r\n   * If the `body` property is `null`, it means the operation does not require\r\n   * the request body data.\r\n   */\r\n  body: IMigrateRoute.IBody<Schema> | null;\r\n\r\n  /**\r\n   * Metadata of response body for success case.\r\n   *\r\n   * The `success` property is a metadata of HTTP response body for RPC function,\r\n   * including content type, and schema when status code is `200` or `201`.\r\n   *\r\n   * If the `success` property is `null`, it means the operation does not have\r\n   * the response body data. In other words, the RPC function would return `void`.\r\n   */\r\n  success: IMigrateRoute.IBody<Schema> | null;\r\n\r\n  /**\r\n   * Metadata of response body for exceptional status cases.\r\n   *\r\n   * The `exceptions` property is a metadata of HTTP response body for RPC\r\n   * function, including content type, and schema when status code is not `200`\r\n   * or `201`.\r\n   *\r\n   * The key of the `exceptions` property is the status code. It may be a\r\n   * stringified number, but sometimes it could be a string like \"default\",\r\n   * because the OpenAPI document allows the status code to be a string.\r\n   */\r\n  exceptions: Record<string, IMigrateRoute.IException<Schema>>;\r\n}\r\nexport namespace IMigrateRoute {\r\n  /**\r\n   * Metadata of request/response body.\r\n   */\r\n  export interface IBody<\r\n    Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\r\n  > {\r\n    /**\r\n     * Name of the body parameter.\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * Key of the body parameter.\r\n     */\r\n    key: string;\r\n\r\n    /**\r\n     * Content type of the body.\r\n     */\r\n    type:\r\n      | \"text/plain\"\r\n      | \"application/json\"\r\n      | \"application/x-www-form-urlencoded\"\r\n      | \"multipart/form-data\";\r\n\r\n    /**\r\n     * Metadata of response body data type.\r\n     */\r\n    schema: Schema;\r\n\r\n    /**\r\n     * Description comment for the request/response body.\r\n     */\r\n    description: () => string | undefined;\r\n\r\n    /**\r\n     * Media type of the request/response body.\r\n     */\r\n    media: () => OpenApi.IOperation.IMediaType<Schema>;\r\n\r\n    /**\r\n     * Whether the body is encrypted or not.\r\n     */\r\n    \"x-nestia-encrypted\"?: boolean;\r\n  }\r\n\r\n  /**\r\n   * Metadata of response body for exceptional status cases.\r\n   */\r\n  export interface IException<\r\n    Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\r\n  > {\r\n    /**\r\n     * Metadata of response body data type.\r\n     */\r\n    schema: Schema;\r\n\r\n    /**\r\n     * Description comment for the exception.\r\n     */\r\n    response: () => OpenApi.IOperation.IResponse<Schema>;\r\n\r\n    /**\r\n     * Media type of the response body.\r\n     */\r\n    media: () => OpenApi.IOperation.IMediaType<Schema>;\r\n  }\r\n}\nexport namespace OpenApi {\r\n  export interface IOperation<Schema extends IJsonSchema = IJsonSchema> {\r\n    /**\r\n     * The request body applicable for this operation.\r\n     */\r\n    requestBody?: IOperation.IRequestBody<Schema>;\r\n\r\n    /**\r\n     * The list of possible responses as they are returned from executing this\r\n     * operation. Its key is the HTTP status code, and the value is the metadata of\r\n     * the response in the HTTP status code.\r\n     */\r\n    responses?: Record<string, IOperation.IResponse<Schema>>;\r\n  }\r\n  export namespace IOperation {\r\n    /**\r\n     * Request body of the operation.\r\n     */\r\n    export interface IRequestBody<Schema extends IJsonSchema = IJsonSchema> {\r\n      content?: IContent<Schema>;\r\n      description?: string;\r\n      required?: boolean;\r\n      \"x-nestia-encrypted\"?: boolean;\r\n    }\r\n\r\n    /**\r\n     * Response of the operation.\r\n     */\r\n    export interface IResponse<Schema extends IJsonSchema = IJsonSchema> {\r\n      headers?: Record<string, IOperation.IParameter<Schema>>;\r\n      content?: IContent<Schema>;\r\n      description?: string;\r\n      \"x-nestia-encrypted\"?: boolean;\r\n    }\r\n\r\n    /**\r\n     * List of content types supported in request/response body.\r\n     */\r\n    export interface IContent<Schema extends IJsonSchema = IJsonSchema>\r\n      extends Partial<Record<ContentType, IMediaType<Schema>>> {}\r\n\r\n    /**\r\n     * Media type of a request/response body.\r\n     */\r\n    export interface IMediaType<Schema extends IJsonSchema = IJsonSchema> {\r\n      schema?: Schema;\r\n      example?: any;\r\n      examples?: Record<string, IExample>;\r\n    }\r\n\r\n    /**\r\n     * List of supported content media types.\r\n     */\r\n    export type ContentType =\r\n      | \"text/plain\"\r\n      | \"application/json\"\r\n      | \"application/x-www-form-url-encoded\"\r\n      | \"multipart/form-data\"\r\n      | \"*/*\"\r\n      | (string & {});\r\n  }\r\n}\nTo normalize the OpenAPI operation to be function like structure, the migration process separates the response body to success and exceptional cases. Also, remains only one representative content type for the request and response body.The distinction between the successive return type and exception throwing comes from its status code. For the \"POST\" HTTP method, \"201\" status code directs the return type, and the other status codes mean failures. For other HTTP methods, 200 status code means the success.If your HTTP operation does not follow the standard status code specification, I'm sorry but there is no way. Justturn back with the standard specification following.","accessor#Accessor":"export interface IMigrateRoute<\r\n  Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\r\n  Operation extends OpenApi.IOperation<Schema> = OpenApi.IOperation<Schema>,\r\n> {\r\n  /**\r\n   * Accessor for the route.\r\n   *\r\n   * The `accessor` is a list of string values that are representing how to\r\n   * access to the OpenAPI generated RPC (Remote Procedure Call) function\r\n   * through namespace(s).\r\n   *\r\n   * The `accessor` is composed with the following rules. At first, namespaces\r\n   * are composed by static directory names in the {@link path}. Parametric\r\n   * symbols represented by `:param` or `{param}` cannot be a part of the\r\n   * namespace.\r\n   *\r\n   * Instead, they would be a part of the function name. The function\r\n   * name is composed with the {@link method HTTP method} and parametric symbols\r\n   * like `getByParam` or `postByParam`. If there are multiple path parameters,\r\n   * they would be concatenated by `And` like `getByParam1AndParam2`.\r\n   *\r\n   * For refefence, if the {@link operation}'s {@link method} is `delete`, the\r\n   * function name would be replaced to `erase` instead of `delete`. It is\r\n   * the reason why the `delete` is a reserved keyword in many programming\r\n   * languages.\r\n   *\r\n   * - Example 1\r\n   *   - path: `POST /shopping/sellers/sales`\r\n   *   - accessor: `shopping.sellers.sales.post`\r\n   * - Example 2\r\n   *   - endpoint: `GET /shoppings/sellers/sales/:saleId/reviews/:reviewId/comments/:id\r\n   *   - accessor: `shoppings.sellers.sales.reviews.getBySaleIdAndReviewIdAndCommentId`\r\n   */\r\n  accessor: string[];\r\n}\nNamespace composition for RPC function conversion.IMigrateRoute.accessor is a list of string values that are representing how to access to the OpenAPI generated RPC (Remote Procedure Call) function through namespace(s). The namespace is composed by static directory names in the API path. If the API path contains parametric symbols like :param or {param}, they would be excluded from the namespace composition.By the way, as IMigrateRoute has been desinged to help conversion from OpenAPI operation to RPC (Remote Procedure Call) function  and the accessor property represents namespace of the RPC function, every string values in the accessor array are valid variable name in the programming language. If the OpenAPI defined path parameter names are not suitable for the variable name, the migration process replaces the parameter names to be a valid variable name."}},"/tech-specs/meta/schema":{"title":"Schema","data":{"summary#Summary":"Full specification of the LLM function calling schema.You know what? In nowadays, most LLM (Large Language Model) like OpenAI are supporting \"function calling\" feature, and the \"function calling\" means that LLM automatically selects a proper function and compose parameter values from the user's chatting text.\"Wrtn Studio Pro\" has defined full specification of such LLM function calling schema, which is converted from the OpenAPI specification bypass the migration process. The function calling schema embodies an RPC (Remote Procedure Call) structure which can be directly executed by the Meta LLM, and contains metadata information for the function call such as function name description.\nOpenAI function calling guide: https://platform.openai.com/docs/guides/function-calling\nSchema definitions:\nIOpenAiDocument\nIOpenAiFunction\nIOpenAiSchema","document#Document":"/**\r\n * Document of OpenAI function call metadata.\r\n *\r\n * `IOpenAiDocument` is a data structure representing content of\r\n * {@link IOpenAiDocument.functions OpenAI function call metadata}, composed by\r\n * {@link OpenAiComposer} from the {@link ISwagger} document, with\r\n * {@link IOpenAiDocument.errors} and adjusted {@link IOpenAiDocument.options}.\r\n *\r\n * The different between `IOpenAiDocument` and its origin source {@link ISwagger}\r\n * is, `IOpenAiDocument` has converted every {@link ISwaggerOperation API endpoints}\r\n * to {@link IOpenAiFunction function metadata}. You can execute the function call\r\n * with OpenAI constructed arguments by using the {@link OpenAiFetcher.execute}\r\n * function with the function metadata.\r\n *\r\n * Also, every type schema informations are casted from {@link ISwaggerSchema} to\r\n * {@link IOpenAiSchema} to escape {@link ISwaggerSchema.IReference reference types},\r\n * and downgrade the version of the JSON schema to OpenAPI 3.0. It's because\r\n * OpenAI function call feature cannot understand both reference types and\r\n * OpenAPI 3.1 specification.\r\n *\r\n * Additionally, if you've composed `IOpenAiDocument` with\r\n * {@link IOpenAiDocument.IOptions.keyword} configuration (as `true`), number of\r\n * {@link IOpenAiFunction.parameters} are always 1 and the first parameter's type is\r\n * always {@link IOpenAiSchema.IObject}. The properties' rule is:\r\n *\r\n * - `pathParameters`: Path parameters of {@link ISwaggerMigrateRoute.parameters}\r\n * - `query`: Query parameter of {@link ISwaggerMigrateRoute.query}\r\n * - `body`: Body parameter of {@link ISwaggerMigrateRoute.body}\r\n *\r\n * ```typescript\r\n * {\r\n *   ...pathParameters,\r\n *   query,\r\n *   body,\r\n * }\r\n * ```\r\n *\r\n * Otherwise, the parameters would be multiple, and the sequence of the parameters\r\n * are following below rules:\r\n *\r\n * ```typescript\r\n * [\r\n *   ...pathParameters,\r\n *   ...(query ? [query] : []),\r\n *   ...(body ? [body] : []),\r\n * ]\r\n * ```\r\n */\r\nexport interface IOpenAiDocument {\r\n  /**\r\n   * Version of OpenAPI.\r\n   *\r\n   * OpenAI function call schemas are based on OpenAPI 3.0.3.\r\n   */\r\n  openapi: \"3.0.3\";\r\n\r\n  /**\r\n   * List of function metadata.\r\n   *\r\n   * List of function metadata that can be used for the OpenAI function call.\r\n   *\r\n   * When you want to execute the function with OpenAI constructed arguments,\r\n   * you can do it through {@link OpenAiFetcher.execute} function.\r\n   */\r\n  functions: IOpenAiFunction[];\r\n\r\n  /**\r\n   * List of errors occurred during the composition.\r\n   */\r\n  errors: IOpenAiDocument.IError[];\r\n\r\n  /**\r\n   * Options for the document.\r\n   *\r\n   * Adjusted options when composing the document through {@link OpenAiComposer}.\r\n   */\r\n  options: IOpenAiDocument.IOptions;\r\n}\r\nexport namespace IOpenAiDocument {\r\n  /**\r\n   * Error occurred in the composition.\r\n   */\r\n  export interface IError {\r\n    /**\r\n     * HTTP method of the endpoint.\r\n     */\r\n    method: \"get\" | \"post\" | \"put\" | \"patch\" | \"delete\" | \"head\";\r\n\r\n    /**\r\n     * Path of the endpoint.\r\n     */\r\n    path: string;\r\n\r\n    /**\r\n     * Error messsages.\r\n     */\r\n    messages: string[];\r\n\r\n    /**\r\n     * Get the Swagger operation metadata.\r\n     *\r\n     * Get the Swagger operation metadata, of the source.\r\n     */\r\n    operation: () => ISwaggerOperation;\r\n\r\n    /**\r\n     * Get the migration route metadata.\r\n     *\r\n     * Get the migration route metadata, of the source.\r\n     *\r\n     * If the property returns `undefined`, it means that the error has been\r\n     * occured in the migration level, not of OpenAI document composition.\r\n     *\r\n     * @returns Migration route metadata.\r\n     */\r\n    route: () => ISwaggerMigrateRoute | undefined;\r\n  }\r\n\r\n  /**\r\n   * Options for composing the OpenAI document.\r\n   */\r\n  export interface IOptions {\r\n    /**\r\n     * Whether the parameters are keyworded or not.\r\n     *\r\n     * If this property value is `true`, length of the\r\n     * {@link IOpenAiDocument.IFunction.parameters} is always 1, and type of the\r\n     * pararameter is always {@link IOpenAiSchema.IObject} type. Also, its\r\n     * properties are following below rules:\r\n     *\r\n     * - `pathParameters`: Path parameters of {@link ISwaggerMigrateRoute.parameters}\r\n     * - `query`: Query parameter of {@link ISwaggerMigrateRoute.query}\r\n     * - `body`: Body parameter of {@link ISwaggerMigrateRoute.body}\r\n     *\r\n     * ```typescript\r\n     * {\r\n     *   ...pathParameters,\r\n     *   query,\r\n     *   body,\r\n     * }\r\n     * ```\r\n     *\r\n     * Otherwise (this property value is `false`), length of the\r\n     * {@link IOpenAiDocument.IFunction.parameters} is variable, and sequence of the\r\n     * parameters are following below rules.\r\n     *\r\n     * ```typescript\r\n     * [\r\n     *   ...pathParameters,\r\n     *   ...(query ? [query] : []),\r\n     *   ...(body ? [body] : []),\r\n     * ]\r\n     * ```\r\n     *\r\n     * @default false\r\n     */\r\n    keyword: boolean;\r\n\r\n    /**\r\n     * Separator function for the parameters.\r\n     *\r\n     * When composing parameter arguments through OpenAI function call,\r\n     * there can be a case that some parameters must be composed by human, or\r\n     * LLM cannot understand the parameter. For example, if the parameter type\r\n     * has configured {@link IOpenAiSchema.IString[\"x-wrtn-secret-key\"]}, the\r\n     * secret key value must be composed by human, not by LLM (Large Language Model).\r\n     *\r\n     * In that case, if you configure this property with a function that\r\n     * predicating whether the schema value must be composed by human or not,\r\n     * the parameters would be separated into two parts.\r\n     *\r\n     * - {@link IOpenAiFunction.separated.llm}\r\n     * - {@link IOpenAiFunction.separated.human}\r\n     *\r\n     * When writing the function, note that returning value `true` means to be\r\n     * a human composing the value, and `false` means to LLM composing the value.\r\n     * Also, when predicating the schema, it would better to utilize the\r\n     * {@link OpenAiTypeChecker} features.\r\n     *\r\n     * @param schema Schema to be separated.\r\n     * @returns Whether the schema value must be composed by human or not.\r\n     * @default null\r\n     */\r\n    separate: null | ((schema: IOpenAiSchema) => boolean);\r\n  }\r\n}\nDocument of OpenAI function call metadata.IOpenAiDocument is a data structure collecting the OpenAI function calling schemas, and stores the options that has been adjusted for the OpenAPI document to OpenAI document conversion. Also, it contains error messages occured during the composition.For reference, the conversion error occured only when the target API operation (OpenApi.IOperation) has a recursive type. LLM function calling schema is utilizing JSON schema of OpenAPI v3.0 specification, but it does not support the reference type ($ref). Therefore, if recursive type comes, no way to express it, so that the error occurs and stored to the IOpenAiDocument.errors array.About the options, there're two configurations; keyword and separate.The keyword means that gathering every parameters into only one single object with property key name/valur pairs. It has been designed for some Large Language Models which are performing the function calling much better than the multiple parameters case.The other option separate is for separating the parameters to two parts; one is for LLM composing, and the other is for Human composing. It's useful when some parameters must be composed by human, like file uploading or secret key value cases.","function#Function":"export interface IOpenAiFunction {\r\n  method: \"get\" | \"post\" | \"patch\" | \"put\" | \"delete\";\r\n  path: string;\r\n  name: string;\r\n  strict: true;\r\n  parameters: IOpenAiSchema[];\r\n  separated?: IOpenAiFunction.ISeparated;\r\n  output?: IOpenAiSchema | undefined;\r\n  description?: string | undefined;\r\n  operation: () => ISwaggerOperation;\r\n  route: () => ISwaggerMigrateRoute;\r\n}\r\nexport namespace IOpenAiFunction {\r\n  export interface ISeparated {\r\n    llm: ISeparatedParameter[];\r\n    human: ISeparatedParameter[];\r\n  }\r\n  export interface ISeparatedParameter {\r\n    index: number;\r\n    schema: IOpenAiSchema;\r\n  }\r\n}\nFunction schema for LLM function call.IOpenAiFunction is a data structure representing a function, which is provided by and converted from the Restful API (OpenApi.IOperation), and be used for the LLM (Large Language Model) function calling. It's a typical RPC (Remote Procedure Call) function structure that containing the function name, parameters and return types.About the type information, LLM function calling schema has daopted the JSON schema of OpenAPI v3.0 specification. However, its detailed specification is a little bit different with the original JSON schema. The difference is between regular JSON schema and of LLMis, LLM excludes the reference type ($ref).Therefore, if there's a function (Restful API operation) which has recursive type, it can't be used in the LLM (Large Language Model) function calling. AS the target OpenApi.IOperation instance cannot be converted to the IOpenAiFunction type, it would be just enrolled to the IOpenAiDocument.errors array instead.","identifier#Identifier":"export interface IOpenAiFunction {\r\n  /**\r\n   * HTTP method of the endpoint.\r\n   */\r\n  method: \"get\" | \"post\" | \"patch\" | \"put\" | \"delete\";\r\n\r\n  /**\r\n   * Path of the endpoint.\r\n   */\r\n  path: string;\r\n\r\n  /**\r\n   * Representative name of the function.\r\n   *\r\n   * The `name` is a repsentative name identifying the function in the\r\n   * {@link IOpenAiDocument}. The `name` value is just composed by joining the\r\n   * {@link IMigrateRoute.accessor} by underscore `_` character.\r\n   *\r\n   * Here is the composition rule of the  {@link IMigrateRoute.accessor}:\r\n   *\r\n   * > The `accessor` is composed with the following rules. At first, namespaces\r\n   * > are composed by static directory names in the {@link path}. Parametric\r\n   * > symbols represented by `:param` or `{param}` cannot be a part of the\r\n   * > namespace.\r\n   * >\r\n   * > Instead, they would be a part of the function name. The function\r\n   * > name is composed with the {@link method HTTP method} and parametric symbols\r\n   * > like `getByParam` or `postByParam`. If there are multiple path parameters,\r\n   * > they would be concatenated by `And` like `getByParam1AndParam2`.\r\n   * >\r\n   * > For refefence, if the {@link operation}'s {@link method} is `delete`, the\r\n   * > function name would be replaced to `erase` instead of `delete`. It is\r\n   * > the reason why the `delete` is a reserved keyword in many programming\r\n   * > languages.\r\n   * >\r\n   * > - Example 1\r\n   * >   - path: `POST /shopping/sellers/sales`\r\n   * >   - accessor: `shopping.sellers.sales.post`\r\n   * > - Example 2\r\n   * >   - endpoint: `GET /shoppings/sellers/sales/:saleId/reviews/:reviewId/comments/:id\r\n   * >   - accessor: `shoppings.sellers.sales.reviews.getBySaleIdAndReviewIdAndCommentId`\r\n   */\r\n  name: string;\r\n\r\n  /**\r\n   * Description of the function.\r\n   *\r\n   * Composed by such rule:\r\n   *\r\n   * 1. Starts from the {@link OpenApi.IOperation.summary} paragraph.\r\n   * 2. The next paragraphs are filled with the {@link OpenApi.IOperation.description}.\r\n   *    By the way, if the first paragraph of {@link OpenApi.IOperation.description} is same\r\n   *    with the {@link OpenApi.IOperation.summary}, it would not be duplicated.\r\n   * 3. Parameters' descriptions are added with `@param` tag.\r\n   * 4. {@link OpenApi.IOperation.security Security requirements} are added with `@security` tag.\r\n   * 5. Tag names are added with `@tag` tag.\r\n   * 6. If {@link OpenApi.IOperation.deprecated}, `@deprecated` tag is added.\r\n   */\r\n  description?: string;\r\n\r\n  /**\r\n   * Get the Swagger operation metadata.\r\n   *\r\n   * Get the Swagger operation metadata, of the source.\r\n   *\r\n   * @returns Swagger operation metadata.\r\n   */\r\n  operation: () => ISwaggerOperation;\r\n\r\n  /**\r\n   * Get the migration route metadata.\r\n   *\r\n   * Get the migration route metadata, of the source.\r\n   *\r\n   * @returns Migration route metadata.\r\n   */\r\n  route: () => ISwaggerMigrateRoute;\r\n}\nexport interface IMigrateRoute<\r\n  Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\r\n  Operation extends OpenApi.IOperation<Schema> = OpenApi.IOperation<Schema>,\r\n> {\r\n  /**\r\n   * Method of the route.\r\n   *\r\n   * If the {@link OpenApi.IOperation.method} is not one of below type\r\n   * values, the operation would be ignored in the migration process for\r\n   * the RPC (Remote Procedure Call) function.\r\n   */\r\n  method: \"head\" | \"get\" | \"post\" | \"put\" | \"patch\" | \"delete\";\r\n\r\n  /**\r\n   * Original path from the OpenAPI document.\r\n   */\r\n  path: string;\r\n\r\n  /**\r\n   * Accessor for the route.\r\n   *\r\n   * The `accessor` is a list of string values that are representing how to\r\n   * access to the OpenAPI generated RPC (Remote Procedure Call) function\r\n   * through namespace(s).\r\n   *\r\n   * The `accessor` is composed with the following rules. At first, namespaces\r\n   * are composed by static directory names in the {@link path}. Parametric\r\n   * symbols represented by `:param` or `{param}` cannot be a part of the\r\n   * namespace.\r\n   *\r\n   * Instead, they would be a part of the function name. The function\r\n   * name is composed with the {@link method HTTP method} and parametric symbols\r\n   * like `getByParam` or `postByParam`. If there are multiple path parameters,\r\n   * they would be concatenated by `And` like `getByParam1AndParam2`.\r\n   *\r\n   * For refefence, if the {@link operation}'s {@link method} is `delete`, the\r\n   * function name would be replaced to `erase` instead of `delete`. It is\r\n   * the reason why the `delete` is a reserved keyword in many programming\r\n   * languages.\r\n   *\r\n   * - Example 1\r\n   *   - path: `POST /shopping/sellers/sales`\r\n   *   - accessor: `shopping.sellers.sales.post`\r\n   * - Example 2\r\n   *   - endpoint: `GET /shoppings/sellers/sales/:saleId/reviews/:reviewId/comments/:id\r\n   *   - accessor: `shoppings.sellers.sales.reviews.getBySaleIdAndReviewIdAndCommentId`\r\n   */\r\n  accessor: string[];\r\n\r\n  /**\r\n   * Description comment for the route function.\r\n   *\r\n   * The `comment` is a function returning description comment for the\r\n   * RPC function of OpenAPI generated. The comment is composed with the\r\n   * following rules:\r\n   *\r\n   * 1. Starts from the {@link OpenApi.IOperation.summary} paragraph.\r\n   * 2. The next paragraphs are filled with {@link OpenApi.IOperation.description}.\r\n   * 3. Parameter descriptions are added with `@param` tag.\r\n   * 4. Security requirements are added with `@security` tag.\r\n   * 5. Tag names are added with `@tag` tag.\r\n   * 6. If {@link OpenApi.IOperation.deprecated}, `@deprecated` tag is added.\r\n   */\r\n  comment: () => string;\r\n\r\n  /**\r\n   * Original operation from the OpenAPI document.\r\n   *\r\n   * The `operation` is a function returning the original\r\n   * {@link OpenApi.IOperation} from the {@link OpenAPI} document.\r\n   */\r\n  operation: () => Operation;\r\n}\nexport namespace OpenApi {\r\n  export interface IOperation<Schema extends IJsonSchema = IJsonSchema> {\r\n    /**\r\n     * A short summary of what the operation does.\r\n     */\r\n    summary?: string;\r\n\r\n    /**\r\n     * A verbose explanation of the operation behavior.\r\n     */\r\n    description?: string;\r\n\r\n    /**\r\n     * List of parameters that are applicable for this operation.\r\n     */\r\n    parameters?: IOperation.IParameter<Schema>[];\r\n\r\n    /**\r\n     * The request body applicable for this operation.\r\n     */\r\n    requestBody?: IOperation.IRequestBody<Schema>;\r\n\r\n    /**\r\n     * List of securities and their scopes that are required for execution.\r\n     *\r\n     * When this property be configured, the Restful API operation requires\r\n     * the matched security value for exection. Its key means security key\r\n     * matched with {@link OpenApi.IDocument.security}.\r\n     *\r\n     * The value means scopes required for the security key when the security\r\n     * type is {@link OpenApi.ISecurityScheme.IOAuth2}. Otherwise the target\r\n     * security type is not {@link OpenApi.ISecurityScheme.IOAuth2}, the value\r\n     * would be empty array.\r\n     */\r\n    security?: Record<string, string[]>[];\r\n\r\n    /**\r\n     * Tags for API documentation control.\r\n     */\r\n    tags?: string[];\r\n  }\r\n}\nIOpenAiFunction has four identical properties; method, path, name and description.The method and path properties are used to identify the target API operation and bypassed migration schema. The other property name is used to identify the function in the document, and description describes the function's purpose so that helps the LLM to select proper function for the user's chatting text.In detaily, the name property is composed by below rule:\nRule\nSplit OpenApi.IOperation.path by / character\nErase template arguments from the splitted path\nJoin the splitted and filtered text with _ character\nAttach method name at the last of the joined text\nAttach template arguments with By prefix pascalized texts at last\nExample 1\nendpoint: POST /shopping/sellers/sales\nname: shopping_sellers_sales_post\nExample 2\nendpoint: GET /shoppings/sellers/sales/:saleId/reviews/:reviewId/comments/:id\nname: \nAlso, description is composed by such rule:\nStarts from the summary paragraph of the OpenAPI operation.\nThe next paragraphs are filled with the OpenApi.IOperation.description. By the way, if the first paragraph of description is same with the summary, it would not be duplicated.\nParameters' descriptions are added with @param tag.\nSecurity requirements (OpenApi.IOperation.security) are added with @security tag.\nTag names are added with @tag tag.\nIf OpenApi.IOperation.deprecated, @deprecated tag is added.","parameters#Parameters":"export interface IOpenAiFunction {\r\n  /**\r\n   * List of parameter schemas.\r\n   *\r\n   * If you've configured {@link IOpenAiDocument.IOptions.keyword} (as `true`),\r\n   * number of {@link IOpenAiFunction.parameters} are always 1 and the first parameter's\r\n   * type is always {@link IOpenAiSchema.IObject}. The properties' rule is:\r\n   *\r\n   * - `pathParameters`: Path parameters of {@link IMigrateRoute.parameters}\r\n   * - `query`: Query parameter of {@link IMigrateRoute.query}\r\n   * - `body`: Body parameter of {@link IMigrateRoute.body}\r\n   *\r\n   * ```typescript\r\n   * {\r\n   *   ...pathParameters,\r\n   *   query,\r\n   *   body,\r\n   * }\r\n   * ```\r\n   *\r\n   * Otherwise, the parameters would be multiple, and the sequence of the parameters\r\n   * are following below rules:\r\n   *\r\n   * ```typescript\r\n   * [\r\n   *   ...pathParameters,\r\n   *   ...(query ? [query] : []),\r\n   *   ...(body ? [body] : []),\r\n   * ]\r\n   * ```\r\n   */\r\n  parameters: IOpenAiSchema[];\r\n}\nexport interface IMigrateRoute<\r\n  Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\r\n  Operation extends OpenApi.IOperation<Schema> = OpenApi.IOperation<Schema>,\r\n> {\r\n  /**\r\n   * List of path parameters.\r\n   *\r\n   * Note that, not a list of every parameters, but only path parameters.\r\n   */\r\n  parameters: IMigrateRoute.IParameter<Schema>[];\r\n\r\n  /**\r\n   * Metadata of query values.\r\n   *\r\n   * The `query` property is a metadata of HTTP request query values for RPC function,\r\n   * including the parameter variable name and schema.\r\n   *\r\n   * Also, its {@link IMigrateRoute.IQuery.schema} is always object or reference\r\n   * to object. Even though the original {@link OpenApi.IOperation OpenAPI operation}'s\r\n   * query parameters are separated to atomic typed properties, the `query` property\r\n   * forcibly combines them into a single object type.\r\n   *\r\n   * For reference, if the `query` property has been converted to an object type\r\n   * forcibly, its property {@link IMigrateRoute.IQuery.name name} and\r\n   * {@link IMigrateRoute.IQuery.key key} are always \"headers\".\r\n   */\r\n  query: IMigrateRoute.IQuery<Schema> | null;\r\n\r\n  /**\r\n   * Metadata of request body.\r\n   *\r\n   * The `body` property is a metadata of HTTP request body for RPC function,\r\n   * including the parameter variable name, content type, and schema.\r\n   *\r\n   * If the `body` property is `null`, it means the operation does not require\r\n   * the request body data.\r\n   */\r\n  body: IMigrateRoute.IBody<Schema> | null;\r\n}\r\nexport namespace IMigrateRoute {\r\n  /**\r\n   * Metadata of path parameter.\r\n   */\r\n  export interface IParameter<\r\n    Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\r\n  > {\r\n    /**\r\n     * Name of the path parameter.\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * Key of the path parameter.\r\n     */\r\n    key: string;\r\n\r\n    /**\r\n     * Metadata of path parameter data type.\r\n     */\r\n    schema: Schema;\r\n\r\n    /**\r\n     * Original parameter info from the OpenAPI document.\r\n     *\r\n     * The `parameter` is a function returning the original\r\n     * {@link OpenApi.IOperation.IParameter} from the {@link OpenAPI} document.\r\n     */\r\n    parameter: () => OpenApi.IOperation.IParameter<Schema>;\r\n  }\r\n\r\n  /**\r\n   * Metadata of query values.\r\n   */\r\n  export interface IQuery<\r\n    Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\r\n  > {\r\n    name: string;\r\n    key: string;\r\n    schema: Schema;\r\n    title: () => string | undefined;\r\n    description: () => string | undefined;\r\n    example: () => any | undefined;\r\n    examples: () => Record<string, any> | undefined;\r\n  }\r\n\r\n  /**\r\n   * Metadata of request/response body.\r\n   */\r\n  export interface IBody<\r\n    Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\r\n  > {\r\n    /**\r\n     * Name of the body parameter.\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * Key of the body parameter.\r\n     */\r\n    key: string;\r\n\r\n    /**\r\n     * Content type of the body.\r\n     */\r\n    type:\r\n      | \"text/plain\"\r\n      | \"application/json\"\r\n      | \"application/x-www-form-urlencoded\"\r\n      | \"multipart/form-data\";\r\n\r\n    /**\r\n     * Metadata of response body data type.\r\n     */\r\n    schema: Schema;\r\n\r\n    /**\r\n     * Description comment for the request/response body.\r\n     */\r\n    description: () => string | undefined;\r\n\r\n    /**\r\n     * Media type of the request/response body.\r\n     */\r\n    media: () => OpenApi.IOperation.IMediaType<Schema>;\r\n\r\n    /**\r\n     * Whether the body is encrypted or not.\r\n     */\r\n    \"x-nestia-encrypted\"?: boolean;\r\n  }\r\n}\nexport namespace OpenApi {\r\n  export interface IOperation<Schema extends IJsonSchema = IJsonSchema> {\r\n    /**\r\n     * List of parameters that are applicable for this operation.\r\n     */\r\n    parameters?: IOperation.IParameter<Schema>[];\r\n\r\n    /**\r\n     * The request body applicable for this operation.\r\n     */\r\n    requestBody?: IOperation.IRequestBody<Schema>;\r\n  }\r\n  export namespace IOperation {\r\n    /**\r\n     * Parameter of the operation.\r\n     */\r\n    export interface IParameter<Schema extends IJsonSchema = IJsonSchema> {\r\n      /**\r\n       * Representative name of the parameter.\r\n       *\r\n       * In the most case, the `name` is equivalent to parameter variable name.\r\n       * Therefore, the `name` must be filled with the significant variable name\r\n       * of the parameter.\r\n       *\r\n       * By the way, only when the {@link in} property is `path`, the `name`\r\n       * can be omitted. In that case, the `name` is automatically deduced from\r\n       * the URL path's positional template argument analyzing.\r\n       */\r\n      name?: string;\r\n\r\n      /**\r\n       * Location of the parameter.\r\n       *\r\n       * The `in` property is a string that determines the location of the parameter.\r\n       *\r\n       * - `path`: parameter is part of the path of the URL.\r\n       * - `query`: parameter is part of the query string.\r\n       * - `header`: parameter is part of the header.\r\n       * - `cookie`: parameter is part of the cookie.\r\n       */\r\n      in: \"path\" | \"query\" | \"header\" | \"cookie\";\r\n\r\n      /**\r\n       * Type info of the parameter.\r\n       */\r\n      schema: Schema;\r\n\r\n      /**\r\n       * Whether the parameter is required for execution or not.\r\n       *\r\n       * If the parameter is required, the value must be filled. Otherwise,\r\n       * it is possible to skip the parameter when executing the APi operation.\r\n       *\r\n       * For reference, the `required` property must be always `true` when the\r\n       * {@link in} property is `path`. Otherwise, the `required` property can\r\n       * be anything of them; `true`, `false` and `undefined`.\r\n       */\r\n      required?: boolean;\r\n\r\n      /**\r\n       * Short title of the parameter.\r\n       */\r\n      title?: string;\r\n\r\n      /**\r\n       * Verbose explanation of the parameter.\r\n       */\r\n      description?: string;\r\n\r\n      /**\r\n       * Example value of the parameter.\r\n       */\r\n      example?: any;\r\n\r\n      /**\r\n       * Collection of example values of the parameter with keys.\r\n       */\r\n      examples?: Record<string, IExample>;\r\n    }\r\n\r\n    /**\r\n     * Request body of the operation.\r\n     */\r\n    export interface IRequestBody<Schema extends IJsonSchema = IJsonSchema> {\r\n      content?: IContent<Schema>;\r\n      description?: string;\r\n      required?: boolean;\r\n      \"x-nestia-encrypted\"?: boolean;\r\n    }\r\n\r\n    /**\r\n     * List of content types supported in request/response body.\r\n     */\r\n    export interface IContent<Schema extends IJsonSchema = IJsonSchema>\r\n      extends Partial<Record<ContentType, IMediaType<Schema>>> {}\r\n\r\n    /**\r\n     * Media type of a request/response body.\r\n     */\r\n    export interface IMediaType<Schema extends IJsonSchema = IJsonSchema> {\r\n      schema?: Schema;\r\n      example?: any;\r\n      examples?: Record<string, IExample>;\r\n    }\r\n\r\n    /**\r\n     * List of supported content media types.\r\n     */\r\n    export type ContentType =\r\n      | \"text/plain\"\r\n      | \"application/json\"\r\n      | \"application/x-www-form-url-encoded\"\r\n      | \"multipart/form-data\"\r\n      | \"*/*\"\r\n      | (string & {});\r\n  }\r\n}\nParameters of the function.IOpenAiFunction.parameters are composed with path, query and request body parameters, directly referencing the IOpenAISchema. About the query parameters, it is always combined into one single object with key/value paired properties. In other words, the parameters of the LLM function calling schema is composed by listing up IMigrateRoute.parameters, IMigrateRoute.query and IMigrateRoute.body properties as an array.By the way, such composition rule is valid only when the IOpenAiDocument.IOptions.keyword property has not been configured as true. If the keyword property is true, number of the parameters are always 1 by gathering every parameters into only one object with key/value paired properties.If express such composition rule with TypeScript, it would be like below:\n// KEYWORD: FALSE\r\n[\r\n  ...pathParameters,\r\n  ...(query ? [query] : []),\r\n  ...(body ? [body] : []),\r\n]\r\n\r\n// KEYWORD: TRUE\r\n{\r\n  ...pathParameters,\r\n  query,\r\n  body,\r\n}","output#Output":"export interface IOpenAiFunction {\r\n  /**\r\n   * Expected return type.\r\n   *\r\n   * If the function returns nothing (`void`), then the output is `undefined`.\r\n   */\r\n  output?: IOpenAiSchema | undefined;\r\n}\nexport interface IMigrateRoute<\r\n  Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\r\n  Operation extends OpenApi.IOperation<Schema> = OpenApi.IOperation<Schema>,\r\n> {\r\n  /**\r\n   * Metadata of response body for success case.\r\n   *\r\n   * The `success` property is a metadata of HTTP response body for RPC function,\r\n   * including content type, and schema when status code is `200` or `201`.\r\n   *\r\n   * If the `success` property is `null`, it means the operation does not have\r\n   * the response body data. In other words, the RPC function would return `void`.\r\n   */\r\n  success: IMigrateRoute.IBody<Schema> | null;\r\n\r\n  /**\r\n   * Metadata of response body for exceptional status cases.\r\n   *\r\n   * The `exceptions` property is a metadata of HTTP response body for RPC\r\n   * function, including content type, and schema when status code is not `200`\r\n   * or `201`.\r\n   *\r\n   * The key of the `exceptions` property is the status code. It may be a\r\n   * stringified number, but sometimes it could be a string like \"default\",\r\n   * because the OpenAPI document allows the status code to be a string.\r\n   */\r\n  exceptions: Record<string, IMigrateRoute.IException<Schema>>;\r\n}\r\nexport namespace IMigrateRoute {\r\n  /**\r\n   * Metadata of request/response body.\r\n   */\r\n  export interface IBody<\r\n    Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\r\n  > {\r\n    /**\r\n     * Name of the body parameter.\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * Key of the body parameter.\r\n     */\r\n    key: string;\r\n\r\n    /**\r\n     * Content type of the body.\r\n     */\r\n    type:\r\n      | \"text/plain\"\r\n      | \"application/json\"\r\n      | \"application/x-www-form-urlencoded\"\r\n      | \"multipart/form-data\";\r\n\r\n    /**\r\n     * Metadata of response body data type.\r\n     */\r\n    schema: Schema;\r\n\r\n    /**\r\n     * Description comment for the request/response body.\r\n     */\r\n    description: () => string | undefined;\r\n\r\n    /**\r\n     * Media type of the request/response body.\r\n     */\r\n    media: () => OpenApi.IOperation.IMediaType<Schema>;\r\n\r\n    /**\r\n     * Whether the body is encrypted or not.\r\n     */\r\n    \"x-nestia-encrypted\"?: boolean;\r\n  }\r\n\r\n  /**\r\n   * Metadata of response body for exceptional status cases.\r\n   */\r\n  export interface IException<\r\n    Schema extends OpenApi.IJsonSchema = OpenApi.IJsonSchema,\r\n  > {\r\n    /**\r\n     * Metadata of response body data type.\r\n     */\r\n    schema: Schema;\r\n\r\n    /**\r\n     * Description comment for the exception.\r\n     */\r\n    response: () => OpenApi.IOperation.IResponse<Schema>;\r\n\r\n    /**\r\n     * Media type of the response body.\r\n     */\r\n    media: () => OpenApi.IOperation.IMediaType<Schema>;\r\n  }\r\n}\nexport namespace OpenApi {\r\n  export interface IOperation<Schema extends IJsonSchema = IJsonSchema> {\r\n    /**\r\n     * The list of possible responses as they are returned from executing this\r\n     * operation. Its key is the HTTP status code, and the value is the metadata of\r\n     * the response in the HTTP status code.\r\n     */\r\n    responses?: Record<string, IOperation.IResponse<Schema>>;\r\n  }\r\n  export namespace IOperation {\r\n    /**\r\n     * Response of the operation.\r\n     */\r\n    export interface IResponse<Schema extends IJsonSchema = IJsonSchema> {\r\n      headers?: Record<string, IOperation.IParameter<Schema>>;\r\n      content?: IContent<Schema>;\r\n      description?: string;\r\n      \"x-nestia-encrypted\"?: boolean;\r\n    }\r\n\r\n    /**\r\n     * List of content types supported in request/response body.\r\n     */\r\n    export interface IContent<Schema extends IJsonSchema = IJsonSchema>\r\n      extends Partial<Record<ContentType, IMediaType<Schema>>> {}\r\n\r\n    /**\r\n     * Media type of a request/response body.\r\n     */\r\n    export interface IMediaType<Schema extends IJsonSchema = IJsonSchema> {\r\n      schema?: Schema;\r\n      example?: any;\r\n      examples?: Record<string, IExample>;\r\n    }\r\n\r\n    /**\r\n     * List of supported content media types.\r\n     */\r\n    export type ContentType =\r\n      | \"text/plain\"\r\n      | \"application/json\"\r\n      | \"application/x-www-form-url-encoded\"\r\n      | \"multipart/form-data\"\r\n      | \"*/*\"\r\n      | (string & {});\r\n  }\r\n}\nIOpenAiFunction.output means a return type of the function.When converting an OpenAPI operation to a LLM function schema bypass migration process, only the success case of 200 status code (or 201 when POST method) is considered. Also, about the content type, only the first one is remained. The schema information registered in the IOpenAiFunction.output comes from such process.However, looking at the intermediate structure IMigrateRoute, you can find that the bypass route is storing not only the IMigrateRoute.success typed response body, but also the exceptional status cases in the IMigrateRoute.exceptions property. Unfortunately, current LLM function calling does not consider the exceptional cases represented by Try<T, E>, the other status codes are not available.","separation#Separation":"export interface IOpenAiFunction {\r\n  /**\r\n   * Collection of separated parameters.\r\n   *\r\n   * Filled only when {@link IOpenAiDocument.IOptions.separate} has been configured.\r\n   */\r\n  separated?: IOpenAiFunction.ISeparated;\r\n\r\n  /**\r\n   * List of parameter schemas.\r\n   *\r\n   * If you've configured {@link IOpenAiDocument.IOptions.keyword} (as `true`),\r\n   * number of {@link IOpenAiFunction.parameters} are always 1 and the first parameter's\r\n   * type is always {@link IOpenAiSchema.IObject}. The properties' rule is:\r\n   *\r\n   * - `pathParameters`: Path parameters of {@link IMigrateRoute.parameters}\r\n   * - `query`: Query parameter of {@link IMigrateRoute.query}\r\n   * - `body`: Body parameter of {@link IMigrateRoute.body}\r\n   *\r\n   * ```typescript\r\n   * {\r\n   *   ...pathParameters,\r\n   *   query,\r\n   *   body,\r\n   * }\r\n   * ```\r\n   *\r\n   * Otherwise, the parameters would be multiple, and the sequence of the parameters\r\n   * are following below rules:\r\n   *\r\n   * ```typescript\r\n   * [\r\n   *   ...pathParameters,\r\n   *   ...(query ? [query] : []),\r\n   *   ...(body ? [body] : []),\r\n   * ]\r\n   * ```\r\n   */\r\n  parameters: IOpenAiSchema[];\r\n}\r\nexport namespace IOpenAiFunction {\r\n  /**\r\n   * Collection of separated parameters.\r\n   */\r\n  export interface ISeparated {\r\n    /**\r\n     * Parameters that would be composed by the OpenAI.\r\n     */\r\n    llm: ISeparatedParameter[];\r\n\r\n    /**\r\n     * Parameters that would be composed by the human.\r\n     */\r\n    human: ISeparatedParameter[];\r\n  }\r\n\r\n  /**\r\n   * Separated parameter.\r\n   */\r\n  export interface ISeparatedParameter {\r\n    /**\r\n     * Index of the parameter.\r\n     */\r\n    index: number;\r\n\r\n    /**\r\n     * Type schema info of the parameter.\r\n     */\r\n    schema: IOpenAiSchema;\r\n  }\r\n}\r\n\r\nexport namespace IOpenAiDocument {\r\n  export interface IOptions {\r\n    /**\r\n     * Separator function for the parameters.\r\n     *\r\n     * When composing parameter arguments through OpenAI function call,\r\n     * there can be a case that some parameters must be composed by human, or\r\n     * LLM cannot understand the parameter. For example, if the parameter type\r\n     * has configured {@link IOpenAiSchema.IString[\"x-wrtn-secret-key\"]}, the\r\n     * secret key value must be composed by human, not by LLM (Large Language Model).\r\n     *\r\n     * In that case, if you configure this property with a function that\r\n     * predicating whether the schema value must be composed by human or not,\r\n     * the parameters would be separated into two parts.\r\n     *\r\n     * - {@link IOpenAiFunction.separated.llm}\r\n     * - {@link IOpenAiFunction.separated.human}\r\n     *\r\n     * When writing the function, note that returning value `true` means to be\r\n     * a human composing the value, and `false` means to LLM composing the value.\r\n     * Also, when predicating the schema, it would better to utilize the\r\n     * {@link OpenAiTypeChecker} features.\r\n     *\r\n     * @param schema Schema to be separated.\r\n     * @returns Whether the schema value must be composed by human or not.\r\n     * @default null\r\n     */\r\n    separate: null | ((schema: IOpenAiSchema) => boolean);\r\n\r\n    /**\r\n     * Whether the parameters are keyworded or not.\r\n     *\r\n     * If this property value is `true`, length of the\r\n     * {@link IOpenAiDocument.IFunction.parameters} is always 1, and type of the\r\n     * pararameter is always {@link IOpenAiSchema.IObject} type. Also, its\r\n     * properties are following below rules:\r\n     *\r\n     * - `pathParameters`: Path parameters of {@link ISwaggerMigrateRoute.parameters}\r\n     * - `query`: Query parameter of {@link ISwaggerMigrateRoute.query}\r\n     * - `body`: Body parameter of {@link ISwaggerMigrateRoute.body}\r\n     *\r\n     * ```typescript\r\n     * {\r\n     *   ...pathParameters,\r\n     *   query,\r\n     *   body,\r\n     * }\r\n     * ```\r\n     *\r\n     * Otherwise (this property value is `false`), length of the\r\n     * {@link IOpenAiDocument.IFunction.parameters} is variable, and sequence of the\r\n     * parameters are following below rules.\r\n     *\r\n     * ```typescript\r\n     * [\r\n     *   ...pathParameters,\r\n     *   ...(query ? [query] : []),\r\n     *   ...(body ? [body] : []),\r\n     * ]\r\n     * ```\r\n     *\r\n     * @default false\r\n     */\r\n    keyword: boolean;\r\n  }\r\n}\nSeparation of parameters to both LLM and Human sides.If configure IOpenAiDocument.IOptions.separate function when converting OpenAPI document to LLM function calling schemas, IOpenAiFunction.separated is activated with two separated parameters; LLM side and Human side. If the configured function returns true, the target schema becomes of Human side, otherwise LLM side.Such separation is useful when some parameter value must be composed by Human, not by LLM. For example, if there's a type indicating the secret key value or file uploading, the value must be constructed by Human, not by LLM automatically composing from the chatting text.For reference, even if configured IOpenAiDocument.IOptions.keyword as true, the separation works properly. Here is the example of the separation function to the keyworded parameter, and its result. As you can see, the separate function checks every nested schemas, and re-construct the parameters into two separated parts.\nconst separator: IOpenAiDocument.IOptions[\"separate\"] = schema =>\r\n  schema.type === \"string\" && (\r\n    || schema[\"x-wrtn-secret-key\"] === true\r\n    || schema.contentMediaType !== undefined\r\n  );\r\nconst parameters: IOpenAiFunction.ISchema[] = [\r\n  {\r\n    type: \"object\",\r\n    properties: {\r\n      file: {\r\n        type: \"string\",\r\n        contentMediaType: \"image/png\",\r\n      },\r\n      title: { type: \"string\" },\r\n      notes: {\r\n        type: \"array\",\r\n        items: { type: \"string\" },\r\n      },\r\n    },\r\n  },\r\n];\r\nconst separated: IOpenAiFunction.ISeparated = {\r\n  llm: [\r\n    {\r\n      index: 0,\r\n      schema: {\r\n        type: \"object\",\r\n        properties: {\r\n          title: { type: \"string\" },\r\n          notes: {\r\n            type: \"array\",\r\n            items: { type: \"string\" },\r\n          },\r\n        },\r\n      },\r\n    },\r\n  ],\r\n  human: [\r\n    {\r\n      index: 0,\r\n      schema: {\r\n        type: \"object\",\r\n        properties: {\r\n          file: {\r\n            type: \"string\",\r\n            contentMediaType: \"image/png\",\r\n          },\r\n        },\r\n      },\r\n    },\r\n  ],\r\n};","schema#Schema":"export type IOpenAiSchema =\r\n  | IOpenAiSchema.IBoolean\r\n  | IOpenAiSchema.IInteger\r\n  | IOpenAiSchema.INumber\r\n  | IOpenAiSchema.IString\r\n  | IOpenAiSchema.IArray\r\n  | IOpenAiSchema.IObject\r\n  | IOpenAiSchema.IUnknown\r\n  | IOpenAiSchema.INullOnly\r\n  | IOpenAiSchema.IOneOf;\r\nexport namespace IOpenAiSchema {\r\n  export interface IBoolean extends __ISignificant<\"boolean\"> {\r\n    default?: boolean;\r\n    enum?: boolean[];\r\n  }\r\n  export interface IInteger extends __ISignificant<\"integer\"> {\r\n    /** @type int64 */ default?: number;\r\n    /** @type int64 */ enum?: number[];\r\n    /** @type int64 */ minimum?: number;\r\n    /** @type int64 */ maximum?: number;\r\n    exclusiveMinimum?: boolean;\r\n    exclusiveMaximum?: boolean;\r\n    /**\r\n     * @type uint64\r\n     * @exclusiveMinimum 0\r\n     */\r\n    multipleOf?: number;\r\n  }\r\n  export interface INumber extends __ISignificant<\"number\"> {\r\n    default?: number;\r\n    enum?: number[];\r\n    minimum?: number;\r\n    maximum?: number;\r\n    exclusiveMinimum?: boolean;\r\n    exclusiveMaximum?: boolean;\r\n    /** @exclusiveMinimum 0 */ multipleOf?: number;\r\n  }\r\n  export interface IString extends __ISignificant<\"string\"> {\r\n    default?: string;\r\n    enum?: string[];\r\n    format?:\r\n      | \"binary\"\r\n      | \"byte\"\r\n      | \"password\"\r\n      | \"regex\"\r\n      | \"uuid\"\r\n      | \"email\"\r\n      | \"hostname\"\r\n      | \"idn-email\"\r\n      | \"idn-hostname\"\r\n      | \"iri\"\r\n      | \"iri-reference\"\r\n      | \"ipv4\"\r\n      | \"ipv6\"\r\n      | \"uri\"\r\n      | \"uri-reference\"\r\n      | \"uri-template\"\r\n      | \"url\"\r\n      | \"date-time\"\r\n      | \"date\"\r\n      | \"time\"\r\n      | \"duration\"\r\n      | \"json-pointer\"\r\n      | \"relative-json-pointer\"\r\n      | (string & {});\r\n    pattern?: string;\r\n    /** @type uint64 */ minLength?: number;\r\n    /** @type uint64 */ maxLength?: number;\r\n    contentMediaType?: string;\r\n    \"x-wrtn-secret-key\"?: string;\r\n    \"x-wrtn-secret-scopes\"?: string[];\r\n  }\r\n  export interface IArray extends __ISignificant<\"array\"> {\r\n    items: IOpenAiSchema;\r\n    uniqueItems?: boolean;\r\n    minItems?: number;\r\n    maxItems?: number;\r\n  }\r\n  export interface IObject extends __ISignificant<\"object\"> {\r\n    properties?: Record<string, IOpenAiSchema>;\r\n    required?: string[];\r\n    additionalProperties?: boolean | IOpenAiSchema;\r\n  }\r\n\r\n  export interface IUnknown extends __IAttribute {\r\n    type?: undefined;\r\n  }\r\n  export interface INullOnly extends __IAttribute {\r\n    type: \"null\";\r\n  }\r\n  export interface IOneOf extends __IAttribute {\r\n    oneOf: IOpenAiSchema[];\r\n  }\r\n  export interface __ISignificant<Type extends string> extends __IAttribute {\r\n    type: Type;\r\n    nullable?: boolean;\r\n  }\r\n  export interface __IAttribute {\r\n    title?: string;\r\n    description?: string;\r\n    deprecated?: boolean;\r\n    \"x-wrtn-placeholder\"?: string;\r\n    \"x-wrtn-prerequisite\"?: {\r\n      method: \"get\" | \"post\" | \"patch\" | \"put\" | \"delete\";\r\n      path: string;\r\n      jmesPath: string;\r\n    };\r\n  }\r\n}\nexport namespace OpenApiV3 {\r\n  export type IJsonSchema =\r\n    | IJsonSchema.IBoolean\r\n    | IJsonSchema.IInteger\r\n    | IJsonSchema.INumber\r\n    | IJsonSchema.IString\r\n    | IJsonSchema.IArray\r\n    | IJsonSchema.IObject\r\n    | IJsonSchema.IReference\r\n    | IJsonSchema.IUnknown\r\n    | IJsonSchema.INullOnly\r\n    | IJsonSchema.IAllOf\r\n    | IJsonSchema.IAnyOf\r\n    | IJsonSchema.IOneOf;\r\n  export namespace IJsonSchema {\r\n    export interface IBoolean extends __ISignificant<\"boolean\"> {\r\n      default?: boolean | null;\r\n      enum?: Array<boolean | null>;\r\n    }\r\n    export interface IInteger extends __ISignificant<\"integer\"> {\r\n      /** @type int64 */ default?: number | null;\r\n      /** @type int64 */ enum?: Array<number | null>;\r\n      /** @type int64 */ minimum?: number;\r\n      /** @type int64 */ maximum?: number;\r\n      exclusiveMinimum?: boolean;\r\n      exclusiveMaximum?: boolean;\r\n      /**\r\n       * @type uint64\r\n       * @exclusiveMinimum 0\r\n       */\r\n      multipleOf?: number;\r\n    }\r\n    export interface INumber extends __ISignificant<\"number\"> {\r\n      default?: number | null;\r\n      enum?: Array<number | null>;\r\n      minimum?: number;\r\n      maximum?: number;\r\n      exclusiveMinimum?: boolean;\r\n      exclusiveMaximum?: boolean;\r\n      /** @exclusiveMinimum 0 */ multipleOf?: number;\r\n    }\r\n    export interface IString extends __ISignificant<\"string\"> {\r\n      default?: string | null;\r\n      enum?: Array<string | null>;\r\n      format?:\r\n        | \"binary\"\r\n        | \"byte\"\r\n        | \"password\"\r\n        | \"regex\"\r\n        | \"uuid\"\r\n        | \"email\"\r\n        | \"hostname\"\r\n        | \"idn-email\"\r\n        | \"idn-hostname\"\r\n        | \"iri\"\r\n        | \"iri-reference\"\r\n        | \"ipv4\"\r\n        | \"ipv6\"\r\n        | \"uri\"\r\n        | \"uri-reference\"\r\n        | \"uri-template\"\r\n        | \"url\"\r\n        | \"date-time\"\r\n        | \"date\"\r\n        | \"time\"\r\n        | \"duration\"\r\n        | \"json-pointer\"\r\n        | \"relative-json-pointer\"\r\n        | (string & {});\r\n      pattern?: string;\r\n      /** @type uint64 */ minLength?: number;\r\n      /** @type uint64 */ maxLength?: number;\r\n    }\r\n\r\n    export interface IArray extends __ISignificant<\"array\"> {\r\n      items: IJsonSchema;\r\n      uniqueItems?: boolean;\r\n      /** @type uint64 */ minItems?: number;\r\n      /** @type uint64 */ maxItems?: number;\r\n    }\r\n    export interface IObject extends __ISignificant<\"object\"> {\r\n      properties?: Record<string, IJsonSchema>;\r\n      required?: string[];\r\n      additionalProperties?: boolean | IJsonSchema;\r\n      maxProperties?: number;\r\n      minProperties?: number;\r\n    }\r\n    export interface IReference<Key = string> extends __IAttribute {\r\n      $ref: Key;\r\n    }\r\n\r\n    export interface IUnknown extends __IAttribute {\r\n      type?: undefined;\r\n    }\r\n    export interface INullOnly extends __IAttribute {\r\n      type: \"null\";\r\n    }\r\n    export interface IAllOf extends __IAttribute {\r\n      allOf: IJsonSchema[];\r\n    }\r\n    export interface IAnyOf extends __IAttribute {\r\n      anyOf: IJsonSchema[];\r\n    }\r\n    export interface IOneOf extends __IAttribute {\r\n      oneOf: IJsonSchema[];\r\n      discriminator?: IOneOf.IDiscriminator;\r\n    }\r\n    export namespace IOneOf {\r\n      export interface IDiscriminator {\r\n        propertyName: string;\r\n        mapping?: Record<string, string>;\r\n      }\r\n    }\r\n\r\n    export interface __ISignificant<Type extends string> extends __IAttribute {\r\n      type: Type;\r\n      nullable?: boolean;\r\n    }\r\n    export interface __IAttribute {\r\n      title?: string;\r\n      description?: string;\r\n      deprecated?: boolean;\r\n    }\r\n  }\r\n}\nexport namespace OpenApi {\r\n  export type IJsonSchema =\r\n    | IJsonSchema.IConstant\r\n    | IJsonSchema.IBoolean\r\n    | IJsonSchema.IInteger\r\n    | IJsonSchema.INumber\r\n    | IJsonSchema.IString\r\n    | IJsonSchema.IArray\r\n    | IJsonSchema.ITuple\r\n    | IJsonSchema.IObject\r\n    | IJsonSchema.IReference\r\n    | IJsonSchema.IOneOf\r\n    | IJsonSchema.INull\r\n    | IJsonSchema.IUnknown;\r\n  export namespace IJsonSchema {\r\n    export interface IConstant extends __IAttribute {\r\n      const: boolean | number | string;\r\n    }\r\n    export interface IBoolean extends __ISignificant<\"boolean\"> {\r\n      default?: boolean;\r\n    }\r\n    export interface IInteger extends __ISignificant<\"integer\"> {\r\n      /** @type int64 */ default?: number;\r\n      /** @type int64 */ minimum?: number;\r\n      /** @type int64 */ maximum?: number;\r\n      exclusiveMinimum?: boolean;\r\n      exclusiveMaximum?: boolean;\r\n      /**\r\n       * @type uint64\r\n       * @exclusiveMinimum 0\r\n       */\r\n      multipleOf?: number;\r\n    }\r\n    export interface INumber extends __ISignificant<\"number\"> {\r\n      default?: number;\r\n      minimum?: number;\r\n      maximum?: number;\r\n      exclusiveMinimum?: boolean;\r\n      exclusiveMaximum?: boolean;\r\n      /** @exclusiveMinimum 0 */ multipleOf?: number;\r\n    }\r\n    export interface IString extends __ISignificant<\"string\"> {\r\n      default?: string;\r\n      format?:\r\n        | \"binary\"\r\n        | \"byte\"\r\n        | \"password\"\r\n        | \"regex\"\r\n        | \"uuid\"\r\n        | \"email\"\r\n        | \"hostname\"\r\n        | \"idn-email\"\r\n        | \"idn-hostname\"\r\n        | \"iri\"\r\n        | \"iri-reference\"\r\n        | \"ipv4\"\r\n        | \"ipv6\"\r\n        | \"uri\"\r\n        | \"uri-reference\"\r\n        | \"uri-template\"\r\n        | \"url\"\r\n        | \"date-time\"\r\n        | \"date\"\r\n        | \"time\"\r\n        | \"duration\"\r\n        | \"json-pointer\"\r\n        | \"relative-json-pointer\"\r\n        | (string & {});\r\n      pattern?: string;\r\n      contentMediaType?: string;\r\n      /** @type uint64 */ minLength?: number;\r\n      /** @type uint64 */ maxLength?: number;\r\n    }\r\n\r\n    export interface IArray<Schema extends IJsonSchema = IJsonSchema>\r\n      extends __ISignificant<\"array\"> {\r\n      items: Schema;\r\n      uniqueItems?: boolean;\r\n      /** @type uint64 */ minItems?: number;\r\n      /** @type uint64 */ maxItems?: number;\r\n    }\r\n    export interface ITuple<Schema extends IJsonSchema = IJsonSchema>\r\n      extends __ISignificant<\"array\"> {\r\n      prefixItems: Schema[];\r\n      additionalItems?: boolean | Schema;\r\n      uniqueItems?: boolean;\r\n      /** @type uint64 */ minItems?: number;\r\n      /** @type uint64 */ maxItems?: number;\r\n    }\r\n    export interface IObject<Schema extends IJsonSchema = IJsonSchema>\r\n      extends __ISignificant<\"object\"> {\r\n      properties?: Record<string, Schema>;\r\n      additionalProperties?: boolean | Schema;\r\n      required?: string[];\r\n    }\r\n\r\n    export interface IReference<Key = string> extends __IAttribute {\r\n      $ref: Key;\r\n    }\r\n    export interface IOneOf<Schema extends IJsonSchema = IJsonSchema>\r\n      extends __IAttribute {\r\n      oneOf: Exclude<Schema, IJsonSchema.IOneOf>[];\r\n      discriminator?: IOneOf.IDiscriminator;\r\n    }\r\n    export namespace IOneOf {\r\n      export interface IDiscriminator {\r\n        propertyName: string;\r\n        mapping?: Record<string, string>;\r\n      }\r\n    }\r\n    export interface INull extends __ISignificant<\"null\"> {\r\n      default?: null;\r\n    }\r\n    export interface IUnknown extends __IAttribute {\r\n      type?: undefined;\r\n    }\r\n\r\n    export interface __ISignificant<Type extends string> extends __IAttribute {\r\n      type: Type;\r\n    }\r\n    export interface __IAttribute {\r\n      title?: string;\r\n      description?: string;\r\n      deprecated?: boolean;\r\n    }\r\n  }\r\n}\nSchema types for the LLM function call.The LLM (Large Language Model) function calling schema is utilizing a specific type schema that is similar to the JSON schema of the OpenAPI v3.0 specification. Only different with the OpenAPI v3.0 JSON schema is, of LLM does not support the IJsonSchema.IReference type.Therefore, looking above type schema definitions of LLM function calling and OpenAPI specifications, you can find that the LLM's type schema type does not contain the reference type in the union IOpenAiSchema type. The other things are same with original JSON schema.Also, if you compare this section with OpenAPI > Json Schema chapter, you may understand the LLM's type system more clearly and easily.","common-properties#Common Properties":"export namespace IOpenAiSchema {\r\n  /**\r\n   * Common attributes that can be applied to all types.\r\n   */\r\n  export interface __IAttribute {\r\n    /**\r\n     * Title of the schema.\r\n     */\r\n    title?: string;\r\n\r\n    /**\r\n     * Detailed description of the schema.\r\n     */\r\n    description?: string;\r\n\r\n    /**\r\n     * Whether the type is deprecated or not.\r\n     */\r\n    deprecated?: boolean;\r\n\r\n    /**\r\n     * Placeholder value for frontend application.\r\n     *\r\n     * Placeholder means the value to be shown in the input field as a hint.\r\n     * For example, when an email input field exists, the placeholder value\r\n     * would be \"Insert your email address here\".\r\n     */\r\n    \"x-wrtn-placeholder\"?: string;\r\n\r\n    /**\r\n     * Prerequisite API endpoint for the schema.\r\n     *\r\n     * `x-wrtn-prerequisite` is a property representing the prerequisite API\r\n     * interaction. It means that, the endpoint API should be called before\r\n     * calling the target API, for composing some argument value.\r\n     *\r\n     * @reference https://github.com/wrtnio/decorators/blob/main/src/Prerequisite.ts\r\n     */\r\n    \"x-wrtn-prerequisite\"?: {\r\n      /**\r\n       * HTTP method to call the endpoint.\r\n       */\r\n      method: \"get\" | \"post\" | \"patch\" | \"put\" | \"delete\";\r\n\r\n      /**\r\n       * Path of the endpoint.\r\n       */\r\n      path: string;\r\n\r\n      /**\r\n       * Function returning transformed values using JMESPath expression.\r\n       *\r\n       * `Prerequisite.Props.jmesPath` is a string typed property that extracts desired values\r\n       * from the prerequisite API response using a JMESPath expression. This property simplifies\r\n       * and replaces the `label`, `value`, and `array` properties.\r\n       *\r\n       * JMESPath expressions are used to extract the desired data based on the API response.\r\n       * The expression must always be a valid JMESPath syntax.\r\n       *\r\n       * - Type: `jmesPath: string`\r\n       * - Example: `\"members[*].data.title\"`\r\n       * - Usage: `jmespath.search(response, jmesPath)`\r\n       *\r\n       * Note: The `label`, `value`, and `array` properties are no longer in use.\r\n       */\r\n      jmesPath: string;\r\n    };\r\n  }\r\n}\nEvery type schemas in the LLM function call has five properties.The first title is the representative name of the schema, and the meaning \"representative\" is powerful due to LLM (Large Language Model) is affected by the title value when understanding the schema information.The other description is the detailed explanation of the schema. In the LLM side, it is used for understanding the schema more deeply than title. Also, LLM utilizes the description value to the writing a chatting text that requesting Human to write the function calling arguments by the chatting text.The next deprecated is used to mark the schema as deprecated. If the target schema is optional and marked as deprecated, the LLM tends to avoid the target schema's value composition. However, if the schema is essential for function calling, it would be ignored.At last, there're plugin properties x-wrtn-placeholder and x-wrtn-prerequisite. It is not a spec for LLM function calling, but for the Workflow editor side. If you want to know more about these plugin properties, please refer to the OpenAPI > Plugin Properties chapter.","boolean#Boolean":"export namespace IOpenAiSchema {\r\n  /**\r\n   * Boolean type schema info.\r\n   */\r\n  export interface IBoolean extends __IAttribute {\r\n    /**\r\n     * Discriminator value of the type.\r\n     */\r\n    type: \"boolean\";\r\n\r\n    /**\r\n     * Enumeration values.\r\n     */\r\n    enum?: boolean[];\r\n\r\n    /**\r\n     * Whether to allow `null` value or not.\r\n     */\r\n    nullable?: boolean;\r\n\r\n    /**\r\n     * Default value.\r\n     */\r\n    default?: boolean;\r\n  }\r\n}\nexport namespace OpenApiV3_0 {\r\n  export namespace IJsonSchema {\r\n    export interface IBoolean extends __IAttribute {\r\n      type: \"boolean\";\r\n      enum?: Array<boolean | null>;\r\n      nullable?: boolean;\r\n      default?: boolean;\r\n    }\r\n  }\r\n}\nexport namespace OpenApi {\r\n  export namespace IJsonSchema {\r\n    export interface IBoolean extends __IAttribute {\r\n      type: \"boolean\";\r\n      default?: boolean;\r\n    }\r\n    export interface IConstant extends __IAttribute {\r\n      const: boolean | number | string;\r\n    }\r\n    export interface INull extends __IAttribute {\r\n      type: \"null\";\r\n      default?: null;\r\n    }\r\n  }\r\n}\nIn the LLM function calling, the boolean type is expressed as above.Also, if the target type of the schema is not a general boolean type, but a specific literal type like true or false, it would be expressed as enum property. Also, if the target type of the schema is nullable, the nullable property would be activated.At last, the default property is used to represent the default value of the schema. If the schema is optional and marked as default, the LLM tends to compose the default value to the function calling arguments.\n Playground Link\nimport typia, { tags } from \"typia\";\r\n\r\nconsole.log(\r\n  typia.json.application<\r\n    [\r\n      boolean,\r\n      false,\r\n      boolean | null,\r\n      boolean & tags.Default<false>\r\n    ], \r\n    \"3.0\"\r\n  >(),\r\n);\r\n  // { type: \"boolean\" },\r\n  // {\r\n  //   type: \"boolean\",\r\n  //   enum: [false],\r\n  // },\r\n  // {\r\n  //   type: \"boolean\",\r\n  //   nullable: true,\r\n  // },\r\n  // {\r\n  //   type: \"boolean\",\r\n  //   default: false,\r\n  // }","integer#Integer":"export namespace IOpenAiSchema {\r\n  /**\r\n   * Integer type schema info.\r\n   */\r\n  export interface IInteger extends __IAttribute {\r\n    /**\r\n     * Discriminator value of the type.\r\n     */\r\n    type: \"integer\";\r\n\r\n    /**\r\n     * Enumeration values.\r\n     *\r\n     * @type int64\r\n     */\r\n    enum?: number[];\r\n\r\n    /**\r\n     * Whether to allow `null` value or not.\r\n     */\r\n    nullable?: boolean;\r\n\r\n    /**\r\n     * Default value.\r\n     *\r\n     * @type int64\r\n     */\r\n    default?: number;\r\n\r\n    /**\r\n     * Minimum value restriction.\r\n     *\r\n     * @type int64\r\n     */\r\n    minimum?: number;\r\n\r\n    /**\r\n     * Maximum value restriction.\r\n     *\r\n     * @type int64\r\n     */\r\n    maximum?: number;\r\n\r\n    /**\r\n     * Exclusive minimum value restriction.\r\n     *\r\n     * For reference, even though your Swagger (or OpenAPI) document has\r\n     * defined the `exclusiveMinimum` value as `number`, {@link OpenAiComposer}\r\n     * forcibly converts it to `boolean` type, and assign the numeric value to\r\n     * the {@link minimum} property.\r\n     */\r\n    exclusiveMinimum?: boolean;\r\n\r\n    /**\r\n     * Exclusive maximum value restriction.\r\n     *\r\n     * For reference, even though your Swagger (or OpenAPI) document has\r\n     * defined the `exclusiveMaximum` value as `number`, {@link OpenAiComposer}\r\n     * forcibly converts it to `boolean` type, and assign the numeric value to\r\n     * the {@link maximum} property.\r\n     */\r\n    exclusiveMaximum?: boolean;\r\n\r\n    /**\r\n     * Multiple of value restriction.\r\n     *\r\n     * @type uint64\r\n     * @exclusiveMinimum 0\r\n     */\r\n    multipleOf?: number;\r\n  }\r\n}\nexport namespace OpenApiV3_0 {\r\n  export namespace IJsonSchema {\r\n    export interface IInteger extends __IAttribute {\r\n      type: \"integer\";\r\n      nullable?: boolean;\r\n      /** @type int64 */ enum?: Array<number | null>;\r\n      /** @type int64 */ default?: number | null;\r\n      /** @type int64 */ minimum?: number;\r\n      /** @type int64 */ maximum?: number;\r\n      exclusiveMinimum?: boolean;\r\n      exclusiveMaximum?: boolean;\r\n      /**\r\n       * @type uint64\r\n       * @exclusiveMinimum 0\r\n       */\r\n      multipleOf?: number;\r\n    }\r\n  }\r\n}\nexport namespace OpenApi {\r\n  export namespace IJsonSchema {\r\n    export interface IInteger extends __IAttribute {\r\n      type: \"integer\";\r\n      /** @type int64 */ default?: number;\r\n      /** @type int64 */ minimum?: number;\r\n      /** @type int64 */ maximum?: number;\r\n      exclusiveMinimum?: boolean;\r\n      exclusiveMaximum?: boolean;\r\n      /**\r\n       * @type uint64\r\n       * @exclusiveMinimum 0\r\n       */\r\n      multipleOf?: number;\r\n    }\r\n    export interface IConstant extends __IAttribute {\r\n      const: boolean | number | string;\r\n    }\r\n    export interface INull extends __IAttribute {\r\n      type: \"null\";\r\n      default?: null;\r\n    }\r\n  }\r\n}\nIn the LLM function calling, the integer type is expressed as above.Unlike above boolean type is, the integer type has additional restriction properties.At first, multipleOf means the value must be multiple of the assigned value. Therefore, if you assign an integer value to the multipleOf restricted type, your integer value must be possible to divid by the multipleOf value without any remainder.The other, minimum and maximum are the range restriction properties, and exclusiveMinimum and exclusiveMaximum are helper properties describing whether the minimum and maximum restrictions are prohibiting equal value or not. As default value of exclusiveMinimum and exclusiveMaximum are false, if only minimum or maximum is assigned, the value is allowed to be equal to the minimum or maximum value.\n Playground Link\nimport typia, { tags } from \"typia\";\r\n\r\nconsole.log(\r\n  typia.json.application<[\r\n    number & tags.Type<\"uint32\"> & tags.Minimum<100>,\r\n  ]>(),\r\n  typia.createIs<number & tags.Type<\"uint32\"> & tags.Minimum<100>>(),\r\n);\r\n// {\r\n//   type: \"integer\",\r\n//   minimum: 100,\r\n// }\r\n//-----------------------\r\n// (input) => {\r\n//   return (\r\n//     \"number\" === typeof input &&\r\n//     Math.floor(input) === input &&\r\n//     -2147483648 <= input &&\r\n//     100 <= input\r\n//   );\r\n// }","number#Number":"export namespace IOpenAiSchema {\r\n  /**\r\n   * Number type schema info.\r\n   */\r\n  export interface INumber extends __IAttribute {\r\n    /**\r\n     * Discriminator value of the type.\r\n     */\r\n    type: \"number\";\r\n\r\n    /**\r\n     * Enumeration values.\r\n     */\r\n    enum?: number[];\r\n\r\n    /**\r\n     * Whether to allow `null` value or not.\r\n     */\r\n    nullable?: boolean;\r\n\r\n    /**\r\n     * Default value.\r\n     */\r\n    default?: number;\r\n\r\n    /**\r\n     * Minimum value restriction.\r\n     */\r\n    minimum?: number;\r\n\r\n    /**\r\n     * Maximum value restriction.\r\n     */\r\n    maximum?: number;\r\n\r\n    /**\r\n     * Exclusive minimum value restriction.\r\n     *\r\n     * For reference, even though your Swagger (or OpenAPI) document has\r\n     * defined the `exclusiveMinimum` value as `number`, {@link OpenAiComposer}\r\n     * forcibly converts it to `boolean` type, and assign the numeric value to\r\n     * the {@link minimum} property.\r\n     */\r\n    exclusiveMinimum?: boolean;\r\n\r\n    /**\r\n     * Exclusive maximum value restriction.\r\n     *\r\n     * For reference, even though your Swagger (or OpenAPI) document has\r\n     * defined the `exclusiveMaximum` value as `number`, {@link OpenAiComposer}\r\n     * forcibly converts it to `boolean` type, and assign the numeric value to\r\n     * the {@link maximum} property.\r\n     */\r\n    exclusiveMaximum?: boolean;\r\n\r\n    /**\r\n     * Multiple of value restriction.\r\n     *\r\n     * @exclusiveMinimum 0\r\n     */\r\n    multipleOf?: number;\r\n  }\r\n}\nexport namespace OpenApiV3_0 {\r\n  export namespace IJsonSchema {\r\n    export interface INumber extends __IAttribute {\r\n      type: \"number\";\r\n      enum?: Array<number | null>;\r\n      nullable?: boolean;\r\n      default?: number | null;\r\n      minimum?: number;\r\n      maximum?: number;\r\n      exclusiveMinimum?: boolean;\r\n      exclusiveMaximum?: boolean;\r\n      /** @exclusiveMinimum 0 */ multipleOf?: number;\r\n    }\r\n  }\r\n}\nexport namespace OpenApi {\r\n  export namespace IJsonSchema {\r\n    export interface INumber extends __IAttribute {\r\n      type: \"number\";\r\n      default?: number;\r\n      minimum?: number;\r\n      maximum?: number;\r\n      exclusiveMinimum?: boolean;\r\n      exclusiveMaximum?: boolean;\r\n      /** @exclusiveMinimum 0 */ multipleOf?: number;\r\n    }\r\n    export interface IConstant extends __IAttribute {\r\n      const: boolean | number | string;\r\n    }\r\n    export interface INull extends __IAttribute {\r\n      type: \"null\";\r\n      default?: null;\r\n    }\r\n  }\r\n}\nIn the LLM function calling, the number type is expressed as above.Only one thing different with number and integer type is, whether to allow the decimal point or not. The number type allows the decimal point, but the integer type does not allow the decimal point. Therefore, member properties of number type are exactly same with integer type.\nDescription in the integer type is also applied to the number type.\nAt first, multipleOf means the value must be multiple of the assigned value. Therefore, if you assign an integer value to the multipleOf restricted type, your integer value must be possible to divid by the multipleOf value without any remainder.The other, minimum and maximum are the range restriction properties, and exclusiveMinimum and exclusiveMaximum are helper properties describing whether the minimum and maximum restrictions are prohibiting equal value or not. As default value of exclusiveMinimum and exclusiveMaximum are false, if only minimum or maximum is assigned, the value is allowed to be equal to the minimum or maximum value.\n Playground Link\nimport typia, { tags } from \"typia\";\r\n\r\nconsole.log(\r\n  typia.json.application<\r\n    [ number & tags.MultipleOf<5.5>],\r\n    \"3.0\"\r\n  >(),\r\n  typia.createIs<number & tags.MultipleOf<5.5>>(),\r\n);\r\n  // {\r\n  //   type: \"number\",\r\n  //   multipleOf: 5.5,\r\n  // }\r\n  //-----------------------\r\n  // (input) => {\r\n  //   return \"number\" === typeof input && input % 5.5 === 0;\r\n  // }","string#String":"export namespace IOpenAiSchema {\r\n  /**\r\n   * String type schema info.\r\n   */\r\n  export interface IString extends __IAttribute {\r\n    /**\r\n     * Discriminator value of the type.\r\n     */\r\n    type: \"string\";\r\n\r\n    /**\r\n     * Enumeration values.\r\n     */\r\n    enum?: string[];\r\n\r\n    /**\r\n     * Whether to allow `null` value or not.\r\n     */\r\n    nullable?: boolean;\r\n\r\n    /**\r\n     * Default value.\r\n     */\r\n    default?: string;\r\n\r\n    /**\r\n     * Format restriction.\r\n     */\r\n    format?:\r\n      | \"binary\"\r\n      | \"byte\"\r\n      | \"password\"\r\n      | \"regex\"\r\n      | \"uuid\"\r\n      | \"email\"\r\n      | \"hostname\"\r\n      | \"idn-email\"\r\n      | \"idn-hostname\"\r\n      | \"iri\"\r\n      | \"iri-reference\"\r\n      | \"ipv4\"\r\n      | \"ipv6\"\r\n      | \"uri\"\r\n      | \"uri-reference\"\r\n      | \"uri-template\"\r\n      | \"url\"\r\n      | \"date-time\"\r\n      | \"date\"\r\n      | \"time\"\r\n      | \"duration\"\r\n      | \"json-pointer\"\r\n      | \"relative-json-pointer\"\r\n      | (string & {});\r\n\r\n    /**\r\n     * Pattern restriction.\r\n     */\r\n    pattern?: string;\r\n\r\n    /**\r\n     * Minimum length restriction.\r\n     *\r\n     * @type uint64\r\n     */\r\n    minLength?: number;\r\n\r\n    /**\r\n     * Maximum length restriction.\r\n     *\r\n     * @type uint64\r\n     */\r\n    maxLength?: number;\r\n\r\n    /**\r\n     * Content media type restriction.\r\n     */\r\n    contentMediaType?: string;\r\n\r\n    /**\r\n     * Secret key for the schema.\r\n     *\r\n     * `x-wrtn-secret-key` is a property means a secret key that is required\r\n     * for the target API endpoint calling. If the secret key is not filled,\r\n     * the API call would be failed.\r\n     */\r\n    \"x-wrtn-secret-key\"?: string;\r\n\r\n    /**\r\n     * Secret scopes for the schema.\r\n     *\r\n     * `x-wrtn-secret-scopes` is a property means a list of secret scopes that\r\n     * are required for the target API endpoint calling. If the secret scopes\r\n     * are not satisfied, the API call would be failed.\r\n     */\r\n    \"x-wrtn-secret-scopes\"?: string[];\r\n  }\r\n}\nexport namespace OpenApiV3_0 {\r\n  export namespace IJsonSchema {\r\n    export interface IString extends __IAttribute {\r\n      type: \"string\";\r\n      enum?: Array<string | null>;\r\n      nullable?: boolean;\r\n      default?: string | null;\r\n      format?:\r\n        | \"binary\"\r\n        | \"byte\"\r\n        | \"password\"\r\n        | \"regex\"\r\n        | \"uuid\"\r\n        | \"email\"\r\n        | \"hostname\"\r\n        | \"idn-email\"\r\n        | \"idn-hostname\"\r\n        | \"iri\"\r\n        | \"iri-reference\"\r\n        | \"ipv4\"\r\n        | \"ipv6\"\r\n        | \"uri\"\r\n        | \"uri-reference\"\r\n        | \"uri-template\"\r\n        | \"url\"\r\n        | \"date-time\"\r\n        | \"date\"\r\n        | \"time\"\r\n        | \"duration\"\r\n        | \"json-pointer\"\r\n        | \"relative-json-pointer\"\r\n        | (string & {});\r\n      pattern?: string;\r\n      /** @type uint64 */ minLength?: number;\r\n      /** @type uint64 */ maxLength?: number;\r\n    }\r\n  }\r\n}\nexport namespace OpenApi {\r\n  export namespace IJsonSchema {\r\n    export interface IString extends __IAttribute {\r\n      type: \"string\";\r\n      default?: string;\r\n      format?:\r\n        | \"binary\"\r\n        | \"byte\"\r\n        | \"password\"\r\n        | \"regex\"\r\n        | \"uuid\"\r\n        | \"email\"\r\n        | \"hostname\"\r\n        | \"idn-email\"\r\n        | \"idn-hostname\"\r\n        | \"iri\"\r\n        | \"iri-reference\"\r\n        | \"ipv4\"\r\n        | \"ipv6\"\r\n        | \"uri\"\r\n        | \"uri-reference\"\r\n        | \"uri-template\"\r\n        | \"url\"\r\n        | \"date-time\"\r\n        | \"date\"\r\n        | \"time\"\r\n        | \"duration\"\r\n        | \"json-pointer\"\r\n        | \"relative-json-pointer\"\r\n        | (string & {});\r\n      pattern?: string;\r\n      contentMediaType?: string;\r\n      /** @type uint64 */ minLength?: number;\r\n      /** @type uint64 */ maxLength?: number;\r\n    }\r\n    export interface IConstant extends __IAttribute {\r\n      const: boolean | number | string;\r\n    }\r\n    export interface INull extends __IAttribute {\r\n      type: \"null\";\r\n      default?: null;\r\n    }\r\n  }\r\n}\nIn the LLM function calling, the string type is expressed as above.As integer and number type have minimum and miximum properties, the string type has minLength and maxLength properties to restrict the length of the string. Also, the string type has special properties that other types do not have, such as format, pattern, and contentMediaType.The pattern is used for restricting the string value by the regular exression. If the string value does not match the regular expression, the value is not valid.The format is used for restricting the string value by the format. The format property is not a regular expression, but a predefined format string. If you want to see the predefined format strings, please refer to below links.\nJSON schema string format\nRegular expressions for format\nThe last contentMediaType is designed for restricting the media type of the string content. It can be used only when the format property is one of them. For reference, the contentMediaType does not affect to the string value validation, but just used for the documentation reason.\nbinary\nbyte\nuri\nurl\n Playground Link\nimport typia, { tags } from \"typia\";\r\n\r\nconsole.log(\r\n  typia.json.application<\r\n    [string & tags.Format<\"uuid\"> & tags.MinLength<5> & tags.MaxLength<255>],\r\n    \"3.0\"\r\n  >(),\r\n  typia.createIs<\r\n    string & tags.Format<\"uuid\"> & tags.MinLength<5> & tags.MaxLength<255>\r\n  >(),\r\n);\r\n  // {\r\n  //   type: \"string\",\r\n  //   format: \"uuid\",\r\n  //   minLength: 5,\r\n  //   maxLength: 255,\r\n  // }\r\n  //-----------------------\r\n  // (input) => {\r\n  //   return (\r\n  //     \"string\" === typeof input &&\r\n  //     /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n  //       input,\r\n  //     ) &&\r\n  //     5 <= input.length &&\r\n  //     input.length <= 255\r\n  //   );\r\n  // }","array#Array":"export namespace IOpenAiSchema {\r\n  /**\r\n   * Array type schema info.\r\n   */\r\n  export interface IArray extends __IAttribute {\r\n    /**\r\n     * Discriminator value of the type.\r\n     */\r\n    type: \"string\";\r\n\r\n    /**\r\n     * Whether to allow `null` value or not.\r\n     */\r\n    nullable?: boolean;\r\n\r\n    /**\r\n     * Items type schema info.\r\n     *\r\n     * The `items` means the type of the array elements. In other words, it is\r\n     * the type schema info of the `T` in the TypeScript array type `Array<T>`.\r\n     */\r\n    items: IOpenAiSchema;\r\n\r\n    /**\r\n     * Unique items restriction.\r\n     *\r\n     * If this property value is `true`, target array must have unique items.\r\n     */\r\n    uniqueItems?: boolean;\r\n\r\n    /**\r\n     * Minimum items restriction.\r\n     *\r\n     * Restriction of minumum number of items in the array.\r\n     *\r\n     * @type uint64\r\n     */\r\n    minItems?: number;\r\n\r\n    /**\r\n     * Maximum items restriction.\r\n     *\r\n     * Restriction of maximum number of items in the array.\r\n     *\r\n     * @type uint64\r\n     */\r\n    maxItems?: number;\r\n  }\r\n}\nexport namespace OpenApiV3_0 {\r\n  export namespace IJsonSchema {\r\n    export interface IArray extends __IAttribute {\r\n      type: \"array\";\r\n      nullable?: boolean;\r\n      items: IJsonSchema;\r\n      uniqueItems?: boolean;\r\n      /** @type uint64 */ minItems?: number;\r\n      /** @type uint64 */ maxItems?: number;\r\n    }\r\n  }\r\n}\nexport namespace OpenApi {\r\n  export namespace IJsonSchema {\r\n    export interface IArray<Schema extends IJsonSchema = IJsonSchema>\r\n      extends __IAttribute {\r\n      type: \"array\";\r\n      items: Schema;\r\n      uniqueItems?: boolean;\r\n      /** @type uint64 */ minItems?: number;\r\n      /** @type uint64 */ maxItems?: number;\r\n    }\r\n    export interface ITuple<Schema extends IJsonSchema = IJsonSchema>\r\n      extends __IAttribute {\r\n      type: \"array\";\r\n      prefixItems: Schema[];\r\n      additionalItems?: boolean | Schema;\r\n      uniqueItems?: boolean;\r\n      /** @type uint64 */ minItems?: number;\r\n      /** @type uint64 */ maxItems?: number;\r\n    }\r\n    export interface INull extends __IAttribute {\r\n      type: \"null\";\r\n      default?: null;\r\n    }\r\n  }\r\n}\nIn the LLM function calling, the array type is expressed as above.At first, items property is used for describing the type of the array elements. In the TypeScript, it is the type schema info of the T element type in the TypeScript array type Array<T>.The uniqueItems property is used for describing whether the array elements are unique or not. If the uniqueItems property is true, the array elements must be unique. Otherwise false or undefined, the array elements are not restricted to be unique.Also, minItems and maxItems properties are used for restricting the number of the array elements. The minItems property is used for describing the minimum number of the array elements, and the maxItems property is used for describing the maximum number of the array elements.By the way, as LLM function calling's type system is based on the OpenAPI v3.0 JSON schema specification, it is not possible to express TypeScript tuple type like [string, number, ...boolean[]] type. If you still enforce to express the tuple type, it would be expressed as an union type on the IOpenAiSchema.IArray.items property.\n Playground Link\nimport typia, { tags } from \"typia\";\r\n\r\nconsole.log(\r\n  typia.json.application<[\r\n    Array<string & tags.Format<\"uuid\">> & tags.MinItems<1>,\r\n    Array<number> & tags.UniqueItems,\r\n    [string, number, ...boolean[]],\r\n  ], \"3.0\">(),\r\n);\r\n  // {\r\n  //   type: \"array\",\r\n  //   items: {\r\n  //     type: \"string\",\r\n  //     format: \"uuid\",\r\n  //   },\r\n  //   minItems: 1,\r\n  // },\r\n  // {\r\n  //   type: \"array\",\r\n  //   items: { type: \"number\" },\r\n  //   uniqueItems: true,\r\n  // },\r\n  // {\r\n  //   type: \"array\",\r\n  //   items: {\r\n  //     oneOf: [\r\n  //       { type: \"string\" },\r\n  //       { type: \"number\" },\r\n  //       { type: \"boolean\" },\r\n  //     ],\r\n  //   },\r\n  //   minItems: 2,\r\n  // }","object#Object":"export namespace IOpenAiSchema {\r\n  /**\r\n   * Object type schema info.\r\n   */\r\n  export interface IObject extends __IAttribute {\r\n    /**\r\n     * Discriminator value of the type.\r\n     */\r\n    type: \"string\";\r\n\r\n    /**\r\n     * Whether to allow `null` value or not.\r\n     */\r\n    nullable?: boolean;\r\n\r\n    /**\r\n     * Properties of the object.\r\n     *\r\n     * The `properties` means a list of key-value pairs of the object's\r\n     * regular properties. The key is the name of the regular property,\r\n     * and the value is the type schema info.\r\n     *\r\n     * If you need additional properties that is represented by dynamic key,\r\n     * you can use the {@link additionalProperties} instead.\r\n     */\r\n    properties?: Record<string, IOpenAiSchema>;\r\n\r\n    /**\r\n     * List of key values of the required properties.\r\n     *\r\n     * The `required` means a list of the key values of the required\r\n     * {@link properties}. If some property key is not listed in the `required`\r\n     * list, it means that property is optional. Otherwise some property key\r\n     * exists in the `required` list, it means that the property must be filled.\r\n     *\r\n     * Below is an example of the {@link properties} and `required`.\r\n     *\r\n     * ```typescript\r\n     * interface SomeObject {\r\n     *   id: string;\r\n     *   email: string;\r\n     *   name?: string;\r\n     * }\r\n     * ```\r\n     *\r\n     * As you can see, `id` and `email` {@link properties} are {@link required},\r\n     * so that they are listed in the `required` list.\r\n     *\r\n     * ```json\r\n     * {\r\n     *   \"type\": \"object\",\r\n     *   \"properties\": {\r\n     *     \"id\": { \"type\": \"string\" },\r\n     *     \"email\": { \"type\": \"string\" },\r\n     *     \"name\": { \"type\": \"string\" }\r\n     *   },\r\n     *   \"required\": [\"id\", \"email\"]\r\n     * }\r\n     * ```\r\n     */\r\n    required?: string[];\r\n\r\n    /**\r\n     * Additional properties' info.\r\n     *\r\n     * The `additionalProperties` means the type schema info of the additional\r\n     * properties that are not listed in the {@link properties}.\r\n     *\r\n     * If the value is `true`, it means that the additional properties are not\r\n     * restricted. They can be any type. Otherwise, if the value is\r\n     * {@link IOpenAiSchema} type, it means that the additional properties must\r\n     * follow the type schema info.\r\n     *\r\n     * - `true`: `Record<string, any>`\r\n     * - `IOpenAiSchema`: `Record<string, T>`\r\n     */\r\n    additionalProperties?: boolean | IOpenAiSchema;\r\n  }\r\n}\nexport namespace OpenApiV3_0 {\r\n  export namespace IJsonSchema {\r\n    export interface IObject extends __IAttribute {\r\n      type: \"object\",\r\n      nullable?: boolean;\r\n      properties?: Record<string, IJsonSchema>;\r\n      required?: string[];\r\n      additionalProperties?: boolean | IJsonSchema;\r\n      maxProperties?: number;\r\n      minProperties?: number;\r\n    }\r\n  }\r\n}\nexport namespace OpenApi {\r\n  export namespace IJsonSchema {\r\n    export interface IObject<Schema extends IJsonSchema = IJsonSchema>\r\n      extends __IAttribute {\r\n      type: \"object\";\r\n      properties?: Record<string, Schema>;\r\n      additionalProperties?: boolean | Schema;\r\n      required?: string[];\r\n    }\r\n    export interface INull extends __IAttribute {\r\n      type: \"null\";\r\n      default?: null;\r\n    }\r\n  }\r\n}\nIn the LLM function calling, the object type is expressed as above.The object type has properties and required properties. The properties property is used for describing the regular properties of the object, and the required property is used for describing the required properties of the object.For example, above example code in the second tab contains a TypeScript object type. In the type, there are four regular properties; id, name, age and configurations. In the above example TypeScript object definition, only id and configurations properties are required, and the others are optional. Therefore, the required property is configured as [\"id\", \"configurations\"].Also, the configurations property is a special property that is represented by the dynamic key-value pairs. The additionalProperties property is used for describing the type schema info of the additional properties that are not listed in the properties property; Record<string, T>.For reference, if you configure the additionalProperties property just as true, it means that type of the additional properties are not restricted, so that it is equivalent to the any type case; Record<string, any>. Otherwise the additionalProperties property configured as false, it means the object type does not allow any superfluous properties. In the undefined value case, it means that does not consider and validatea the superfluous properties.\n Playground Link\nimport typia, { tags } from \"typia\";\r\n\r\nconsole.log(\r\n  typia.json.application<[\r\n    {\r\n      id: string & tags.Format<\"uuid\">;\r\n      name?: string;\r\n      age?: number & tags.Type<\"uint32\">;\r\n      configurations: {\r\n        [key: string]: boolean;\r\n      };\r\n    }\r\n  ], \"3.0\">(),\r\n);\r\n  // {\r\n  //   type: \"object\",\r\n  //   properties: {\r\n  //     id: {\r\n  //       type: \"string\",\r\n  //       format: \"uuid\",\r\n  //     },\r\n  //     name?: {\r\n  //       type: \"string\",\r\n  //     },\r\n  //     age: {\r\n  //       type: \"integer\",\r\n  //       minimum: 0,\r\n  //     },\r\n  //     configurations: {\r\n  //       type: \"object\",\r\n  //       properties: {},\r\n  //       additionalProperties: {\r\n  //         type: \"boolean\",\r\n  //       },\r\n  //     },\r\n  //   },\r\n  //   required: [\"id\", \"configurations\"],\r\n  // }","oneof#OneOf":"export namespace IOpenAiSchema {\r\n  /**\r\n   * One of type schema info.\r\n   *\r\n   * `IOneOf` represents an union type of the TypeScript (`A | B | C`).\r\n   *\r\n   * For reference, even though your Swagger (or OpenAPI) document has\r\n   * defined `anyOf` instead of the `oneOf`, {@link OpenAiComposer} forcibly\r\n   * converts it to `oneOf` type.\r\n   */\r\n  export interface IOneOf extends __IAttribute {\r\n    /**\r\n     * List of the union types.\r\n     */\r\n    oneOf: IOpenAiSchema[];\r\n  }\r\n}\nexport namespace OpenApiV3_0 {\r\n  export namespace IJsonSchema {\r\n    export interface IOneOf extends __IAttribute {\r\n      oneOf: IJsonSchema[];\r\n      discriminator?: IOneOf.IDiscriminator;\r\n    }\r\n    export namespace IOneOf {\r\n      export interface IDiscriminator {\r\n        propertyName: string;\r\n        mapping?: Record<string, string>;\r\n      }\r\n    }\r\n    export interface IReference<Key = string> extends __IAttribute {\r\n      $ref: Key;\r\n    }\r\n  }\r\n}\nexport namespace OpenApi {\r\n  export namespace IJsonSchema {\r\n    export interface IOneOf<Schema extends IJsonSchema = IJsonSchema>\r\n      extends __IAttribute {\r\n      oneOf: Exclude<Schema, IJsonSchema.IOneOf>[];\r\n      discriminator?: IOneOf.IDiscriminator;\r\n    }\r\n    export namespace IOneOf {\r\n      export interface IDiscriminator {\r\n        propertyName: string;\r\n        mapping?: Record<string, string>;\r\n      }\r\n    }\r\n    export interface IReference<Key = string> extends __IAttribute {\r\n      $ref: Key;\r\n    }\r\n  }\r\n}\nIn the LLM function calling, the oneOf type is expressed as above.The oneOf type is used for representing the union type of the TypeScript (A | B | C).By the way, as LLM function calling's type schema does not support the reference type ($ref), IOpenAiSchema.IOneOf type does not have the discriminator property which points the discriminator property in the oneOf type.","unknown#Unknown":"export namespace IOpenAiSchema {\r\n  /**\r\n   * Unknown type schema info.\r\n   *\r\n   * It means the type of the value is `any`.\r\n   */\r\n  export interface IUnknown extends __IAttribute {\r\n    /**\r\n     * Type is never be defined.\r\n     */\r\n    type?: undefined;\r\n  }\r\n}\nIn the LLM function calling schema, unknown type is expressed as above.Within framework of the TypeScript definition, it is equivalent any and unknown types.Of course, as the type is literally unknown, LLM cannot compose proper value for the type. Therefore, it would better to avoid to using the unknown (any) type when you are considering an API to be utilized by the LLM function calling."}},"/tech-specs/openapi/convert":{"title":"Convert","data":{"conversion#Conversion":"import { OpenApi } from \"@samchon/openapi\";\r\nimport fs from \"fs\";\r\n\r\nconst document: \r\n  | OpenApiV3_1.IDocument\r\n  | OpenApiV3.IDocument\r\n  | SwaggerV2.IDocument = JSON.parse(fs.readFileSync(\"swagger.json\", \"utf8\"));\r\nconst emended: OpenApi.IDocument = OpenApi.migrate(document);\nYou can easily convert your OpenAPI document to \"Wrtn Studio Pro\" is following.Just install @samchon/openapi library and call its OpenApi.convert() function. Then, whatever your OpenAPI document version is, your document would be converted to the emended OpenAPI v3.1 specified that \"Wrtn Studio Pro\" has adopted.By the way, is your document following the OpenAPI specs exactly, without any type error? Even though marketplace would reject invalid OpenAPI document uploading, you may want to validate it by yourself on your local machine. In that case, you can assert or validate the OpenAPI document type like below sections.","type-assertion#Type Assertion":"npm install typia @samchon/openapi\r\nnpx typia setup\r\nnpx ts-node src/assert.ts\nimport { OpenApi, OpenApiV3, OpenApiV3_1, SwaggerV2 } from \"@samchon/openapi\";\r\nimport typia from \"typia\";\r\n\r\nconst main = async (): Promise<void> => {\r\n  // GET YOUR OPENAPI DOCUMENT\r\n  const response: Response = await fetch(\r\n    \"https://raw.githubusercontent.com/samchon/openapi/master/examples/v3.0/openai.json\"\r\n  );\r\n  const document: any = await response.json();\r\n\r\n  // TYPE ASSERTION\r\n  typia.assertGuard<\r\n    | OpenApiV3_1.IDocument\r\n    | OpenApiV3.IDocument\r\n    | SwaggerV2.IDocument\r\n  >(document);\r\n\r\n  // CONVERT TO EMENDED\r\n  const emended: OpenApi.IDocument = OpenApi.convert(document);\r\n  console.log(emended);\r\n};\r\nmain().catch(console.error);\nYou can assert your OpenAPI document through the typia.assertGuard<T>() function.If there's any type error, the typia.assertGuard<T>() function would throws the TypeGuardError exception. Otherwise, it would return nothing, and the input type would be considered as the T type. Therefore, in the above example code, document type be casted to OpenApiV3_1.IDocument | OpenApiV3.IDocument | SwaggerV2.IDocument type after the typia.assertGuard<T>() function call.For referene, if your OpenAPI document is uploaded to somewhere URL, you can assert it right now. Just open the below playground link, and change the URL to yours. And then, click the \"execute\" button. You may see the result of the type assertion; TypeGuardError exception or the converted OpenApi.IDocument object.\n Playground Link","detailed-validation#Detailed Validation":"import { OpenApi, OpenApiV3, OpenApiV3_1, SwaggerV2 } from \"@samchon/openapi\";\r\nimport typia from \"typia\";\r\n\r\nconst main = async (): Promise<void> => {\r\n  // GET YOUR OPENAPI DOCUMENT\r\n  const response: Response = await fetch(\r\n    \"https://raw.githubusercontent.com/samchon/openapi/master/examples/v3.0/openai.json\"\r\n  );\r\n  const document: any = await response.json();\r\n\r\n  // TYPE VALIDATION\r\n  const result = typia.validate<\r\n    | OpenApiV3_1.IDocument\r\n    | OpenApiV3.IDocument\r\n    | SwaggerV2.IDocument\r\n  >(document);\r\n  if (result.success === false) {\r\n    console.info(result.errors);\r\n    return;\r\n  }\r\n\r\n  // CONVERT TO EMENDED\r\n  const emended: OpenApi.IDocument = OpenApi.convert(document);\r\n  console.info(emended);\r\n};\r\nmain().catch(console.error);\nYou can validate your OpenAPI document, and get detailed every type error reasons through the typia.validate<T>() function.If there're some type errors, the typia.validate<T>() function would return the IValidation.IFailure object with detailed type error reasons. Otherwise, it would return the IValidation.ISuccess<T>() object with the type T casted input value.For reference, if your OpenAPI document is uploaded to somewhere URL, you can validate it right now. Just open the below playground link, and change the URL to yours. And then, click the \"execute\" button. You may see the result of the type validation; IValidation.IFailure object with detailed type error reasons or the converted OpenApi.IDocument object.\n Playground Link"}},"/tech-specs/openapi/document":{"title":"Document","data":{"concepts#Concepts":"\"Wrtn Studio Pro\" has adopted OpenAPI specification with some emendations.\"Wrtn Studio Pro\" is utilizing the OpenAPI v3.1 specification, but as the OpenAPI v3.1 specification has too many ambiguous and duplicated expressions, \"Wrtn Studio Pro\" has emended the OpenAPI v3.1 specification to remove such ambiguous and duplicated expressions for the convenience and clarity.Here is the full definitions of every OpenAPI specifications and \"Wrtn Studio Pro\" utilizing emended OpenAPI v3.1 specification. For reference, if user takes an original OpenAPI v3.1 speicified document without emendation or previous versions than OpenAPI v3.1, \"Wrtn Studio Pro\" automatically converts it to the emended.\nOpenAPI v3.1 emended\nOpenAPI v3.1\nOpenAPI v3.0\nSwagger v2.0","definitions#Definitions":"","document#Document":"export namespace OpenApi {\r\n  /**\r\n   * OpenAPI document.\r\n   *\r\n   * `OpenApi.IDocument` represents an OpenAPI document of emended OpenAPI v3.1.\r\n   *\r\n   * In other words, `OpenApi.IDocument` is a structure of `swagger.json` file of\r\n   * OpenAPI v3.1 specification, but a little bit shrinked to remove ambiguous and\r\n   * duplicated expressions of OpenAPI v3.1 for the convenience and clarity.\r\n   *\r\n   * @template Schema JSON schema type\r\n   * @template Operation HTTP operation type\r\n   */\r\n  export interface IDocument<\r\n    Schema extends IJsonSchema = IJsonSchema,\r\n    Operation extends IOperation<Schema> = IOperation<Schema>,\r\n  > {\r\n    /**\r\n     * OpenAPI version number.\r\n     */\r\n    openapi: `3.1.${number}`;\r\n\r\n    /**\r\n     * List of servers that provide the API.\r\n     */\r\n    servers?: IServer[];\r\n\r\n    /**\r\n     * Information about the API.\r\n     */\r\n    info?: IDocument.IInfo;\r\n\r\n    /**\r\n     * An object to hold reusable data structures.\r\n     *\r\n     * It stores both DTO schemas and security schemes.\r\n     *\r\n     * For reference, `nestia` defines every object and alias types as reusable DTO\r\n     * schemas. The alias type means that defined by `type` keyword in TypeScript.\r\n     */\r\n    components: IComponents<Schema>;\r\n\r\n    /**\r\n     * The available paths and operations for the API.\r\n     *\r\n     * The 1st key is the path, and the 2nd key is the HTTP method.\r\n     */\r\n    paths?: Record<string, IPath<Schema, Operation>>;\r\n\r\n    /**\r\n     * An object to hold Webhooks.\r\n     *\r\n     * Its structure is same with {@link paths}, so that the 1st key is the path,\r\n     * and the 2nd key is the HTTP method.\r\n     */\r\n    webhooks?: Record<string, IPath<Schema, Operation>>;\r\n\r\n    /**\r\n     * A declaration of which security mechanisms can be used across the API.\r\n     *\r\n     * When this property be configured, it would be overwritten in every API routes.\r\n     *\r\n     * For reference, key means the name of security scheme and value means the `scopes`.\r\n     * The `scopes` can be used only when target security scheme is `oauth2` type,\r\n     * especially for {@link ISwaggerSecurityScheme.IOAuth2.IFlow.scopes} property.\r\n     */\r\n    security?: Record<string, string[]>[];\r\n\r\n    /**\r\n     * List of tag names with description.\r\n     *\r\n     * It is possible to omit this property or skip some tag name even if\r\n     * the tag name is used in the API routes. In that case, the tag name\r\n     * would be displayed (in Swagger-UI) without description.\r\n     */\r\n    tags?: IDocument.ITag[];\r\n\r\n    /**\r\n     * Flag for indicating this document is emended by `@samchon/openapi`.\r\n     */\r\n    \"x-samchon-emended\": true;\r\n  }\r\n  export namespace IDocument {\r\n    /**\r\n     * Information about the API.\r\n     */\r\n    export interface IInfo {\r\n      /**\r\n       * The title of the API.\r\n       */\r\n      title: string;\r\n\r\n      /**\r\n       * A short summary of the API.\r\n       */\r\n      summary?: string;\r\n\r\n      /**\r\n       * A full description of the API.\r\n       */\r\n      description?: string;\r\n\r\n      /**\r\n       * A URL to the Terms of Service for the API.\r\n       */\r\n      termsOfService?: string;\r\n\r\n      /**\r\n       * The contact information for the exposed API.\r\n       */\r\n      contact?: IContact;\r\n\r\n      /**\r\n       * The license information for the exposed API.\r\n       */\r\n      license?: ILicense;\r\n\r\n      /**\r\n       * Version of the API.\r\n       */\r\n      version: string;\r\n    }\r\n\r\n    /**\r\n     * OpenAPI tag information.\r\n     *\r\n     * It is possible to skip composing this structure, even if some\r\n     * tag names are regsitered in the API routes ({@link OpenApi.IOperation.tags}).\r\n     * In that case, the tag name would be displayed in Swagger-UI without\r\n     * description.\r\n     *\r\n     * However, if you want to describe the tag name, you can compose this\r\n     * structure and describe the tag name in the {@link description} property.\r\n     */\r\n    export interface ITag {\r\n      /**\r\n       * The name of the tag.\r\n       */\r\n      name: string;\r\n\r\n      /**\r\n       * An optional string describing the tag.\r\n       */\r\n      description?: string;\r\n    }\r\n\r\n    /**\r\n     * Contact information for the exposed API.\r\n     */\r\n    export interface IContact {\r\n      /**\r\n       * The identifying name of the contact person/organization.\r\n       */\r\n      name?: string;\r\n\r\n      /**\r\n       * The URL pointing to the contact information.\r\n       */\r\n      url?: string;\r\n\r\n      /**\r\n       * The email address of the contact person/organization.\r\n       *\r\n       * @format email\r\n       */\r\n      email?: string;\r\n    }\r\n\r\n    /**\r\n     * License information for the exposed API.\r\n     */\r\n    export interface ILicense {\r\n      /**\r\n       * The license name used for the API.\r\n       */\r\n      name: string;\r\n\r\n      /**\r\n       * Identifier for the license used for the API.\r\n       *\r\n       * example: MIT\r\n       */\r\n      identifier?: string;\r\n\r\n      /**\r\n       * A URL to the license used for the API.\r\n       */\r\n      url?: string;\r\n    }\r\n  }\r\n}\nIn the OpenAPI specification, document is the root object of the OpenAPI document.At first, the documenet provides the version of the OpenAPI specification through the openapi property. As \"Wrtn Studio Pro\" has adopted the OpenAPI v3.1 speicification with some emendations, the openapi property is always set to 3.1.x, where x is a number. Also, the documents contains metata information of the API, such as the title, version, and contact information through the OpenApi.IDocument.info property.At second, the document object includes the path and webhooks properties. Through these path and webhooks properties and their nested OpenApi.IOperation structured objects, document defines the API's endpoints (method + path) and which parameter and request/response body types are required for the endpoint execution. Also, document object supports the tags property to categorize the API's endpoints, and contains the components property storing the reusable data structures, such as DTO schemas and security schemes as named types.At last, the document object includes the security property declaring which security mechanisms would be adjusted to every API endpoints.","server#Server":"export namespace OpenApi {\r\n  /**\r\n   * The remote server that provides the API.\r\n   */\r\n  export interface IServer {\r\n    /**\r\n     * A URL to the target host.\r\n     */\r\n    url: string;\r\n\r\n    /**\r\n     * An optional string describing the target server.\r\n     */\r\n    description?: string;\r\n\r\n    /**\r\n     * A map between a variable name and its value.\r\n     *\r\n     * When the server {@link url} is a type of template, this property\r\n     * would be utilized to fill the template with actual values.\r\n     */\r\n    variables?: Record<string, IServer.IVariable>;\r\n  }\r\n  export namespace IServer {\r\n    /**\r\n     * A variable for the server URL template.\r\n     */\r\n    export interface IVariable {\r\n      /**\r\n       * Default value to use for substitution.\r\n       */\r\n      default: string;\r\n\r\n      /**\r\n       * List of available values for the variable.\r\n       */\r\n      enum?: string[];\r\n\r\n      /**\r\n       * An optional description for the server variable.\r\n       */\r\n      description?: string;\r\n    }\r\n  }\r\n\r\n  export interface IDocument {\r\n    openapi: `3.1.${number}`;\r\n    servers?: IServer[];\r\n    info?: IDocument.IInfo;\r\n    components: IComponents;\r\n    paths?: Record<string, IPath>;\r\n    webhooks?: Record<string, IPath>;\r\n    security?: Record<string, string[]>[];\r\n    tags?: IDocument.ITag[];\r\n    \"x-samchon-emended\": true;\r\n  }\r\n\r\n  export interface IOperation {\r\n    operationId?: string;\r\n    parameters?: IOperation.IParameter[];\r\n    requestBody?: IOperation.IRequestBody;\r\n    responses?: Record<string, IOperation.IResponse>;\r\n    servers?: IServer[];\r\n    summary?: string;\r\n    description?: string;\r\n    security?: Record<string, string[]>[];\r\n    tags?: string[];\r\n    deprecated?: boolean;\r\n  }\r\n}\nIn the OpenAPI definition, server is an object representing the remote server that providing the API.The server object contains the url property, which is the URL of the target host. You can compose the actual API endpoints just by concatenating the server.url and path of the target operation. Sometimes, the server provide the additional property description, and variables to fill the URL template with actual values.Also, the server objects can be defined in both document.servers and operation.servers properties. If a server is defined in the document.servers property, it means that the server's url and its variables (optional) would be applied to every API operations. Otherwise if a server is defined in the operation.servers property, it means that the operation is an exceptional case, so that only the operation uses independent server information.For reference, it is possible to declare multiple server instances in both document.servers and operation.servers properties. Such multiple servers are used for separating real/development/local server addresses in the most cases. Therefore, in the multiple servers case, please read the description property carefully to distinguish the server's purpose.","operation#Operation":"export namespace OpenApi {\r\n  /**\r\n   * Path item.\r\n   *\r\n   * `OpenApi.IPath` represents a path item of emended OpenAPI v3.1,\r\n   * collecting multiple method operations in a single path.\r\n   */\r\n  export interface IPath<\r\n    Schema extends IJsonSchema = IJsonSchema,\r\n    Operation extends IOperation<Schema> = IOperation<Schema>,\r\n  > extends Partial<Record<Method, Operation>> {\r\n    /**\r\n     * Servers that provide the path operations.\r\n     */\r\n    servers?: IServer[];\r\n\r\n    /**\r\n     * Summary of the path.\r\n     */\r\n    summary?: string;\r\n\r\n    /**\r\n     * Description of the path.\r\n     */\r\n    description?: string;\r\n  }\r\n\r\n  /**\r\n   * Remote operation info.\r\n   *\r\n   * `OpenApi.IOperation` represents an Restful API operation provided by the\r\n   * remote server.\r\n   */\r\n  export interface IOperation<Schema extends IJsonSchema = IJsonSchema> {\r\n    /**\r\n     * Unique string used to identify the operation.\r\n     */\r\n    operationId?: string;\r\n\r\n    /**\r\n     * List of parameters that are applicable for this operation.\r\n     */\r\n    parameters?: IOperation.IParameter<Schema>[];\r\n\r\n    /**\r\n     * The request body applicable for this operation.\r\n     */\r\n    requestBody?: IOperation.IRequestBody<Schema>;\r\n\r\n    /**\r\n     * The list of possible responses as they are returned from executing this\r\n     * operation. Its key is the HTTP status code, and the value is the metadata of\r\n     * the response in the HTTP status code.\r\n     */\r\n    responses?: Record<string, IOperation.IResponse<Schema>>;\r\n\r\n    /**\r\n     * A list of servers providing this API operation.\r\n     */\r\n    servers?: IServer[];\r\n\r\n    /**\r\n     * A short summary of what the operation does.\r\n     */\r\n    summary?: string;\r\n\r\n    /**\r\n     * A verbose explanation of the operation behavior.\r\n     */\r\n    description?: string;\r\n\r\n    /**\r\n     * List of securities and their scopes that are required for execution.\r\n     *\r\n     * When this property be configured, the Restful API operation requires\r\n     * the matched security value for exection. Its key means security key\r\n     * matched with {@link OpenApi.IDocument.security}.\r\n     *\r\n     * The value means scopes required for the security key when the security\r\n     * type is {@link OpenApi.ISecurityScheme.IOAuth2}. Otherwise the target\r\n     * security type is not {@link OpenApi.ISecurityScheme.IOAuth2}, the value\r\n     * would be empty array.\r\n     */\r\n    security?: Record<string, string[]>[];\r\n\r\n    /**\r\n     * Tags for API documentation control.\r\n     */\r\n    tags?: string[];\r\n\r\n    /**\r\n     * Flag for indicating this operation is deprecated.\r\n     */\r\n    deprecated?: boolean;\r\n  }\r\n  export namespace IOperation {\r\n    /**\r\n     * Parameter of the operation.\r\n     */\r\n    export interface IParameter<Schema extends IJsonSchema = IJsonSchema> {\r\n      /**\r\n       * Representative name of the parameter.\r\n       *\r\n       * In the most case, the `name` is equivalent to parameter variable name.\r\n       * Therefore, the `name` must be filled with the significant variable name\r\n       * of the parameter.\r\n       *\r\n       * By the way, only when the {@link in} property is `path`, the `name`\r\n       * can be omitted. In that case, the `name` is automatically deduced from\r\n       * the URL path's positional template argument analyzing.\r\n       */\r\n      name?: string;\r\n\r\n      /**\r\n       * Location of the parameter.\r\n       *\r\n       * The `in` property is a string that determines the location of the parameter.\r\n       *\r\n       * - `path`: parameter is part of the path of the URL.\r\n       * - `query`: parameter is part of the query string.\r\n       * - `header`: parameter is part of the header.\r\n       * - `cookie`: parameter is part of the cookie.\r\n       */\r\n      in: \"path\" | \"query\" | \"header\" | \"cookie\";\r\n\r\n      /**\r\n       * Type info of the parameter.\r\n       */\r\n      schema: Schema;\r\n\r\n      /**\r\n       * Whether the parameter is required for execution or not.\r\n       *\r\n       * If the parameter is required, the value must be filled. Otherwise,\r\n       * it is possible to skip the parameter when executing the APi operation.\r\n       *\r\n       * For reference, the `required` property must be always `true` when the\r\n       * {@link in} property is `path`. Otherwise, the `required` property can\r\n       * be anything of them; `true`, `false` and `undefined`.\r\n       */\r\n      required?: boolean;\r\n\r\n      /**\r\n       * Short title of the parameter.\r\n       */\r\n      title?: string;\r\n\r\n      /**\r\n       * Verbose explanation of the parameter.\r\n       */\r\n      description?: string;\r\n\r\n      /**\r\n       * Example value of the parameter.\r\n       */\r\n      example?: any;\r\n\r\n      /**\r\n       * Collection of example values of the parameter with keys.\r\n       */\r\n      examples?: Record<string, IExample>;\r\n    }\r\n\r\n    /**\r\n     * Request body of the operation.\r\n     */\r\n    export interface IRequestBody<Schema extends IJsonSchema = IJsonSchema> {\r\n      content?: IContent<Schema>;\r\n      description?: string;\r\n      required?: boolean;\r\n      \"x-nestia-encrypted\"?: boolean;\r\n    }\r\n\r\n    /**\r\n     * Response of the operation.\r\n     */\r\n    export interface IResponse<Schema extends IJsonSchema = IJsonSchema> {\r\n      headers?: Record<string, IOperation.IParameter<Schema>>;\r\n      content?: IContent<Schema>;\r\n      description?: string;\r\n      \"x-nestia-encrypted\"?: boolean;\r\n    }\r\n\r\n    /**\r\n     * List of content types supported in request/response body.\r\n     */\r\n    export type IContent<Schema extends IJsonSchema = IJsonSchema> = Partial<\r\n      Record<ContentType, IMediaType<Schema>>\r\n    >;\r\n\r\n    /**\r\n     * Media type of a request/response body.\r\n     */\r\n    export interface IMediaType<Schema extends IJsonSchema = IJsonSchema> {\r\n      schema?: Schema;\r\n      example?: any;\r\n      examples?: Record<string, IExample>;\r\n    }\r\n\r\n    /**\r\n     * List of supported content media types.\r\n     */\r\n    export type ContentType =\r\n      | \"text/plain\"\r\n      | \"application/json\"\r\n      | \"application/x-www-form-url-encoded\"\r\n      | \"multipart/form-data\"\r\n      | \"*/*\"\r\n      | (string & {});\r\n  }\r\n}\nIn the OpenAPI definition, OpenApi.IOperationn is an object representing the Restful API function.It is stored in the OpenApi.IDocument.paths property of two-dimensional dictionary structure (Map<string, Map<string, Operation>>); the 1st key is the path and the 2nd key is the HTTP method. Also, it sometimes has a OpenApi.IOperation.servers property when the operation is provided by another server url.OpenApi.IOperation object contains the descriptive information of the operation, such as summary and description. The summary is a short summary of what the operation does, and the description is a verbose explanation of the operation behavior. For reference, those descriptive properties are very important to understand the operation's purpose and behavior to the LLM (Large Language Model) function calling, so that hope to describe them as detailed as possible.At last, the OpenApi.IOperation object has additional properties tags and deprecated. The tags property is used for API documentation level categorizing, and the deprecated property is used for indicating the operation is deprecated or not. When the deprecated property be turned on, the operation is still alive, but means to be removed in the future.","parameter#Parameter":"export namespace OpenApi {\r\n  export interface IOperation<Schema extends IJsonSchema = IJsonSchema> {\r\n    operationId?: string;\r\n    parameters?: IOperation.IParameter<Schema>[];\r\n    requestBody?: IOperation.IRequestBody<Schema>;\r\n    responses?: Record<string, IOperation.IResponse<Schema>>;\r\n    servers?: IServer[];\r\n    summary?: string;\r\n    description?: string;\r\n    security?: Record<string, string[]>[];\r\n    tags?: string[];\r\n    deprecated?: boolean;\r\n  }\r\n  export namespace IOperation {\r\n    /**\r\n     * Parameter of the operation.\r\n     */\r\n    export interface IParameter<Schema extends IJsonSchema = IJsonSchema> {\r\n      /**\r\n       * Representative name of the parameter.\r\n       *\r\n       * In the most case, the `name` is equivalent to parameter variable name.\r\n       * Therefore, the `name` must be filled with the significant variable name\r\n       * of the parameter.\r\n       *\r\n       * By the way, only when the {@link in} property is `path`, the `name`\r\n       * can be omitted. In that case, the `name` is automatically deduced from\r\n       * the URL path's positional template argument analyzing.\r\n       */\r\n      name?: string;\r\n\r\n      /**\r\n       * Location of the parameter.\r\n       *\r\n       * The `in` property is a string that determines the location of the parameter.\r\n       *\r\n       * - `path`: parameter is part of the path of the URL.\r\n       * - `query`: parameter is part of the query string.\r\n       * - `header`: parameter is part of the header.\r\n       * - `cookie`: parameter is part of the cookie.\r\n       */\r\n      in: \"path\" | \"query\" | \"header\" | \"cookie\";\r\n\r\n      /**\r\n       * Type info of the parameter.\r\n       */\r\n      schema: Schema;\r\n\r\n      /**\r\n       * Whether the parameter is required for execution or not.\r\n       *\r\n       * If the parameter is required, the value must be filled. Otherwise,\r\n       * it is possible to skip the parameter when executing the APi operation.\r\n       *\r\n       * For reference, the `required` property must be always `true` when the\r\n       * {@link in} property is `path`. Otherwise, the `required` property can\r\n       * be anything of them; `true`, `false` and `undefined`.\r\n       */\r\n      required?: boolean;\r\n\r\n      /**\r\n       * Short title of the parameter.\r\n       */\r\n      title?: string;\r\n\r\n      /**\r\n       * Verbose explanation of the parameter.\r\n       */\r\n      description?: string;\r\n\r\n      /**\r\n       * Example value of the parameter.\r\n       */\r\n      example?: any;\r\n\r\n      /**\r\n       * Collection of example values of the parameter with keys.\r\n       */\r\n      examples?: Record<string, IExample>;\r\n    }\r\n  }\r\n}\nIn the OpenAPI definition, OpenApi.IOperation.IParameter is an object representing the parameter of the API operation. For reference, in OpenAPI spec, the word \"parameter\" does not contain the request body. It covers only the parameters in the URL \"path\", \"query\", \"header\", and \"cookie\".In the OpenApi.IOperation.IParameter member properties, name property represents a variable name of the parameter, and in property means the category of the parameter. Also, if the parameter category (in) is \"path\", the parameter name can be optional. In that case, \"Wrtn Studio Pro\" duduces the parameter name through the URL path's positional template argument analyzing.Type schema information is stored in the schema property as an OpenApi.IJsonSchema instance, and the required property is used for indicating whether the parameter is essential for the API operation execution or not. By the way, if the category (in) of the parameter is \"path\", the required property must be always true.At last, the OpenApi.IOperation.IParameter object has additional descriptive properties title and description. The title property is a short title of the parameter, and the description property is a verbose explanation of the parameter. For reference, those descriptive properties are very important to understand the parameter's purpose and behavior to the LLM (Large Language Model) function calling, so that hope to describe them as detailed as possible.","requestresponse-body#Request/Response Body":"export namespace OpenApi {\r\n  export interface IOperation<Schema extends IJsonSchema = IJsonSchema> {\r\n    operationId?: string;\r\n    parameters?: IOperation.IParameter<Schema>[];\r\n    requestBody?: IOperation.IRequestBody<Schema>;\r\n    responses?: Record<string, IOperation.IResponse<Schema>>;\r\n    servers?: IServer[];\r\n    summary?: string;\r\n    description?: string;\r\n    security?: Record<string, string[]>[];\r\n    tags?: string[];\r\n    deprecated?: boolean;\r\n  }\r\n  export namespace IOperation {\r\n    /**\r\n     * Request body of the operation.\r\n     */\r\n    export interface IRequestBody<Schema extends IJsonSchema = IJsonSchema> {\r\n      content?: IContent<Schema>;\r\n      description?: string;\r\n      required?: boolean;\r\n      \"x-nestia-encrypted\"?: boolean;\r\n    }\r\n\r\n    /**\r\n     * Response of the operation.\r\n     */\r\n    export interface IResponse<Schema extends IJsonSchema = IJsonSchema> {\r\n      headers?: Record<string, IOperation.IParameter<Schema>>;\r\n      content?: IContent<Schema>;\r\n      description?: string;\r\n      \"x-nestia-encrypted\"?: boolean;\r\n    }\r\n\r\n    /**\r\n     * List of content types supported in request/response body.\r\n     */\r\n    export type IContent<Schema extends IJsonSchema = IJsonSchema> = Partial<\r\n      Record<ContentType, IMediaType<Schema>>\r\n    >;\r\n\r\n    /**\r\n     * Media type of a request/response body.\r\n     */\r\n    export interface IMediaType<Schema extends IJsonSchema = IJsonSchema> {\r\n      schema?: Schema;\r\n      example?: any;\r\n      examples?: Record<string, IExample>;\r\n    }\r\n\r\n    /**\r\n     * List of supported content media types.\r\n     */\r\n    export type ContentType =\r\n      | \"text/plain\"\r\n      | \"application/json\"\r\n      | \"application/x-www-form-url-encoded\"\r\n      | \"multipart/form-data\"\r\n      | \"*/*\"\r\n      | (string & {});\r\n  }\r\n}\nIn the OpenAPI specification, OpenApi.IOperation.IRequestBody and OpenApi.IOperation.IResponse are objects representing the request/response body of the API operation, and they are stored in the OpenApi.IOperation.requestBody and OpenApi.IOperation.responses properties.At first, OpenApi.IOperation.IRequestBody has three properties; content, description and required. As you know can from the property name, description is a verbose explanation of the request body, and required is a flag indicating whether the request body is essential for the API operation execution or not. The other content property is a dictionary structure of the request body's content types and their media types. In the media type (OpenApi.IOperation.IMediaType), the type schema information of the request body is enrolled in the schema property.About the OpenApi.IOperation.responses property is a type of dictionary that the key is the HTTP status code and the value is the metadata of the response in the HTTP status code. OpenApi.IOperation.IResponse is almost same with the OpenApi.IOperation.IRequestBody case, but OpenApi.IOperation.IResponse has an additional property headers that which header values are responsed from executing the operation.At last, there are many content types supported in the request/response body, but \"Wrtn Studio Pro\" handles only the following content types. It is possible to providing the other content types to \"Wrtn Studio Pro\", but only below types can be executed by LLM function calling in the \"Wrtn Studio Pro\".\ntext/plain\napplication/json\napplication/x-www-form-url-encoded\nmultipart/form-data","security-scheme#Security Scheme":"export namespace OpenApi {\r\n  /**\r\n   * Security scheme of Swagger Documents.\r\n   *\r\n   * `OpenApi.ISecurityScheme` is a data structure representing content of\r\n   * `securitySchemes` in `swagger.json` file. It is composed with 5 types of\r\n   * security schemes as an union type like below.\r\n   *\r\n   * @reference https://swagger.io/specification/#security-scheme-object\r\n   */\r\n  export type ISecurityScheme =\r\n    | ISecurityScheme.IApiKey\r\n    | ISecurityScheme.IHttpBasic\r\n    | ISecurityScheme.IHttpBearer\r\n    | ISecurityScheme.IOAuth2\r\n    | ISecurityScheme.IOpenId;\r\n  export namespace ISecurityScheme {\r\n    /**\r\n     * Normal API key type.\r\n     */\r\n    export interface IApiKey {\r\n      type: \"apiKey\";\r\n      in?: \"header\" | \"query\" | \"cookie\";\r\n      name?: string;\r\n      description?: string;\r\n    }\r\n\r\n    /**\r\n     * HTTP basic authentication type.\r\n     */\r\n    export interface IHttpBasic {\r\n      type: \"http\";\r\n      scheme: \"basic\";\r\n      description?: string;\r\n    }\r\n\r\n    /**\r\n     * HTTP bearer authentication type.\r\n     */\r\n    export interface IHttpBearer {\r\n      type: \"http\";\r\n      scheme: \"bearer\";\r\n      bearerFormat?: string;\r\n      description?: string;\r\n    }\r\n\r\n    /**\r\n     * OAuth2 authentication type.\r\n     */\r\n    export interface IOAuth2 {\r\n      type: \"oauth2\";\r\n      flows: IOAuth2.IFlowSet;\r\n      description?: string;\r\n    }\r\n    export interface IOpenId {\r\n      type: \"openIdConnect\";\r\n      openIdConnectUrl: string;\r\n      description?: string;\r\n    }\r\n    export namespace IOAuth2 {\r\n      export interface IFlowSet {\r\n        authorizationCode?: IFlow;\r\n        implicit?: Omit<IFlow, \"tokenUrl\">;\r\n        password?: Omit<IFlow, \"authorizationUrl\">;\r\n        clientCredentials?: Omit<IFlow, \"authorizationUrl\">;\r\n      }\r\n      export interface IFlow {\r\n        authorizationUrl?: string;\r\n        tokenUrl?: string;\r\n        refreshUrl?: string;\r\n        scopes?: Record<string, string>;\r\n      }\r\n    }\r\n  }\r\n\r\n  export interface IComponents<Schema extends IJsonSchema = IJsonSchema> {\r\n    schemas?: Record<string, Schema>;\r\n    securitySchemes?: Record<string, ISecurityScheme>;\r\n  }\r\n\r\n  export interface IDocument<\r\n    Schema extends IJsonSchema = IJsonSchema,\r\n    Operation extends IOperation<Schema> = IOperation<Schema>,\r\n  > {\r\n    openapi: `3.1.${number}`;\r\n    servers?: IServer[];\r\n    info?: IDocument.IInfo;\r\n    components: IComponents<Schema>;\r\n    paths?: Record<string, IPath<Schema, Operation>>;\r\n    webhooks?: Record<string, IPath<Schema, Operation>>;\r\n    security?: Record<string, string[]>[];\r\n    tags?: IDocument.ITag[];\r\n    \"x-samchon-emended\": true;\r\n  }\r\n\r\n  export interface IOperation<Schema extends IJsonSchema = IJsonSchema> {\r\n    operationId?: string;\r\n    parameters?: IOperation.IParameter<Schema>[];\r\n    requestBody?: IOperation.IRequestBody<Schema>;\r\n    responses?: Record<string, IOperation.IResponse<Schema>>;\r\n    servers?: IServer[];\r\n    summary?: string;\r\n    description?: string;\r\n    security?: Record<string, string[]>[];\r\n    tags?: string[];\r\n    deprecated?: boolean;\r\n  }\r\n}\nIn the OpenAPI definition, OpenApi.ISecurityScheme is an union type representing the security scheme of the API. It is placed on the OpenApi.IComponents.securitySchemes property, and referenced by the OpenApi.IDocument.security and OpenApi.IOperation.security properties.When OpenApi.IDocument.security and OpenApi.IOperation.security are referencing the security schemes, its key is the name of the security schema, and the value is the scopes required for the security scheme. The scopes can be used only when the security scheme is oauth2 type, especially for the OpenApi.ISecurityScheme.IOAuth2.IFlow.scopes property. If the target security scheme is not oauth2 type, the scopes value would be an empty array.About individual schema types of the OpenApi.ISecurityScheme, there are 5 types of security schemes. The first OpenApi.ISecurityScheme.IApiKey is a normal API key type, and the second OpenApi.ISecurityScheme.IHttpBasic is an HTTP basic authentication type. The third OpenApi.ISecurityScheme.IHttpBearer is an HTTP bearer authentication type, and the fourth OpenApi.ISecurityScheme.IOAuth2 is an OAuth2 authentication type. The last OpenApi.ISecurityScheme.IOpenId is an OpenID Connect authentication type.","detailed-emendations#Detailed Emendations":"","document-1#Document":"export namespace OpenApi {\r\n  export interface IDocument<\r\n    Schema extends IJsonSchema = IJsonSchema,\r\n    Operation extends IOperation<Schema> = IOperation<Schema>,\r\n  > {\r\n    openapi: `3.1.${number}`;\r\n    servers?: IServer[];\r\n    info?: IDocument.IInfo;\r\n    components: IComponents<Schema>;\r\n    paths?: Record<string, IPath<Schema, Operation>>;\r\n    webhooks?: Record<string, IPath<Schema, Operation>>;\r\n    security?: Record<string, string[]>[];\r\n    tags?: IDocument.ITag[];\r\n    \"x-samchon-emended\": true;\r\n  }\r\n  export interface IComponents<Schema extends IJsonSchema = IJsonSchema> {\r\n    schemas?: Record<string, Schema>;\r\n    securitySchemes?: Record<string, ISecurityScheme>;\r\n  }\r\n}\r\n\r\nexport namespace OpenApiV3_1 {\r\n  export interface IDocument {\r\n    openapi: `3.1.${number}`;\r\n    servers?: IServer[];\r\n    info?: IDocument.IInfo;\r\n    components?: IComponents;\r\n    paths?: Record<string, IPath>;\r\n    webhooks?: Record<\r\n      string,\r\n      | IJsonSchema.IReference<`#/components/pathItems/${string}`> \r\n      | IPath\r\n    >;\r\n    security?: Record<string, string[]>[];\r\n    tags?: IDocument.ITag[];\r\n  }\r\n  export interface IComponents {\r\n    schemas?: Record<string, IJsonSchema>;\r\n    pathItems?: Record<string, IPath>;\r\n    responses?: Record<string, IOperation.IResponse>;\r\n    parameters?: Record<string, IOperation.IParameter>;\r\n    requestBodies?: Record<string, IOperation.IRequestBody>;\r\n    securitySchemes?: Record<string, ISecurityScheme>;\r\n    headers?: Record<string, Omit<IOperation.IParameter, \"in\">>;\r\n    examples?: Record<string, IExample>;\r\n  }\r\n}\nIn the original OpenAPI v3.1 specification, the OpenApiV3_1.IDocument object has an union value typed dynamic record property webhooks. Its values can reference OpenApiV3_1.IComponents object or contain the OpenApiV3_1.IPath objet directly.By the way, OpenApiV3_1.IDocument.paths property is a little bit different with the OpenApiV3_1.IDocument case. Even though its containing value type is exactly equal to the OpenApiV3_1.IDocument.webhooks property, the OpenApiV3_1.IDocument.paths property is not union typed, it cannot reference OpenApiV3_1.IComponents object. Therefore, OpenApiV3_1.IDocument.webhooks can reference the OpenApiV3_1.IComponents object, but it is not suitable for the reusability.To resolve the ambiguous expression of the OpenApiV3_1.IDocument.webhooks property type, OpenApi.IDocument object has been emended to contain the OpenApiV3_1.IDocument.webhooks property as a direct OpenApi.IPath object. If OpenApiV3_1.IDocument.paths was also possible to reference the OpenApiV3_1.IComponents object, I may consider to keeping the OpenApiV3_1.IDocument.webhooks's union value type for reusability, but as you can see, it is not.Anyway, by removing the union typed dynamic record property, the OpenApi.IDocument object becomes more clear and concise. The OpenApi.IDocument becomes significant root object without referencing to nested, and OpenApi.IComponents object is only used for storing the reusable data structures, such as DTO schemas and security schemes.","path#Path":"export namespace OpenApi {\r\n  export interface IPath<\r\n    Schema extends IJsonSchema = IJsonSchema,\r\n    Operation extends IOperation<Schema> = IOperation<Schema>,\r\n  > extends Partial<Record<Method, Operation>> {\r\n    servers?: IServer[];\r\n    summary?: string;\r\n    description?: string;\r\n  }\r\n  export interface IComponents<Schema extends IJsonSchema = IJsonSchema> {\r\n    schemas?: Record<string, Schema>;\r\n    securitySchemes?: Record<string, ISecurityScheme>;\r\n  }\r\n}\r\n\r\nexport namespace OpenApiV3_1 {\r\n  export interface IPath extends Partial<Record<Method, IOperation>> {\r\n    parameters?: Array<\r\n      | IOperation.IParameter\r\n      | IJsonSchema.IReference<`#/components/headers/${string}`>\r\n      | IJsonSchema.IReference<`#/components/parameters/${string}`>\r\n    >;\r\n    servers?: IServer[];\r\n    summary?: string;\r\n    description?: string;\r\n  }\r\n  export interface IOperation {\r\n    operationId?: string;\r\n    parameters?: Array<\r\n      | IOperation.IParameter\r\n      | IJsonSchema.IReference<`#/components/headers/${string}`>\r\n      | IJsonSchema.IReference<`#/components/parameters/${string}`>\r\n    >;\r\n    requestBody?:\r\n      | IOperation.IRequestBody\r\n      | IJsonSchema.IReference<`#/components/requestBodies/${string}`>;\r\n    responses?: Record<\r\n      string,\r\n      | IOperation.IResponse\r\n      | IJsonSchema.IReference<`#/components/responses/${string}`>\r\n    >;\r\n    servers?: IServer[];\r\n    summary?: string;\r\n    description?: string;\r\n    security?: Record<string, string[]>[];\r\n    tags?: string[];\r\n    deprecated?: boolean;\r\n  }\r\n  export interface IComponents {\r\n    schemas?: Record<string, IJsonSchema>;\r\n    pathItems?: Record<string, IPath>;\r\n    responses?: Record<string, IOperation.IResponse>;\r\n    parameters?: Record<string, IOperation.IParameter>;\r\n    requestBodies?: Record<string, IOperation.IRequestBody>;\r\n    securitySchemes?: Record<string, ISecurityScheme>;\r\n    headers?: Record<string, Omit<IOperation.IParameter, \"in\">>;\r\n    examples?: Record<string, IExample>;\r\n  }\r\n}\nIn the original OpenAPI v3.1 specification, the OpenApiV3_1.IPath object can contain parameters property, which can be applied to all operations belonged to the path. If both OpenApiV3_1.IPath and belonged OpenApiV3_1.IOperation objects have their own parameters properties, the OpenApiV3_1.IPath's parameters would be attached to in front of the operation's parameters.As OpenApiV3_1.IPath.parameters property is such ambiguous and duplicated with the OpenApiV3_1.IOperation.parameters property, \"Wrtn Studio Pro\" removes the OpenApi.IPath.parameters property and move it to the children OpenApi.IOperation's parameters property.By removing the OpenApiV3_1.IPath.parameters property, the OpenApi.IPath object comes only a collection of operations with the same path value. Also, only OpenApi.IOperation object handles the properties about the operation subject, the \"Wrtn Studio Pro\" emended OpenAPI specification becomes more clear and concise.","operation-1#Operation":"export namespace OpenApi {\r\n  export interface IOperation<Schema extends IJsonSchema = IJsonSchema> {\r\n    operationId?: string;\r\n    parameters?: IOperation.IParameter<Schema>[];\r\n    requestBody?: IOperation.IRequestBody<Schema>;\r\n    responses?: Record<string, IOperation.IResponse<Schema>>;\r\n    servers?: IServer[];\r\n    summary?: string;\r\n    description?: string;\r\n    security?: Record<string, string[]>[];\r\n    tags?: string[];\r\n    deprecated?: boolean;\r\n  }\r\n  export interface IComponents<Schema extends IJsonSchema = IJsonSchema> {\r\n    schemas?: Record<string, Schema>;\r\n    securitySchemes?: Record<string, ISecurityScheme>;\r\n  }\r\n}\r\n\r\nexport namespace OpenApiV3_1 {\r\n  export interface IOperation {\r\n    operationId?: string;\r\n    parameters?: Array<\r\n      | IOperation.IParameter\r\n      | IJsonSchema.IReference<`#/components/headers/${string}`>\r\n      | IJsonSchema.IReference<`#/components/parameters/${string}`>\r\n    >;\r\n    requestBody?:\r\n      | IOperation.IRequestBody\r\n      | IJsonSchema.IReference<`#/components/requestBodies/${string}`>;\r\n    responses?: Record<\r\n      string,\r\n      | IOperation.IResponse\r\n      | IJsonSchema.IReference<`#/components/responses/${string}`>\r\n    >;\r\n    servers?: IServer[];\r\n    summary?: string;\r\n    description?: string;\r\n    security?: Record<string, string[]>[];\r\n    tags?: string[];\r\n    deprecated?: boolean;\r\n  }\r\n  export interface IComponents {\r\n    schemas?: Record<string, IJsonSchema>;\r\n    pathItems?: Record<string, IPath>;\r\n    responses?: Record<string, IOperation.IResponse>;\r\n    parameters?: Record<string, IOperation.IParameter>;\r\n    requestBodies?: Record<string, IOperation.IRequestBody>;\r\n    securitySchemes?: Record<string, ISecurityScheme>;\r\n    headers?: Record<string, Omit<IOperation.IParameter, \"in\">>;\r\n    examples?: Record<string, IExample>;\r\n  }\r\n}\nIn the original OpenAPI v3.1 specification, the OpenApiV3_1.IOperation object has many union typed properties which references OpenApiV3_1.IComponents or contains metadata information by itself; parameters, requestBody and responses.However, as \"Wrtn Studio Pro\" tends to avoid indirect referencing to the components object for the convenience and clarity, the OpenApi.IOperation object's union typed properties has emended to containn the metadata information by itself.By revmoing such indirect referencing, the OpenApi.IOperation object becomes more clear and concise. It always contains the metadata information of operation by itself, and the OpenApi.IComponents object is only used for storing the reusable data structures, such as DTO schemas and security schemes.","parameter-1#Parameter":"export namespace OpenApi {\r\n  export namespace IOperation {\r\n    export interface IParameter<Schema extends IJsonSchema = IJsonSchema> {\r\n      name?: string;\r\n      in: \"path\" | \"query\" | \"header\" | \"cookie\";\r\n      schema: Schema;\r\n      required?: boolean;\r\n      title?: string;\r\n      description?: string;\r\n      example?: any;\r\n      examples?: Record<string, IExample>;\r\n    }\r\n  }\r\n  export interface IComponents<Schema extends IJsonSchema = IJsonSchema> {\r\n    schemas?: Record<string, Schema>;\r\n    securitySchemes?: Record<string, ISecurityScheme>;\r\n  }\r\n  export interface IExample {\r\n    summary?: string;\r\n    description?: string;\r\n    value?: any;\r\n    externalValue?: string;\r\n  }\r\n}\r\n\r\nexport namespace OpenApiV3_1 {\r\n  export namespace IOperation {\r\n    export interface IParameter {\r\n      name?: string;\r\n      in: \"path\" | \"query\" | \"header\" | \"cookie\";\r\n      schema: IJsonSchema;\r\n      required?: boolean;\r\n      description?: string;\r\n      example?: any;\r\n      examples?: Record<\r\n        string,\r\n        IExample | IJsonSchema.IReference<`#/components/examples/${string}`>\r\n      >;\r\n    }\r\n  }\r\n  export interface IComponents {\r\n    schemas?: Record<string, IJsonSchema>;\r\n    pathItems?: Record<string, IPath>;\r\n    responses?: Record<string, IOperation.IResponse>;\r\n    parameters?: Record<string, IOperation.IParameter>;\r\n    requestBodies?: Record<string, IOperation.IRequestBody>;\r\n    securitySchemes?: Record<string, ISecurityScheme>;\r\n    headers?: Record<string, Omit<IOperation.IParameter, \"in\">>;\r\n    examples?: Record<string, IExample>;\r\n  }\r\n  export interface IExample {\r\n    summary?: string;\r\n    description?: string;\r\n    value?: any;\r\n    externalValue?: string;\r\n  }\r\n}\nIn the original OpenAPI v3.1 specification, the OpenApiV3_1.IOperation.IParameter has examples property, and the examples has an union typed value which references OpenApiV3_1.IComponents or contains the example value by itself.However, as \"Wrtn Studio Pro\" tends to avoid indirect referencing to the components object for the convenience and clarity, the OpenApi.IOperation.IParameter.examples has emended to only contain the example values by itself, instead of referencing the components object.By revmoing such indirect referencing, the OpenApi.IOperation.IParameter object becomes more clear and concise. It always contains the metadata information of operation by itself, and the OpenApi.IComponents object is only used for storing the reusable data structures, such as DTO schemas and security schemes."}},"/tech-specs/openapi/plugin":{"title":"Plugin","data":{"json-schema#JSON Schema":"We are defining surplus plugin properties for special purposes.\nexport namespace ISwaggerSchema {\r\n  /**\r\n   * String type info.\r\n   */\r\n  export interface IString extends OpenApi.IJsonSchema.IString, __IAttribute {\r\n    /**\r\n     * Secret key for the schema.\r\n     *\r\n     * `x-wrtn-secret-key` is a property means a secret key that is required\r\n     * for the target API endpoint calling. If the secret key is not filled,\r\n     * the API call would be failed.\r\n     */\r\n    \"x-wrtn-secret-key\"?: string;\r\n\r\n    /**\r\n     * Secret scopes for the schema.\r\n     *\r\n     * `x-wrtn-secret-scopes` is a property means a list of secret scopes that\r\n     * are required for the target API endpoint calling. If the secret scopes\r\n     * are not satisfied, the API call would be failed.\r\n     */\r\n    \"x-wrtn-secret-scopes\"?: string[];\r\n  }\r\n\r\n  /**\r\n   * Plugin properties for every types.\r\n   */\r\n  export interface __IAttribute {\r\n    /**\r\n     * Placeholder value for frontend application.\r\n     *\r\n     * Placeholder means the value to be shown in the input field as a hint.\r\n     * For example, when an email input field exists, the placeholder value\r\n     * would be \"Insert your email address here\".\r\n     */\r\n    \"x-wrtn-placeholder\"?: string;\r\n\r\n    /**\r\n     * Prerequisite API endpoint for the schema.\r\n     *\r\n     * `x-wrtn-prerequisite` is a property representing the prerequisite API\r\n     * interaction. It means that, the endpoint API should be called before\r\n     * calling the target API, for composing some argument value.\r\n     *\r\n     * @reference https://github.com/wrtnio/decorators/blob/main/src/Prerequisite.ts\r\n     */\r\n    \"x-wrtn-prerequisite\"?: {\r\n      /**\r\n       * HTTP method to call the endpoint.\r\n       */\r\n      method: \"get\" | \"post\" | \"patch\" | \"put\" | \"delete\";\r\n\r\n      /**\r\n       * Path of the endpoint.\r\n       */\r\n      path: string;\r\n\r\n      /**\r\n       * Function returning transformed values using JMESPath expression.\r\n       *\r\n       * `Prerequisite.Props.jmesPath` is a string typed property that extracts desired values\r\n       * from the prerequisite API response using a JMESPath expression. This property simplifies\r\n       * and replaces the `label`, `value`, and `array` properties.\r\n       *\r\n       * JMESPath expressions are used to extract the desired data based on the API response.\r\n       * The expression must always be a valid JMESPath syntax.\r\n       *\r\n       * - Type: `jmesPath: string`\r\n       * - Example: `\"members[*].data.title\"`\r\n       * - Usage: `jmespath.search(response, jmesPath)`\r\n       *\r\n       * Note: The `label`, `value`, and `array` properties are no longer in use.\r\n       */\r\n      jmesPath: string;\r\n    };\r\n  }\r\n}\nexport namespace OpenApi {\r\n  export type IJsonSchema =\r\n    | IJsonSchema.IConstant\r\n    | IJsonSchema.IBoolean\r\n    | IJsonSchema.IInteger\r\n    | IJsonSchema.INumber\r\n    | IJsonSchema.IString\r\n    | IJsonSchema.IArray\r\n    | IJsonSchema.ITuple\r\n    | IJsonSchema.IObject\r\n    | IJsonSchema.IReference\r\n    | IJsonSchema.IOneOf\r\n    | IJsonSchema.INull\r\n    | IJsonSchema.IUnknown;\r\n  export namespace IJsonSchema {\r\n    export interface IConstant extends __IAttribute {\r\n      const: boolean | number | string;\r\n    }\r\n    export interface IBoolean extends __ISignificant<\"boolean\"> {\r\n      default?: boolean;\r\n    }\r\n    export interface IInteger extends __ISignificant<\"integer\"> {\r\n      /** @type int64 */ default?: number;\r\n      /** @type int64 */ minimum?: number;\r\n      /** @type int64 */ maximum?: number;\r\n      exclusiveMinimum?: boolean;\r\n      exclusiveMaximum?: boolean;\r\n      /**\r\n       * @type uint64\r\n       * @exclusiveMinimum 0\r\n       */\r\n      multipleOf?: number;\r\n    }\r\n    export interface INumber extends __ISignificant<\"number\"> {\r\n      default?: number;\r\n      minimum?: number;\r\n      maximum?: number;\r\n      exclusiveMinimum?: boolean;\r\n      exclusiveMaximum?: boolean;\r\n      /** @exclusiveMinimum 0 */ multipleOf?: number;\r\n    }\r\n    export interface IString extends __ISignificant<\"string\"> {\r\n      default?: string;\r\n      format?:\r\n        | \"binary\"\r\n        | \"byte\"\r\n        | \"password\"\r\n        | \"regex\"\r\n        | \"uuid\"\r\n        | \"email\"\r\n        | \"hostname\"\r\n        | \"idn-email\"\r\n        | \"idn-hostname\"\r\n        | \"iri\"\r\n        | \"iri-reference\"\r\n        | \"ipv4\"\r\n        | \"ipv6\"\r\n        | \"uri\"\r\n        | \"uri-reference\"\r\n        | \"uri-template\"\r\n        | \"url\"\r\n        | \"date-time\"\r\n        | \"date\"\r\n        | \"time\"\r\n        | \"duration\"\r\n        | \"json-pointer\"\r\n        | \"relative-json-pointer\"\r\n        | (string & {});\r\n      pattern?: string;\r\n      contentMediaType?: string;\r\n      /** @type uint64 */ minLength?: number;\r\n      /** @type uint64 */ maxLength?: number;\r\n    }\r\n\r\n    export interface IArray<Schema extends IJsonSchema = IJsonSchema>\r\n      extends __ISignificant<\"array\"> {\r\n      items: Schema;\r\n      uniqueItems?: boolean;\r\n      /** @type uint64 */ minItems?: number;\r\n      /** @type uint64 */ maxItems?: number;\r\n    }\r\n    export interface ITuple<Schema extends IJsonSchema = IJsonSchema>\r\n      extends __ISignificant<\"array\"> {\r\n      prefixItems: Schema[];\r\n      additionalItems?: boolean | Schema;\r\n      uniqueItems?: boolean;\r\n      /** @type uint64 */ minItems?: number;\r\n      /** @type uint64 */ maxItems?: number;\r\n    }\r\n    export interface IObject<Schema extends IJsonSchema = IJsonSchema>\r\n      extends __ISignificant<\"object\"> {\r\n      properties?: Record<string, Schema>;\r\n      additionalProperties?: boolean | Schema;\r\n      required?: string[];\r\n    }\r\n\r\n    export interface IReference<Key = string> extends __IAttribute {\r\n      $ref: Key;\r\n    }\r\n    export interface IOneOf<Schema extends IJsonSchema = IJsonSchema>\r\n      extends __IAttribute {\r\n      oneOf: Exclude<Schema, IJsonSchema.IOneOf>[];\r\n      discriminator?: IOneOf.IDiscriminator;\r\n    }\r\n    export namespace IOneOf {\r\n      export interface IDiscriminator {\r\n        propertyName: string;\r\n        mapping?: Record<string, string>;\r\n      }\r\n    }\r\n    export interface INull extends __ISignificant<\"null\"> {\r\n      default?: null;\r\n    }\r\n    export interface IUnknown extends __IAttribute {\r\n      type?: undefined;\r\n    }\r\n\r\n    export interface __ISignificant<Type extends string> extends __IAttribute {\r\n      type: Type;\r\n    }\r\n    export interface __IAttribute {\r\n      title?: string;\r\n      description?: string;\r\n      deprecated?: boolean;\r\n    }\r\n  }\r\n}\n\"Wrtn Studio Pro\" is defining surplus plugin properties to JSON schema for special purposes.At first, \"Wrtn Studio Pro\" has defined two additional properties to the string type; x-wrtn-secret-key and x-wrtn-secret-scopes. When those properties are specified, it means that the target value must be filled with the secret value which satisfies the secret key and scopes.For example, in the \"Wrtn Studio Pro\", you can send an email in the chatting room through the G-Mail service. To send an email through the G-Mail service, you need to fill the secret value of the Google manually. Therefore, below G-Mail sending related JSON schema has the x-wrtn-secret-key and x-wrtn-secret-scopes properties to specify the secret key and scopes.\n{\r\n  \"type\": \"object\",\r\n  \"properties\": {\r\n    \"to\": {\r\n      \"type\": \"array\",\r\n      \"items\": {\r\n        \"type\": \"string\"\r\n      },\r\n      \"title\": \"Email address of the receipant.\"\r\n    },\r\n    \"subject\": {\r\n      \"type\": \"string\",\r\n      \"title\": \"Title of the email content.\"\r\n    },\r\n    \"body\": {\r\n      \"type\": \"string\",\r\n      \"title\": \"Body of the email content.\",\r\n      \"description\": \"Mail content body of the email sending.\\n\\nThe content must be written in the HTML format. If not, the content body can be broken.\\n\\nAlso, adjust only the G-Mail adjustable CSS styles.\\n\\nAt last, please do not write too long content. If the content length is too much long, e-mail sending can be failure.\"\r\n    },\r\n    \"cc\": {\r\n      \"type\": \"array\",\r\n      \"items\": {\r\n        \"type\": \"string\"\r\n      },\r\n      \"title\": \"List of reference email list\"\r\n    },\r\n    \"Bcc\": {\r\n      \"type\": \"array\",\r\n      \"items\": {\r\n        \"type\": \"string\"\r\n      },\r\n      \"title\": \"List of hidden reference email list\"\r\n    },\r\n    \"secretKey\": {\r\n      \"type\": \"string\",\r\n      \"x-wrtn-secret-key\": \"google\",\r\n      \"x-wrtn-secret-scopes\": [\r\n        \"https://mail.google.com/\"\r\n      ],\r\n      \"title\": \"Authentification key for the G-Mail service.\"\r\n    }\r\n  },\r\n  \"required\": [\r\n    \"to\",\r\n    \"subject\",\r\n    \"body\",\r\n    \"secretKey\"\r\n  ],\r\n  \"title\": \"The information for sending an email through the G-Mail service.\"\r\n}\nAlso, \"Wrtn Studio Pro\" has defined some additional properties to every JSON schema types. The additional properties are x-wrtn-placeholder and x-wrtn-prerequisite.The first property x-wrtn-placeholder is a property to show a hint label in the input field. For example, when there is a string typed JSON schema with email format, the x-wrtn-placeholder property would be written like \"Insert your e-mail address please\".The other property x-wrtn-prerequisite is a property indicating the prerequisite API interaction. It means that the prerequisite API should be called befored composing the target value of the JSON schema. method and path member properties of the x-wrtn-prerequisite are the HTTP method and path of the prerequisite API endpoint. The jmesPath member property is a JMESPath expression to extract the desired values from the prerequisite API response.","operation#Operation":"/**\r\n * Remote operation info.\r\n *\r\n * `ISwaggerOperation` represents an Restful API operation provided by the\r\n * remote server.\r\n */\r\nexport interface ISwaggerOperation extends OpenApi.IOperation<ISwaggerSchema> {\r\n  /**\r\n   * Icon URL.\r\n   *\r\n   * `x-wrtn-icon` is a property means an icon URL representing the target API.\r\n   */\r\n  \"x-wrtn-icon\"?: string & tags.Format<\"uri\">;\r\n}\nexport namespace OpenApi {\r\n  /**\r\n   * Remote operation info.\r\n   *\r\n   * `OpenApi.IOperation` represents an Restful API operation provided by the\r\n   * remote server.\r\n   */\r\n  export interface IOperation<Schema extends IJsonSchema = IJsonSchema> {\r\n    /**\r\n     * Unique string used to identify the operation.\r\n     */\r\n    operationId?: string;\r\n\r\n    /**\r\n     * List of parameters that are applicable for this operation.\r\n     */\r\n    parameters?: IOperation.IParameter<Schema>[];\r\n\r\n    /**\r\n     * The request body applicable for this operation.\r\n     */\r\n    requestBody?: IOperation.IRequestBody<Schema>;\r\n\r\n    /**\r\n     * The list of possible responses as they are returned from executing this\r\n     * operation. Its key is the HTTP status code, and the value is the metadata of\r\n     * the response in the HTTP status code.\r\n     */\r\n    responses?: Record<string, IOperation.IResponse<Schema>>;\r\n\r\n    /**\r\n     * A list of servers providing this API operation.\r\n     */\r\n    servers?: IServer[];\r\n\r\n    /**\r\n     * A short summary of what the operation does.\r\n     */\r\n    summary?: string;\r\n\r\n    /**\r\n     * A verbose explanation of the operation behavior.\r\n     */\r\n    description?: string;\r\n\r\n    /**\r\n     * List of securities and their scopes that are required for execution.\r\n     *\r\n     * When this property be configured, the Restful API operation requires\r\n     * the matched security value for exection. Its key means security key\r\n     * matched with {@link OpenApi.IDocument.security}.\r\n     *\r\n     * The value means scopes required for the security key when the security\r\n     * type is {@link OpenApi.ISecurityScheme.IOAuth2}. Otherwise the target\r\n     * security type is not {@link OpenApi.ISecurityScheme.IOAuth2}, the value\r\n     * would be empty array.\r\n     */\r\n    security?: Record<string, string[]>[];\r\n\r\n    /**\r\n     * Tags for API documentation control.\r\n     */\r\n    tags?: string[];\r\n\r\n    /**\r\n     * Flag for indicating this operation is deprecated.\r\n     */\r\n    deprecated?: boolean;\r\n  }\r\n}\n\"Wrtn Studio Pro\" is defining plugin property x-wrtn-icon to the OpenApi.IOperatio object.It is to show representative icon images for each API operation.Here is the example operation case shown in the \"Wrtn Studio Pro\" service.","document#Document":"export namespace OpenApi {\r\n  /**\r\n   * OpenAPI document.\r\n   *\r\n   * `OpenApi.IDocument` represents an OpenAPI document of emended OpenAPI v3.1.\r\n   *\r\n   * In other words, `OpenApi.IDocument` is a structure of `swagger.json` file of\r\n   * OpenAPI v3.1 specification, but a little bit shrinked to remove ambiguous and\r\n   * duplicated expressions of OpenAPI v3.1 for the convenience and clarity.\r\n   *\r\n   * @template Schema JSON schema type\r\n   * @template Operation HTTP operation type\r\n   */\r\n  export interface IDocument<\r\n    Schema extends IJsonSchema = IJsonSchema,\r\n    Operation extends IOperation<Schema> = IOperation<Schema>,\r\n  > {\r\n    /**\r\n     * Flag for indicating this document is emended by `@samchon/openapi`.\r\n     */\r\n    \"x-samchon-emended\": true;\r\n\r\n    /**\r\n     * OpenAPI version number.\r\n     */\r\n    openapi: `3.1.${number}`;\r\n\r\n    /**\r\n     * List of servers that provide the API.\r\n     */\r\n    servers?: IServer[];\r\n\r\n    /**\r\n     * Information about the API.\r\n     */\r\n    info?: IDocument.IInfo;\r\n\r\n    /**\r\n     * An object to hold reusable data structures.\r\n     *\r\n     * It stores both DTO schemas and security schemes.\r\n     *\r\n     * For reference, `nestia` defines every object and alias types as reusable DTO\r\n     * schemas. The alias type means that defined by `type` keyword in TypeScript.\r\n     */\r\n    components: IComponents<Schema>;\r\n\r\n    /**\r\n     * The available paths and operations for the API.\r\n     *\r\n     * The 1st key is the path, and the 2nd key is the HTTP method.\r\n     */\r\n    paths?: Record<string, IPath<Schema, Operation>>;\r\n\r\n    /**\r\n     * An object to hold Webhooks.\r\n     *\r\n     * Its structure is same with {@link paths}, so that the 1st key is the path,\r\n     * and the 2nd key is the HTTP method.\r\n     */\r\n    webhooks?: Record<string, IPath<Schema, Operation>>;\r\n\r\n    /**\r\n     * A declaration of which security mechanisms can be used across the API.\r\n     *\r\n     * When this property be configured, it would be overwritten in every API routes.\r\n     *\r\n     * For reference, key means the name of security scheme and value means the `scopes`.\r\n     * The `scopes` can be used only when target security scheme is `oauth2` type,\r\n     * especially for {@link ISwaggerSecurityScheme.IOAuth2.IFlow.scopes} property.\r\n     */\r\n    security?: Record<string, string[]>[];\r\n\r\n    /**\r\n     * List of tag names with description.\r\n     *\r\n     * It is possible to omit this property or skip some tag name even if\r\n     * the tag name is used in the API routes. In that case, the tag name\r\n     * would be displayed (in Swagger-UI) without description.\r\n     */\r\n    tags?: IDocument.ITag[];\r\n  }\r\n}\n\"Wrtn Studio Pro\" utilizing emended OpenAPI v3.1 specification has special property on the OpenApi.IDocument object. The property is x-samchon-emended and it is a flag for indicating this document is emended by @samchon/openapi.If the x-samchon-emended is false or undefined, it means that the document has not been emended yet. In that case, \"Wrtn Studio Pro\" automatically emends the document by @samchon/openapi and sets the x-samchon-emended flag to be true."}},"/tech-specs/openapi/json":{"title":"Json","data":{"concepts#Concepts":"\"Wrtn Studio Pro\" has adopted OpenAPI v3.1 specified JSON schema definitions with some emendations.\"Wrtn Studio Pro\" is utilizng OpenAPI v3.1 specification and its following schema defining rule of \"JSON schema draft 2020-12\", for every schema definitions like API marketplace sales and Workflow Engine. If customer uploads a different version of OpenAPI specified JSON schema in the API marketplace, \"Wrtn Studio Pro\" will convert it to the JSON schema draft 2020-12 version.By the way, as JSON schema draft 2020-12 version has many synonym definitions of same meaning, \"Wrtn Studio Pro\" has emended the JSON schema draft 2020-12 version a little bit for clarity and consistency. Below is the list of JSON schema definitions in each OpenAPI version including the emended by \"Wrtn Studio Pro\".For reference, if user takes an original OpenAPI v3.1 specified document witout emendation or previous version than OpenAPI v3.1, \"Wrtn Studio Pro\" automatically converts it to the emended OpenAPI v3.1 version.\nOpenAPI v3.1 emended\nOpenAPI v3.1\nOpenAPI v3.0\nSwagger v2.0\nexport namespace OpenApi {\r\n  export type IJsonSchema =\r\n    | IJsonSchema.IConstant\r\n    | IJsonSchema.IBoolean\r\n    | IJsonSchema.IInteger\r\n    | IJsonSchema.INumber\r\n    | IJsonSchema.IString\r\n    | IJsonSchema.IArray\r\n    | IJsonSchema.ITuple\r\n    | IJsonSchema.IObject\r\n    | IJsonSchema.IReference\r\n    | IJsonSchema.IOneOf\r\n    | IJsonSchema.INull\r\n    | IJsonSchema.IUnknown;\r\n  export namespace IJsonSchema {\r\n    export interface IConstant extends __IAttribute {\r\n      const: boolean | number | string;\r\n    }\r\n    export interface IBoolean extends __ISignificant<\"boolean\"> {\r\n      default?: boolean;\r\n    }\r\n    export interface IInteger extends __ISignificant<\"integer\"> {\r\n      /** @type int64 */ default?: number;\r\n      /** @type int64 */ minimum?: number;\r\n      /** @type int64 */ maximum?: number;\r\n      exclusiveMinimum?: boolean;\r\n      exclusiveMaximum?: boolean;\r\n      /**\r\n       * @type uint64\r\n       * @exclusiveMinimum 0\r\n       */\r\n      multipleOf?: number;\r\n    }\r\n    export interface INumber extends __ISignificant<\"number\"> {\r\n      default?: number;\r\n      minimum?: number;\r\n      maximum?: number;\r\n      exclusiveMinimum?: boolean;\r\n      exclusiveMaximum?: boolean;\r\n      /** @exclusiveMinimum 0 */ multipleOf?: number;\r\n    }\r\n    export interface IString extends __ISignificant<\"string\"> {\r\n      default?: string;\r\n      format?:\r\n        | \"binary\"\r\n        | \"byte\"\r\n        | \"password\"\r\n        | \"regex\"\r\n        | \"uuid\"\r\n        | \"email\"\r\n        | \"hostname\"\r\n        | \"idn-email\"\r\n        | \"idn-hostname\"\r\n        | \"iri\"\r\n        | \"iri-reference\"\r\n        | \"ipv4\"\r\n        | \"ipv6\"\r\n        | \"uri\"\r\n        | \"uri-reference\"\r\n        | \"uri-template\"\r\n        | \"url\"\r\n        | \"date-time\"\r\n        | \"date\"\r\n        | \"time\"\r\n        | \"duration\"\r\n        | \"json-pointer\"\r\n        | \"relative-json-pointer\"\r\n        | (string & {});\r\n      pattern?: string;\r\n      contentMediaType?: string;\r\n      /** @type uint64 */ minLength?: number;\r\n      /** @type uint64 */ maxLength?: number;\r\n    }\r\n\r\n    export interface IArray<Schema extends IJsonSchema = IJsonSchema>\r\n      extends __ISignificant<\"array\"> {\r\n      items: Schema;\r\n      uniqueItems?: boolean;\r\n      /** @type uint64 */ minItems?: number;\r\n      /** @type uint64 */ maxItems?: number;\r\n    }\r\n    export interface ITuple<Schema extends IJsonSchema = IJsonSchema>\r\n      extends __ISignificant<\"array\"> {\r\n      prefixItems: Schema[];\r\n      additionalItems?: boolean | Schema;\r\n      uniqueItems?: boolean;\r\n      /** @type uint64 */ minItems?: number;\r\n      /** @type uint64 */ maxItems?: number;\r\n    }\r\n    export interface IObject<Schema extends IJsonSchema = IJsonSchema>\r\n      extends __ISignificant<\"object\"> {\r\n      properties?: Record<string, Schema>;\r\n      additionalProperties?: boolean | Schema;\r\n      required?: string[];\r\n    }\r\n\r\n    export interface IReference<Key = string> extends __IAttribute {\r\n      $ref: Key;\r\n    }\r\n    export interface IOneOf<Schema extends IJsonSchema = IJsonSchema>\r\n      extends __IAttribute {\r\n      oneOf: Exclude<Schema, IJsonSchema.IOneOf>[];\r\n      discriminator?: IOneOf.IDiscriminator;\r\n    }\r\n    export namespace IOneOf {\r\n      export interface IDiscriminator {\r\n        propertyName: string;\r\n        mapping?: Record<string, string>;\r\n      }\r\n    }\r\n    export interface INull extends __ISignificant<\"null\"> {\r\n      default?: null;\r\n    }\r\n    export interface IUnknown extends __IAttribute {\r\n      type?: undefined;\r\n    }\r\n\r\n    export interface __ISignificant<Type extends string> extends __IAttribute {\r\n      type: Type;\r\n    }\r\n    export interface __IAttribute {\r\n      title?: string;\r\n      description?: string;\r\n      deprecated?: boolean;\r\n    }\r\n  }\r\n}\nexport namespace OpenApiV3_1 {\r\n  export type IJsonSchema =\r\n    | IJsonSchema.IMixed\r\n    | IJsonSchema.IConstant\r\n    | IJsonSchema.IBoolean\r\n    | IJsonSchema.IInteger\r\n    | IJsonSchema.INumber\r\n    | IJsonSchema.IString\r\n    | IJsonSchema.IArray\r\n    | IJsonSchema.IObject\r\n    | IJsonSchema.IReference\r\n    | IJsonSchema.IRecursiveReference\r\n    | IJsonSchema.IUnknown\r\n    | IJsonSchema.INull\r\n    | IJsonSchema.IAllOf\r\n    | IJsonSchema.IAnyOf\r\n    | IJsonSchema.IOneOf;\r\n  export namespace IJsonSchema {\r\n    export interface IMixed\r\n      extends IConstant,\r\n        Omit<IBoolean, \"type\" | \"default\" | \"enum\">,\r\n        Omit<INumber, \"type\" | \"default\" | \"enum\">,\r\n        Omit<IString, \"type\" | \"default\" | \"enum\">,\r\n        Omit<IArray, \"type\">,\r\n        Omit<IObject, \"type\">,\r\n        IOneOf,\r\n        IAnyOf,\r\n        IAllOf {\r\n      type: Array<\r\n        \"boolean\" | \"integer\" | \"number\" | \"string\" | \"array\" | \"object\"\r\n      >;\r\n      default?: any[];\r\n      enum?: any[];\r\n    }\r\n\r\n    export interface IConstant extends __IAttribute {\r\n      const: boolean | number | string;\r\n    }\r\n    export interface IBoolean extends __ISignificant<\"boolean\"> {\r\n      default?: boolean | null;\r\n      enum?: Array<boolean | null>;\r\n    }\r\n    export interface IInteger extends __ISignificant<\"integer\"> {\r\n      /** @type int64 */ default?: number | null;\r\n      /** @type int64 */ enum?: Array<number | null>;\r\n      /** @type int64 */ minimum?: number;\r\n      /** @type int64 */ maximum?: number;\r\n      /** @type int64 */ exclusiveMinimum?: number | boolean;\r\n      /** @type int64 */ exclusiveMaximum?: number | boolean;\r\n      /**\r\n       * @type uint64\r\n       * @exclusiveMinimum 0\r\n       */\r\n      multipleOf?: number;\r\n    }\r\n    export interface INumber extends __ISignificant<\"number\"> {\r\n      default?: number | null;\r\n      enum?: Array<number | null>;\r\n      minimum?: number;\r\n      maximum?: number;\r\n      exclusiveMinimum?: number | boolean;\r\n      exclusiveMaximum?: number | boolean;\r\n      /** @exclusiveMinimum 0 */ multipleOf?: number;\r\n    }\r\n    export interface IString extends __ISignificant<\"string\"> {\r\n      contentMediaType?: string;\r\n      default?: string | null;\r\n      enum?: Array<string | null>;\r\n      format?:\r\n        | \"binary\"\r\n        | \"byte\"\r\n        | \"password\"\r\n        | \"regex\"\r\n        | \"uuid\"\r\n        | \"email\"\r\n        | \"hostname\"\r\n        | \"idn-email\"\r\n        | \"idn-hostname\"\r\n        | \"iri\"\r\n        | \"iri-reference\"\r\n        | \"ipv4\"\r\n        | \"ipv6\"\r\n        | \"uri\"\r\n        | \"uri-reference\"\r\n        | \"uri-template\"\r\n        | \"url\"\r\n        | \"date-time\"\r\n        | \"date\"\r\n        | \"time\"\r\n        | \"duration\"\r\n        | \"json-pointer\"\r\n        | \"relative-json-pointer\"\r\n        | (string & {});\r\n      pattern?: string;\r\n      /** @type uint64 */ minLength?: number;\r\n      /** @type uint64 */ maxLength?: number;\r\n    }\r\n\r\n    export interface IUnknown extends __IAttribute {\r\n      type?: undefined;\r\n    }\r\n    export interface INull extends __ISignificant<\"null\"> {\r\n      default?: null;\r\n    }\r\n    export interface IAllOf extends __IAttribute {\r\n      allOf: IJsonSchema[];\r\n    }\r\n    export interface IAnyOf extends __IAttribute {\r\n      anyOf: IJsonSchema[];\r\n    }\r\n    export interface IOneOf extends __IAttribute {\r\n      oneOf: IJsonSchema[];\r\n      discriminator?: IOneOf.IDiscriminator;\r\n    }\r\n    export namespace IOneOf {\r\n      export interface IDiscriminator {\r\n        propertyName: string;\r\n        mapping?: Record<string, string>;\r\n      }\r\n    }\r\n\r\n    export interface IArray extends __ISignificant<\"array\"> {\r\n      items: IJsonSchema | IJsonSchema[];\r\n      prefixItems?: IJsonSchema[];\r\n      uniqueItems?: boolean;\r\n      additionalItems?: boolean | IJsonSchema;\r\n      /** @type uint64 */ minItems?: number;\r\n      /** @type uint64 */ maxItems?: number;\r\n    }\r\n    export interface IObject extends __ISignificant<\"object\"> {\r\n      properties?: Record<string, IJsonSchema>;\r\n      required?: string[];\r\n      additionalProperties?: boolean | IJsonSchema;\r\n      maxProperties?: number;\r\n      minProperties?: number;\r\n    }\r\n    export interface IReference<Key = string> extends __IAttribute {\r\n      $ref: Key;\r\n    }\r\n    export interface IRecursiveReference extends __IAttribute {\r\n      $recursiveRef: string;\r\n    }\r\n\r\n    export interface __ISignificant<Type extends string> extends __IAttribute {\r\n      type: Type;\r\n      nullable?: boolean;\r\n    }\r\n    export interface __IAttribute {\r\n      title?: string;\r\n      description?: string;\r\n      deprecated?: boolean;\r\n    }\r\n  }\r\n}\nexport namespace OpenApiV3 {\r\n  export type IJsonSchema =\r\n    | IJsonSchema.IBoolean\r\n    | IJsonSchema.IInteger\r\n    | IJsonSchema.INumber\r\n    | IJsonSchema.IString\r\n    | IJsonSchema.IArray\r\n    | IJsonSchema.IObject\r\n    | IJsonSchema.IReference\r\n    | IJsonSchema.IUnknown\r\n    | IJsonSchema.INullOnly\r\n    | IJsonSchema.IAllOf\r\n    | IJsonSchema.IAnyOf\r\n    | IJsonSchema.IOneOf;\r\n  export namespace IJsonSchema {\r\n    export interface IBoolean extends __ISignificant<\"boolean\"> {\r\n      default?: boolean | null;\r\n      enum?: Array<boolean | null>;\r\n    }\r\n    export interface IInteger extends __ISignificant<\"integer\"> {\r\n      /** @type int64 */ default?: number | null;\r\n      /** @type int64 */ enum?: Array<number | null>;\r\n      /** @type int64 */ minimum?: number;\r\n      /** @type int64 */ maximum?: number;\r\n      exclusiveMinimum?: boolean;\r\n      exclusiveMaximum?: boolean;\r\n      /**\r\n       * @type uint64\r\n       * @exclusiveMinimum 0\r\n       */\r\n      multipleOf?: number;\r\n    }\r\n    export interface INumber extends __ISignificant<\"number\"> {\r\n      default?: number | null;\r\n      enum?: Array<number | null>;\r\n      minimum?: number;\r\n      maximum?: number;\r\n      exclusiveMinimum?: boolean;\r\n      exclusiveMaximum?: boolean;\r\n      /** @exclusiveMinimum 0 */ multipleOf?: number;\r\n    }\r\n    export interface IString extends __ISignificant<\"string\"> {\r\n      default?: string | null;\r\n      enum?: string[];\r\n      format?:\r\n        | \"binary\"\r\n        | \"byte\"\r\n        | \"password\"\r\n        | \"regex\"\r\n        | \"uuid\"\r\n        | \"email\"\r\n        | \"hostname\"\r\n        | \"idn-email\"\r\n        | \"idn-hostname\"\r\n        | \"iri\"\r\n        | \"iri-reference\"\r\n        | \"ipv4\"\r\n        | \"ipv6\"\r\n        | \"uri\"\r\n        | \"uri-reference\"\r\n        | \"uri-template\"\r\n        | \"url\"\r\n        | \"date-time\"\r\n        | \"date\"\r\n        | \"time\"\r\n        | \"duration\"\r\n        | \"json-pointer\"\r\n        | \"relative-json-pointer\"\r\n        | (string & {});\r\n      pattern?: string;\r\n      /** @type uint64 */ minLength?: number;\r\n      /** @type uint64 */ maxLength?: number;\r\n    }\r\n\r\n    export interface IArray extends __ISignificant<\"array\"> {\r\n      items: IJsonSchema;\r\n      uniqueItems?: boolean;\r\n      /** @type uint64 */ minItems?: number;\r\n      /** @type uint64 */ maxItems?: number;\r\n    }\r\n    export interface IObject extends __ISignificant<\"object\"> {\r\n      properties?: Record<string, IJsonSchema>;\r\n      required?: string[];\r\n      additionalProperties?: boolean | IJsonSchema;\r\n      maxProperties?: number;\r\n      minProperties?: number;\r\n    }\r\n    export interface IReference<Key = string> extends __IAttribute {\r\n      $ref: Key;\r\n    }\r\n\r\n    export interface IUnknown extends __IAttribute {\r\n      type?: undefined;\r\n    }\r\n    export interface INullOnly extends __IAttribute {\r\n      type: \"null\";\r\n    }\r\n    export interface IAllOf extends __IAttribute {\r\n      allOf: IJsonSchema[];\r\n    }\r\n    export interface IAnyOf extends __IAttribute {\r\n      anyOf: IJsonSchema[];\r\n    }\r\n    export interface IOneOf extends __IAttribute {\r\n      oneOf: IJsonSchema[];\r\n      discriminator?: IOneOf.IDiscriminator;\r\n    }\r\n    export namespace IOneOf {\r\n      export interface IDiscriminator {\r\n        propertyName: string;\r\n        mapping?: Record<string, string>;\r\n      }\r\n    }\r\n\r\n    export interface __ISignificant<Type extends string> extends __IAttribute {\r\n      type: Type;\r\n      nullable?: boolean;\r\n    }\r\n    export interface __IAttribute {\r\n      title?: string;\r\n      description?: string;\r\n      deprecated?: boolean;\r\n    }\r\n  }\r\n}\nexport namespace SwaggerV2 {\r\n  export type IJsonSchema =\r\n    | IJsonSchema.IBoolean\r\n    | IJsonSchema.IInteger\r\n    | IJsonSchema.INumber\r\n    | IJsonSchema.IString\r\n    | IJsonSchema.IArray\r\n    | IJsonSchema.IObject\r\n    | IJsonSchema.IReference\r\n    | IJsonSchema.IUnknown\r\n    | IJsonSchema.INullOnly\r\n    | IJsonSchema.IAllOf\r\n    | IJsonSchema.IAnyOf\r\n    | IJsonSchema.IOneOf;\r\n  export namespace IJsonSchema {\r\n    export interface IBoolean extends __ISignificant<\"boolean\"> {\r\n      default?: boolean | null;\r\n      enum?: Array<boolean | null>;\r\n    }\r\n    export interface IInteger extends __ISignificant<\"integer\"> {\r\n      /** @type int64 */ default?: number | null;\r\n      /** @type int64 */ enum?: Array<number | null>;\r\n      /** @type int64 */ minimum?: number;\r\n      /** @type int64 */ maximum?: number;\r\n      exclusiveMinimum?: boolean;\r\n      exclusiveMaximum?: boolean;\r\n      /**\r\n       * @type uint64\r\n       * @exclusiveMinimum 0\r\n       */\r\n      multipleOf?: number;\r\n    }\r\n    export interface INumber extends __ISignificant<\"number\"> {\r\n      default?: number | null;\r\n      enum?: Array<number | null>;\r\n      minimum?: number;\r\n      maximum?: number;\r\n      exclusiveMinimum?: boolean;\r\n      exclusiveMaximum?: boolean;\r\n      /** @exclusiveMinimum 0 */ multipleOf?: number;\r\n    }\r\n    export interface IString extends __ISignificant<\"string\"> {\r\n      default?: string | null;\r\n      enum?: Array<string | null>;\r\n      format?:\r\n        | \"binary\"\r\n        | \"byte\"\r\n        | \"password\"\r\n        | \"regex\"\r\n        | \"uuid\"\r\n        | \"email\"\r\n        | \"hostname\"\r\n        | \"idn-email\"\r\n        | \"idn-hostname\"\r\n        | \"iri\"\r\n        | \"iri-reference\"\r\n        | \"ipv4\"\r\n        | \"ipv6\"\r\n        | \"uri\"\r\n        | \"uri-reference\"\r\n        | \"uri-template\"\r\n        | \"url\"\r\n        | \"date-time\"\r\n        | \"date\"\r\n        | \"time\"\r\n        | \"duration\"\r\n        | \"json-pointer\"\r\n        | \"relative-json-pointer\"\r\n        | (string & {});\r\n      pattern?: string;\r\n      /** @type uint64 */ minLength?: number;\r\n      /** @type uint64 */ maxLength?: number;\r\n    }\r\n\r\n    export interface IArray extends __ISignificant<\"array\"> {\r\n      items: IJsonSchema;\r\n      uniqueItems?: boolean;\r\n      /** @type uint64 */ minItems?: number;\r\n      /** @type uint64 */ maxItems?: number;\r\n    }\r\n    export interface IObject extends __ISignificant<\"object\"> {\r\n      properties?: Record<string, IJsonSchema>;\r\n      required?: string[];\r\n      additionalProperties?: boolean | IJsonSchema;\r\n      maxProperties?: number;\r\n      minProperties?: number;\r\n    }\r\n    export interface IReference<Key = string> extends __IAttribute {\r\n      $ref: Key;\r\n    }\r\n\r\n    export interface IUnknown extends __IAttribute {\r\n      type?: undefined;\r\n    }\r\n    export interface INullOnly extends __IAttribute {\r\n      type: \"null\";\r\n    }\r\n    export interface IAllOf extends __IAttribute {\r\n      allOf: IJsonSchema[];\r\n    }\r\n    export interface IAnyOf extends __IAttribute {\r\n      \"x-anyOf\": IJsonSchema[];\r\n    }\r\n    export interface IOneOf extends __IAttribute {\r\n      \"x-oneOf\": IJsonSchema[];\r\n    }\r\n\r\n    export interface __ISignificant<Type extends string> extends __IAttribute {\r\n      type: Type;\r\n      \"x-nullable\"?: boolean;\r\n    }\r\n    export interface __IAttribute {\r\n      title?: string;\r\n      description?: string;\r\n      deprecated?: boolean;\r\n    }\r\n  }\r\n}","definitions#Definitions":"","common-properties#Common Properties":"export namespace OpenApi {\r\n  export namespace IJsonSchema {\r\n    /**\r\n     * Common attributes that can be applied to all types.\r\n     */\r\n    export interface __IAttribute {\r\n      /**\r\n       * Representative title of the schema.\r\n       */\r\n      title?: string;\r\n\r\n      /**\r\n       * Detailed description of the schema.\r\n       * \r\n       * Very important for LLM (Large Language Model) function calling.\r\n       */\r\n      description?: string;\r\n\r\n      /**\r\n       * Whether the type is deprecated or not.\r\n       */\r\n      deprecated?: boolean;\r\n    }\r\n  }\r\n}\nEvery JSON schema definitions have the following common properties.The first title is the representative name of the schema, and the meaning \"representative\" is powerful even some OpenAPI (swagger) document viewers are replacing the parameter/property/variable name to the title assigned value.The other description is the detailed explanation of the schema. In the OpenAPI (swagger) document viewer level, the title is a little bit important than description, but in the LLM (Large Language Model) function calling level, it is something different. As the description property is used for describing the schema in detail to LLM agent, the description proeprty is very important with its original type info.The last deprecated is used to mark the schema as deprecated. If the schema is marked as deprecated, the schema is not recommended to use anymore. The schema is still valid so that no problem would be right now, but the @deprecated means that the API provider will remove it soon, so that would not work in the future.","atomic-types#Atomic Types":"","constant#Constant":"export namespace OpenApi {\r\n  export namespace IJsonSchema {\r\n    /**\r\n     * Constant value type.\r\n     */\r\n    export interface IConstant {\r\n      /**\r\n       * The constant value.\r\n       */\r\n      const: boolean | number | string;\r\n\r\n      /**\r\n       * Representative title of the schema.\r\n       */\r\n      title?: string;\r\n\r\n      /**\r\n       * Detailed description of the schema.\r\n       * \r\n       * Very important for LLM (Large Language Model) function calling.\r\n       */\r\n      description?: string;\r\n\r\n      /**\r\n       * Whether the type is deprecated or not.\r\n       */\r\n      deprecated?: boolean;\r\n    }\r\n  }\r\n}\nimport typia from \"typia\";\r\n\r\nconst enum State {\r\n  NONE = 0,\r\n  CONNECTING = 1,\r\n  CLOSING = 2,\r\n  REJECTING = 3,\r\n  CONNECTED = 4,\r\n  CLOSED = 5,\r\n}\r\n\r\ntypia.json.application<[\r\n  \"one\" | \"two\" | \"three\",\r\n  State\r\n]>();\r\n  //{\r\n  //  version: \"3.1\",\r\n  //  components: {\r\n  //    schemas: {\r\n  //      State: {\r\n  //        oneOf: [\r\n  //          {\r\n  //            const: 0,\r\n  //            description: \"Did nothing yet\",\r\n  //          },\r\n  //          {\r\n  //            const: 1,\r\n  //            description: \"Connecting to the server\",\r\n  //          },\r\n  //          {\r\n  //            const: 2,\r\n  //            description: \"Closing the connection\",\r\n  //          },\r\n  //          {\r\n  //            const: 3,\r\n  //            description: \"Connection is alive\",\r\n  //          },\r\n  //          {\r\n  //            const: 4,\r\n  //            description: \"Connection has been closed\",\r\n  //          },\r\n  //        ],\r\n  //      },\r\n  //    },\r\n  //  },\r\n  //  schemas: [\r\n  //    {\r\n  //      oneOf: [\r\n  //        { const: \"one\" },\r\n  //        { const: \"two\" },\r\n  //        { const: \"three\" },\r\n  //      ],\r\n  //    },\r\n  //    { $ref: \"#/components/schemas/State\" },\r\n  //  ],\r\n  //}\n Playground Link\nIn the JSON schema definition, the Constant type is used for representing a constant literal value.The constant literal value means that the value is always fixed and never changes. In the TypeScript, the constant literal value type is defined like below. As you can see, the constant literal values false, 1, and \"two\" are always fixed and never changed, so that assigned to the const property of the JSON schema.","boolean#Boolean":"export namespace OpenApi {\r\n  export namespace IJsonSchema {\r\n    /**\r\n     * Constant value type.\r\n     */\r\n    export interface IBoolean {\r\n      /**\r\n       * Discriminator value of the type.\r\n       */\r\n      type: \"boolean\";\r\n\r\n      /**\r\n       * The default value.\r\n       */\r\n      default?: boolean;\r\n\r\n      /**\r\n       * Representative title of the schema.\r\n       */\r\n      title?: string;\r\n\r\n      /**\r\n       * Detailed description of the schema.\r\n       * \r\n       * Very important for LLM (Large Language Model) function calling.\r\n       */\r\n      description?: string;\r\n\r\n      /**\r\n       * Whether the type is deprecated or not.\r\n       */\r\n      deprecated?: boolean;\r\n    }\r\n  }\r\n}\nimport typia, { tags } from \"typia\";\r\n\r\ntypia.json.application<[\r\n  boolean & tags.Default<false>\r\n]>();\r\n  // {\r\n  //   type: \"boolean\",\r\n  //   default: false,\r\n  // }\nIn the JSON schema definition, the boolean type is expressed as above.Different with the previous Constant type, the boolean type has a special property default, which is used for representing the default value for the schema. The default value is used when the schema value is not assigned by the user.","integer#Integer":"export namespace OpenApi {\r\n  export namespace IJsonSchema {\r\n    /**\r\n     * Integer type info.\r\n     */\r\n    export interface IInteger {\r\n      /**\r\n       * Discriminator value of the type.\r\n       */\r\n      type: \"integer\";\r\n\r\n      /**\r\n       * Minimum value restriction.\r\n       *\r\n       * @type int64\r\n       */\r\n      minimum?: number;\r\n\r\n      /**\r\n       * Maximum value restriction.\r\n       *\r\n       * @type int64\r\n       */\r\n      maximum?: number;\r\n\r\n      /**\r\n       * Exclusive minimum value restriction.\r\n       *\r\n       * For reference, even though your Swagger (or OpenAPI) document has\r\n       * defined the `exclusiveMinimum` value as `number`, {@link OpenApi}\r\n       * forcibly converts it to `boolean` type, and assign the numeric value to\r\n       * the {@link minimum} property.\r\n       * \r\n       * @default false\r\n       */\r\n      exclusiveMinimum?: boolean;\r\n\r\n      /**\r\n       * Exclusive maximum value restriction.\r\n       *\r\n       * For reference, even though your Swagger (or OpenAPI) document has\r\n       * defined the `exclusiveMaximum` value as `number`, {@link OpenApi}\r\n       * forcibly converts it to `boolean` type, and assign the numeric value to\r\n       * the {@link maximum} property.\r\n       * \r\n       * @default false\r\n       */\r\n      exclusiveMaximum?: boolean;\r\n\r\n      /**\r\n       * Multiple of value restriction.\r\n       *\r\n       * @type uint64\r\n       * @exclusiveMinimum 0\r\n       */\r\n      multipleOf?: number;\r\n\r\n      /**\r\n       * Default value.\r\n       *\r\n       * @type int64\r\n       */\r\n      default?: number;\r\n\r\n      /**\r\n       * Representative title of the schema.\r\n       */\r\n      title?: string;\r\n\r\n      /**\r\n       * Detailed description of the schema.\r\n       * \r\n       * Very important for LLM (Large Language Model) function calling.\r\n       */\r\n      description?: string;\r\n\r\n      /**\r\n       * Whether the type is deprecated or not.\r\n       */\r\n      deprecated?: boolean;\r\n    }\r\n  }\r\n}\nimport typia, { tags } from \"typia\";\r\n\r\nconsole.log(\r\n  typia.json.application<[\r\n    number & tags.Type<\"uint32\"> & tags.Minimum<100>,\r\n  ]>(),\r\n  typia.createIs<number & tags.Type<\"uint32\"> & tags.Minimum<100>>(),\r\n);\r\n// {\r\n//   type: \"integer\",\r\n//   minimum: 100,\r\n// }\r\n//-----------------------\r\n// (input) => {\r\n//   return (\r\n//     \"number\" === typeof input &&\r\n//     Math.floor(input) === input &&\r\n//     -2147483648 <= input &&\r\n//     100 <= input\r\n//   );\r\n// }\n Playground Link\nIn the JSON schema definition, the integer type is expressed as above.Unlike above boolean type is, the integer type has additional restriction properties.At first, multipleOf means the value must be multiple of the assigned value. Therefore, if you assign an integer value to the multipleOf restricted type, your integer value must be possible to divid by the multipleOf value without any remainder.The other, minimum and maximum are the range restriction properties, and exclusiveMinimum and exclusiveMaximum are helper properties describing whether the minimum and maximum restrictions are prohibiting equal value or not. As default value of exclusiveMinimum and exclusiveMaximum are false, if only minimum or maximum is assigned, the value is allowed to be equal to the minimum or maximum value.\nx >= 0 // { minimum: 0, exclusiveMinimum: false }\r\ny < 10 // { maximum: 10, exclusiveMaximum: true }","number#Number":"export namespace OpenApi {\r\n  export namespace IJsonSchema {\r\n    /**\r\n     * Number (double) type info.\r\n     */\r\n    export interface INumber {\r\n      /**\r\n       * Discriminator value of the type.\r\n       */\r\n      type: \"number\";\r\n\r\n      /**\r\n       * Minimum value restriction.\r\n       */\r\n      minimum?: number;\r\n\r\n      /**\r\n       * Maximum value restriction.\r\n       */\r\n      maximum?: number;\r\n\r\n      /**\r\n       * Exclusive minimum value restriction.\r\n       *\r\n       * For reference, even though your Swagger (or OpenAPI) document has\r\n       * defined the `exclusiveMinimum` value as `number`, {@link OpenAiComposer}\r\n       * forcibly converts it to `boolean` type, and assign the numeric value to\r\n       * the {@link minimum} property.\r\n       */\r\n      exclusiveMinimum?: boolean;\r\n\r\n      /**\r\n       * Exclusive maximum value restriction.\r\n       *\r\n       * For reference, even though your Swagger (or OpenAPI) document has\r\n       * defined the `exclusiveMaximum` value as `number`, {@link OpenAiComposer}\r\n       * forcibly converts it to `boolean` type, and assign the numeric value to\r\n       * the {@link maximum} property.\r\n       */\r\n      exclusiveMaximum?: boolean;\r\n\r\n      /**\r\n       * Multiple of value restriction.\r\n       *\r\n       * @exclusiveMinimum 0\r\n       */\r\n      multipleOf?: number;\r\n\r\n      /**\r\n       * Default value.\r\n       */\r\n      default?: number;\r\n\r\n      /**\r\n       * Representative title of the schema.\r\n       */\r\n      title?: string;\r\n\r\n      /**\r\n       * Detailed description of the schema.\r\n       * \r\n       * Very important for LLM (Large Language Model) function calling.\r\n       */\r\n      description?: string;\r\n\r\n      /**\r\n       * Whether the type is deprecated or not.\r\n       */\r\n      deprecated?: boolean;\r\n    }\r\n  }\r\n}\nimport typia, { tags } from \"typia\";\r\n\r\nconsole.log(\r\n  typia.json.application<[\r\n    number & tags.MultipleOf<5.5>,\r\n  ]>(),\r\n  typia.createIs<number & tags.MultipleOf<5.5>>(),\r\n);\r\n  // {\r\n  //   type: \"number\",\r\n  //   multipleOf: 5.5,\r\n  // }\r\n  //-----------------------\r\n  // (input) => {\r\n  //   return \"number\" === typeof input && input % 5.5 === 0;\r\n  // }\n Playground Link\nIn the JSON schema definition, the number type is expressed as above.Only one thing different with number and integer type is, whether to allow the decimal point or not. The number type allows the decimal point, but the integer type does not allow the decimal point. Therefore, member properties of number type are exactly same with integer type.\nDescription in the integer type is also applied to the number type.\nAt first, multipleOf means the value must be multiple of the assigned value. Therefore, if you assign an integer value to the multipleOf restricted type, your integer value must be possible to divid by the multipleOf value without any remainder.The other, minimum and maximum are the range restriction properties, and exclusiveMinimum and exclusiveMaximum are helper properties describing whether the minimum and maximum restrictions are prohibiting equal value or not. As default value of exclusiveMinimum and exclusiveMaximum are false, if only minimum or maximum is assigned, the value is allowed to be equal to the minimum or maximum value.\nx >= 0 // { minimum: 0, exclusiveMinimum: false }\r\ny < 10 // { maximum: 10, exclusiveMaximum: true }","string#String":"export namespace OpenApi {\r\n  export namespace IJsonSchema {\r\n    /**\r\n     * String type info.\r\n     */\r\n    export interface IString {\r\n      /**\r\n       * Discriminator value of the type.\r\n       */\r\n      type: \"string\";\r\n\r\n      /**\r\n       * Format restriction.\r\n       */\r\n      format?:\r\n        | \"binary\"\r\n        | \"byte\"\r\n        | \"password\"\r\n        | \"regex\"\r\n        | \"uuid\"\r\n        | \"email\"\r\n        | \"hostname\"\r\n        | \"idn-email\"\r\n        | \"idn-hostname\"\r\n        | \"iri\"\r\n        | \"iri-reference\"\r\n        | \"ipv4\"\r\n        | \"ipv6\"\r\n        | \"uri\"\r\n        | \"uri-reference\"\r\n        | \"uri-template\"\r\n        | \"url\"\r\n        | \"date-time\"\r\n        | \"date\"\r\n        | \"time\"\r\n        | \"duration\"\r\n        | \"json-pointer\"\r\n        | \"relative-json-pointer\"\r\n        | (string & {});\r\n\r\n      /**\r\n       * Pattern restriction.\r\n       */\r\n      pattern?: string;\r\n\r\n      /**\r\n       * Content media type restriction.\r\n       */\r\n      contentMediaType?: string;\r\n\r\n      /**\r\n       * Minimum length restriction.\r\n       *\r\n       * @type uint64\r\n       */\r\n      minLength?: number;\r\n\r\n      /**\r\n       * Maximum length restriction.\r\n       *\r\n       * @type uint64\r\n       */\r\n      maxLength?: number;\r\n\r\n      /**\r\n       * Default value.\r\n       */\r\n      default?: string;\r\n\r\n      /**\r\n       * Representative title of the schema.\r\n       */\r\n      title?: string;\r\n\r\n      /**\r\n       * Detailed description of the schema.\r\n       * \r\n       * Very important for LLM (Large Language Model) function calling.\r\n       */\r\n      description?: string;\r\n\r\n      /**\r\n       * Whether the type is deprecated or not.\r\n       */\r\n      deprecated?: boolean;\r\n    }\r\n  }\r\n}\nimport typia, { tags } from \"typia\";\r\n\r\nconsole.log(\r\n  typia.json.application<[\r\n    string & tags.Format<\"uuid\"> & tags.MinLength<5> & tags.MaxLength<255>,\r\n  ]>(),\r\n  typia.createIs<\r\n    string & tags.Format<\"uuid\"> & tags.MinLength<5> & tags.MaxLength<255>\r\n  >(),\r\n);\r\n  // {\r\n  //   type: \"string\",\r\n  //   format: \"uuid\",\r\n  //   minLength: 5,\r\n  //   maxLength: 255,\r\n  // }\r\n  //-----------------------\r\n  // (input) => {\r\n  //   return (\r\n  //     \"string\" === typeof input &&\r\n  //     /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n  //       input,\r\n  //     ) &&\r\n  //     5 <= input.length &&\r\n  //     input.length <= 255\r\n  //   );\r\n  // }\n Playground Link\nIn the JSON schema definition, the string type is expressed as above.As integer and number type have minimum and miximum properties, the string type has minLength and maxLength properties to restrict the length of the string. Also, the string type has special properties that other types do not have, such as format, pattern, and contentMediaType.The pattern is used for restricting the string value by the regular exression. If the string value does not match the regular expression, the value is not valid.The format is used for restricting the string value by the format. The format property is not a regular expression, but a predefined format string. If you want to see the predefined format strings, please refer to below links.\nJSON schema string format\nRegular expressions for format\nThe last contentMediaType is designed for restricting the media type of the string content. It can be used only when the format property is one of them. For reference, the contentMediaType does not affect to the string value validation, but just used for the documentation reason.\nbinary\nbyte\nuri\nurl","nested-types#Nested Types":"","array#Array":"export namespace OpenApi {\r\n  export namespace IJsonSchema {\r\n    /**\r\n     * Array type info.\r\n     */\r\n    export interface IArray {\r\n      /**\r\n       * Discriminator value of the type.\r\n       */\r\n      type: \"array\";\r\n\r\n      /**\r\n       * Items type info.\r\n       *\r\n       * The `items` means the type of the array elements. In other words, it is\r\n       * the type schema info of the `T` in the TypeScript array type `Array<T>`.\r\n       */\r\n      items: IJsonSchema;\r\n\r\n      /**\r\n       * Unique items restriction.\r\n       *\r\n       * If this property value is `true`, target array must have unique items.\r\n       */\r\n      uniqueItems?: boolean;\r\n\r\n      /**\r\n       * Minimum items restriction.\r\n       *\r\n       * Restriction of minumum number of items in the array.\r\n       *\r\n       * @type uint64\r\n       */\r\n      minItems?: number;\r\n\r\n      /**\r\n       * Maximum items restriction.\r\n       *\r\n       * Restriction of maximum number of items in the array.\r\n       *\r\n       * @type uint64\r\n       */\r\n      maxItems?: number;\r\n\r\n      /**\r\n       * Representative title of the schema.\r\n       */\r\n      title?: string;\r\n\r\n      /**\r\n       * Detailed description of the schema.\r\n       * \r\n       * Very important for LLM (Large Language Model) function calling.\r\n       */\r\n      description?: string;\r\n\r\n      /**\r\n       * Whether the type is deprecated or not.\r\n       */\r\n      deprecated?: boolean;\r\n    }\r\n  }\r\n}\nimport typia, { tags } from \"typia\";\r\n\r\nconsole.log(\r\n  typia.json.application<[\r\n    Array<string & tags.Format<\"uuid\">> \r\n      & tags.MinItems<1> \r\n      & tags.UniqueItems\r\n  ]>(),\r\n  typia.createIs<\r\n    Array<string & tags.Format<\"uuid\">> \r\n      & tags.MinItems<1>\r\n      & tags.UniqueItems\r\n  >(),\r\n);\r\n  // {\r\n  //   type: \"array\",\r\n  //   items: {\r\n  //     type: \"string\",\r\n  //     format: \"uuid\",\r\n  //   },\r\n  //   minItems: 1,\r\n  //   uniqueItems: true,\r\n  // }\r\n  //-----------------------\r\n  // (() => {\r\n  //   return (input) =>\r\n  //     Array.isArray(input) &&\r\n  //     1 <= input.length &&\r\n  //     (input.length <= 1 || input.length === new Set(input).size) &&\r\n  //     input.every(\r\n  //       (elem) =>\r\n  //         \"string\" === typeof elem &&\r\n  //         /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i.test(\r\n  //           elem,\r\n  //         ),\r\n  //     );\r\n  // })()\nIn the JSON schema definition, the array type is expressed as above.At first, items property is used for describing the type of the array elements. In the TypeScript, it is the type schema info of the T element type in the TypeScript array type Array<T>.The uniqueItems property is used for describing whether the array elements are unique or not. If the uniqueItems property is true, the array elements must be unique. Otherwise false or undefined, the array elements are not restricted to be unique.Also, minItems and maxItems properties are used for restricting the number of the array elements. The minItems property is used for describing the minimum number of the array elements, and the maxItems property is used for describing the maximum number of the array elements.","tuple#Tuple":"export namespace OpenApi {\r\n  export namespace IJsonSchema {\r\n    /**\r\n     * Tuple type info.\r\n     */\r\n    export interface ITuple {\r\n      /**\r\n       * Discriminator value of the type.\r\n       */\r\n      type: \"array\";\r\n\r\n      /**\r\n       * Prefix items.\r\n       *\r\n       * The `prefixItems` means the type schema info of the prefix items in the\r\n       * tuple type. In the TypeScript, it is expressed as `[T1, T2]`.\r\n       *\r\n       * If you want to express `[T1, T2, ...TO[]]` type, you can configure the\r\n       * `...TO[]` through the {@link additionalItems} property.\r\n       */\r\n      prefixItems: IJsonSchema[];\r\n\r\n      /**\r\n       * Additional items.\r\n       *\r\n       * The `additionalItems` means the type schema info of the additional items\r\n       * after the {@link prefixItems}. In the TypeScript, if there's a type\r\n       * `[T1, T2, ...TO[]]`, the `...TO[]` is represented by the `additionalItems`.\r\n       *\r\n       * By the way, if you configure the `additionalItems` as `true`, it means\r\n       * the additional items are not restricted. They can be any type, so that\r\n       * it is equivalent to the TypeScript type `[T1, T2, ...any[]]`.\r\n       *\r\n       * Otherwise configure the `additionalItems` as the {@link IJsonSchema},\r\n       * it means the additional items must follow the type schema info.\r\n       * Therefore, it is equivalent to the TypeScript type `[T1, T2, ...TO[]]`.\r\n       */\r\n      additionalItems?: boolean | IJsonSchema;\r\n\r\n      /**\r\n       * Unique items restriction.\r\n       *\r\n       * If this property value is `true`, target tuple must have unique items.\r\n       */\r\n      uniqueItems?: boolean;\r\n\r\n      /**\r\n       * Minimum items restriction.\r\n       *\r\n       * Restriction of minumum number of items in the tuple.\r\n       *\r\n       * @type uint64\r\n       */\r\n      minItems?: number;\r\n\r\n      /**\r\n       * Maximum items restriction.\r\n       *\r\n       * Restriction of maximum number of items in the tuple.\r\n       *\r\n       * @type uint64\r\n       */\r\n      maxItems?: number;\r\n\r\n      /**\r\n       * Representative title of the schema.\r\n       */\r\n      title?: string;\r\n\r\n      /**\r\n       * Detailed description of the schema.\r\n       * \r\n       * Very important for LLM (Large Language Model) function calling.\r\n       */\r\n      description?: string;\r\n\r\n      /**\r\n       * Whether the type is deprecated or not.\r\n       */\r\n      deprecated?: boolean;\r\n    }\r\n  }\r\n}\nimport typia from \"typia\";\r\n\r\nconsole.log(\r\n  typia.json.application<[\r\n    [3, 4, string],\r\n    [number, string, boolean],\r\n    [boolean, number, ...string[]]\r\n  ]>(),\r\n);\r\n  // [\r\n  //   {\r\n  //     type: \"array\",\r\n  //     prefixItems: [\r\n  //       { const: 3 },\r\n  //       { const: 4 },\r\n  //       { type: \"string\" },\r\n  //     ],\r\n  //     additionalItems: false,\r\n  //   },\r\n  //   {\r\n  //     type: \"array\",\r\n  //     prefixItems: [\r\n  //       { type: \"number\" },\r\n  //       { type: \"string\" },\r\n  //       { type: \"boolean\" },\r\n  //     ],\r\n  //     additionalItems: false,\r\n  //   },\r\n  //   {\r\n  //     type: \"array\",\r\n  //     prefixItems: [\r\n  //       { type: \"boolean\" },\r\n  //       { type: \"number\" },\r\n  //     ],\r\n  //     additionalItems: {\r\n  //       type: \"string\",\r\n  //     },\r\n  //   },\r\n  // ]\nIn the JSON schema definition, the tuple type is expressed as above.The tuple type is a special type of the array type. The array type is used for representing the array of the same type elements, but the tuple type is used for representing the array of the different type elements.In the TypeScript, the tuple type is expressed as [T1, T2, ...TO[]], and such list of prefixed items are archived on the prefixItems property. If you make the prefixItems to be zero length array, it is equivalent to the empty array type.By the way, if you want to express [T1, T2, ...TO[]] type, which means that only T1, T2 types are prefixed and the rest of the types are any type, you can configure the ...TO[] type through the additionalItems property.","object#Object":"export namespace OpenApi {\r\n  export namespace IJsonSchema {\r\n    /**\r\n     * Object type info.\r\n     */\r\n    export interface IObject {\r\n      /**\r\n       * Discriminator value of the type.\r\n       */\r\n      type: \"object\";\r\n\r\n      /**\r\n       * Properties of the object.\r\n       *\r\n       * The `properties` means a list of key-value pairs of the object's\r\n       * regular properties. The key is the name of the regular property,\r\n       * and the value is the type schema info.\r\n       *\r\n       * If you need additional properties that is represented by dynamic key,\r\n       * you can use the {@link additionalProperties} instead.\r\n       */\r\n      properties?: Record<string, IJsonSchema>;\r\n\r\n      /**\r\n       * Additional properties' info.\r\n       *\r\n       * The `additionalProperties` means the type schema info of the additional\r\n       * properties that are not listed in the {@link properties}.\r\n       *\r\n       * If the value is `true`, it means that the additional properties are not\r\n       * restricted. They can be any type. Otherwise, if the value is\r\n       * {@link IOpenAiSchema} type, it means that the additional properties must\r\n       * follow the type schema info.\r\n       *\r\n       * - `true`: `Record<string, any>`\r\n       * - `IOpenAiSchema`: `Record<string, T>`\r\n       */\r\n      additionalProperties?: boolean | IJsonSchema;\r\n\r\n      /**\r\n       * List of key values of the required properties.\r\n       *\r\n       * The `required` means a list of the key values of the required\r\n       * {@link properties}. If some property key is not listed in the `required`\r\n       * list, it means that property is optional. Otherwise some property key\r\n       * exists in the `required` list, it means that the property must be filled.\r\n       *\r\n       * Below is an example of the {@link properties} and `required`.\r\n       *\r\n       * ```typescript\r\n       * interface SomeObject {\r\n       *   id: string;\r\n       *   email: string;\r\n       *   name?: string;\r\n       * }\r\n       * ```\r\n       *\r\n       * As you can see, `id` and `email` {@link properties} are {@link required},\r\n       * so that they are listed in the `required` list.\r\n       *\r\n       * ```json\r\n       * {\r\n       *   \"type\": \"object\",\r\n       *   \"properties\": {\r\n       *     \"id\": { \"type\": \"string\" },\r\n       *     \"email\": { \"type\": \"string\" },\r\n       *     \"name\": { \"type\": \"string\" }\r\n       *   },\r\n       *   \"required\": [\"id\", \"email\"]\r\n       * }\r\n       * ```\r\n       */\r\n      required?: string[];\r\n\r\n      /**\r\n       * Representative title of the schema.\r\n       */\r\n      title?: string;\r\n\r\n      /**\r\n       * Detailed description of the schema.\r\n       * \r\n       * Very important for LLM (Large Language Model) function calling.\r\n       */\r\n      description?: string;\r\n\r\n      /**\r\n       * Whether the type is deprecated or not.\r\n       */\r\n      deprecated?: boolean;\r\n    }\r\n  }\r\n}\nimport typia, { tags } from \"typia\";\r\n\r\nconsole.log(\r\n  typia.json.application<[\r\n    {\r\n      id: string & tags.Format<\"uuid\">;\r\n      name?: string;\r\n      age?: number & tags.Type<\"uint32\">;\r\n      configurations: {\r\n        [key: string]: boolean;\r\n      };\r\n    }\r\n  ]>(),\r\n);\r\n  // {\r\n  //   type: \"object\",\r\n  //   properties: {\r\n  //     id: {\r\n  //       type: \"string\",\r\n  //       format: \"uuid\",\r\n  //     },\r\n  //     name?: {\r\n  //       type: \"string\",\r\n  //     },\r\n  //     age: {\r\n  //       type: \"integer\",\r\n  //       minimum: 0,\r\n  //     },\r\n  //     configurations: {\r\n  //       type: \"object\",\r\n  //       properties: {},\r\n  //       additionalProperties: {\r\n  //         type: \"boolean\",\r\n  //       },\r\n  //     },\r\n  //   },\r\n  //   required: [\"id\", \"configurations\"],\r\n  // }\nIn the JSON schema definition, the object type is expressed as above.The object type has properties and required properties. The properties property is used for describing the regular properties of the object, and the required property is used for describing the required properties of the object.For example, above example code in the second tab contains a TypeScript object type. In the type, there are four regular properties; id, name, age and configurations. In the above example TypeScript object definition, only id and configurations properties are required, and the others are optional. Therefore, the required property is configured as [\"id\", \"configurations\"].Also, the configurations property is a special property that is represented by the dynamic key-value pairs. The additionalProperties property is used for describing the type schema info of the additional properties that are not listed in the properties property; Record<string, T>.For reference, if you configure the additionalProperties property just as true, it means that type of the additional properties are not restricted, so that it is equivalent to the any type case; Record<string, any>. Otherwise the additionalProperties property configured as false, it means the object type does not allow any superfluous properties. In the undefined value case, it means that does not consider and validatea the superfluous properties.","reference#Reference":"export namespace OpenApi {\r\n  export namespace IJsonSchema {\r\n    /**\r\n     * Reference type directing named schema.\r\n     */\r\n    export interface IReference<Key = string> {\r\n      /**\r\n       * Reference to the named schema.\r\n       *\r\n       * The `ref` is a reference to the named schema. Format of the `$ref` is\r\n       * following the JSON Pointer specification. In the OpenAPI, the `$ref`\r\n       * starts with `#/components/schemas/` which means the type is stored in\r\n       * the {@link OpenApi.IComponents.schemas} object.\r\n       *\r\n       * - `#/components/schemas/SomeObject`\r\n       * - `#/components/schemas/AnotherObject`\r\n       */\r\n      $ref: Key;\r\n\r\n      /**\r\n       * Representative title of the schema.\r\n       */\r\n      title?: string;\r\n\r\n      /**\r\n       * Detailed description of the schema.\r\n       * \r\n       * Very important for LLM (Large Language Model) function calling.\r\n       */\r\n      description?: string;\r\n\r\n      /**\r\n       * Whether the type is deprecated or not.\r\n       */\r\n      deprecated?: boolean;\r\n    }\r\n  }\r\n}\nimport typia from \"typia\";\r\n\r\ninterface IMember {\r\n  id: string;\r\n  name: string;\r\n  age?: number;\r\n}\r\nconsole.log(\r\n  typia.json.application<[\r\n    IMember,\r\n    {\r\n      x: number;\r\n      y: number;\r\n      z?: number;\r\n    }\r\n  ]>(),\r\n);\r\n  // {\r\n  //   components: {\r\n  //     schemas: {\r\n  //       IMember: {\r\n  //         type: \"object\",\r\n  //         properties: {\r\n  //           id: { type: \"string\" },\r\n  //           name: { type: \"string\" },\r\n  //           age: { type: \"number\" },\r\n  //         },\r\n  //         required: [\"id\", \"name\"],\r\n  //       },\r\n  //     },\r\n  //   },\r\n  //   schemas: [\r\n  //     {\r\n  //       $ref: \"#/components/schemas/IMember\",\r\n  //     },\r\n  //     {\r\n  //       type: \"object\",\r\n  //       properties: {\r\n  //         x: { type: \"number\" },\r\n  //         y: { type: \"number\" },\r\n  //         z: { type: \"number\" },\r\n  //       },\r\n  //       required: [\"x\", \"y\"],\r\n  //     },\r\n  //   ],\r\n  // }\nIn the JSON schema definition, the reference type is expressed as above.The reference type is used for referencing the named schema, defined in the components instance. If you have a named schema, you can reference it by the $ref property with #/components/schemas prefix. In the above case, $ref of the IMember type is #/components/schemas/IMember.Also in the above example code of second tab, you can see that two types are listed in the JSON schema generator. The first is the IMember  type that is defined as a explicit named interface type, and the second is the literal object type. As the IMember type is defined as a named schema, it is referenced by the $ref property.The other one is not named type case, so that listed in the schemas directly.","oneof#OneOf":"export namespace OpenApi {\r\n  export namespace IJsonSchema {\r\n    /**\r\n     * Union type.\r\n     *\r\n     * IOneOf` represents an union type of the TypeScript (`A | B | C`).\r\n     *\r\n     * For reference, even though your Swagger (or OpenAPI) document has\r\n     * defined `anyOf` instead of the `oneOf`, {@link OpenApi} forcibly\r\n     * converts it to `oneOf` type.\r\n     */\r\n    export interface IOneOf {\r\n      /**\r\n       * List of the union types.\r\n       */\r\n      oneOf: Exclude<IJsonSchema, IJsonSchema.IOneOf>[];\r\n\r\n      /**\r\n       * Discriminator info of the union type.\r\n       */\r\n      discriminator?: IOneOf.IDiscriminator;\r\n\r\n      /**\r\n       * Representative title of the schema.\r\n       */\r\n      title?: string;\r\n\r\n      /**\r\n       * Detailed description of the schema.\r\n       * \r\n       * Very important for LLM (Large Language Model) function calling.\r\n       */\r\n      description?: string;\r\n\r\n      /**\r\n       * Whether the type is deprecated or not.\r\n       */\r\n      deprecated?: boolean;\r\n    }\r\n    export namespace IOneOf {\r\n      /**\r\n       * Discriminator info of the union type.\r\n       */\r\n      export interface IDiscriminator {\r\n        /**\r\n         * Property name for the discriminator.\r\n         */\r\n        propertyName: string;\r\n\r\n        /**\r\n         * Mapping of the discriminator value to the schema name.\r\n         *\r\n         * This property is valid only for {@link IReference} typed\r\n         * {@link IOneOf.oneof} elements. Therefore, `key` of `mapping` is\r\n         * the discriminator value, and `value` of `mapping` is the\r\n         * schema name like `#/components/schemas/SomeObject`.\r\n         */\r\n        mapping?: Record<string, string>;\r\n      }\r\n    }\r\n  }\r\n}\nimport typia from \"typia\";\r\n\r\ninterface ICircle {\r\n  type: \"circle\";\r\n  radius: number;\r\n}\r\ninterface ITriangle {\r\n  type: \"triangle\";\r\n  base: number;\r\n  height: number;\r\n}\r\ninterface IRectangle {\r\n  type: \"rectangle\";\r\n  width: number;\r\n  height: number;\r\n}\r\n\r\nconsole.log(\r\n  typia.json.application<[\r\n    | ICircle \r\n    | ITriangle \r\n    | IRectangle\r\n  ]>(),\r\n);\r\n  // {\r\n  //   version: \"3.1\",\r\n  //   components: {\r\n  //     schemas: {\r\n  //       ICircle: {\r\n  //         type: \"object\",\r\n  //         properties: {\r\n  //           type: { const: \"circle\" },\r\n  //           radius: { type: \"number\" },\r\n  //         },\r\n  //         required: [\"type\", \"radius\"],\r\n  //       },\r\n  //       ITriangle: {\r\n  //         type: \"object\",\r\n  //         properties: {\r\n  //           type: { const: \"triangle\" },\r\n  //           base: { type: \"number\" },\r\n  //           height: { type: \"number\" },\r\n  //         },\r\n  //         required: [\"type\", \"base\", \"height\"],\r\n  //       },\r\n  //       IRectangle: {\r\n  //         type: \"object\",\r\n  //         properties: {\r\n  //           type: { const: \"rectangle\" },\r\n  //           width: { type: \"number\" },\r\n  //           height: { type: \"number\" },\r\n  //         },\r\n  //         required: [\"type\", \"width\", \"height\"],\r\n  //       },\r\n  //     },\r\n  //   },\r\n  //   schemas: [\r\n  //     {\r\n  //       oneOf: [\r\n  //         { $ref: \"#/components/schemas/ICircle\" },\r\n  //         { $ref: \"#/components/schemas/ITriangle\" },\r\n  //         { $ref: \"#/components/schemas/IRectangle\" },\r\n  //       ],\r\n  //       discriminator: {\r\n  //         propertyName: \"type\",\r\n  //         mapping: {\r\n  //           circle: \"#/components/schemas/ICircle\",\r\n  //           triangle: \"#/components/schemas/ITriangle\",\r\n  //           rectangle: \"#/components/schemas/IRectangle\",\r\n  //         },\r\n  //       },\r\n  //     },\r\n  //   ],\r\n  // }\nIn the JSON schema definition, the oneOf type is expressed as above.The oneOf type is used for representing the union type of the TypeScript (A | B | C).Individual types composing the union type are listed in the oneOf property. Also, the discriminator property is constructed only when discriminator property exists in the union type, and every individual types are named reference type like above case.\nICircle.type: \"circle\"\nITriangle.type: \"triangle\"\nIRectangle.type: \"rectangle\"","special-types#Special Types":"","null#Null":"export namespace OpenApi {\r\n  export namespace IJsonSchema {\r\n    /**\r\n     * Null type.\r\n     */\r\n    export interface INull {\r\n      /**\r\n       * Discriminator value of the type.\r\n       */\r\n      type: \"null\";\r\n\r\n      /**\r\n       * Default value.\r\n       */\r\n      default?: null;\r\n\r\n      /**\r\n       * Representative title of the schema.\r\n       */\r\n      title?: string;\r\n\r\n      /**\r\n       * Detailed description of the schema.\r\n       * \r\n       * Very important for LLM (Large Language Model) function calling.\r\n       */\r\n      description?: string;\r\n\r\n      /**\r\n       * Whether the type is deprecated or not.\r\n       */\r\n      deprecated?: boolean;\r\n    }\r\n  }\r\n}\nimport typia from \"typia\";\r\n\r\nconsole.log(\r\n  typia.json.application<[\r\n    null,\r\n    string | null,\r\n    number | null,\r\n  ]>(),\r\n);\r\n  // [\r\n  //   { type: \"null\" },\r\n  //   {\r\n  //     oneOf: [\r\n  //       { type: \"null\" },\r\n  //       { type: \"string\" },\r\n  //     ],\r\n  //   },\r\n  //   {\r\n  //     oneOf: [\r\n  //       { type: \"null\" },\r\n  //       { type: \"number\" },\r\n  //     ],\r\n  //   },\r\n  // ]\nIn the JSON schema definition, the null type is expressed as above.It is exactly same with null type in the TypeScript.If you want to declare a nullable type of the other type, you have to use the oneOf type with null type.","unknown#Unknown":"export namespace OpenApi {\r\n  export namespace IJsonSchema {\r\n    /**\r\n     * Unknown, `any` type.\r\n     */\r\n    export interface IUnknown extends __IAttribute {\r\n      /**\r\n       * Type is never be defined.\r\n       */\r\n      type?: undefined;\r\n\r\n      /**\r\n       * Representative title of the schema.\r\n       */\r\n      title?: string;\r\n\r\n      /**\r\n       * Detailed description of the schema.\r\n       * \r\n       * Very important for LLM (Large Language Model) function calling.\r\n       */\r\n      description?: string;\r\n\r\n      /**\r\n       * Whether the type is deprecated or not.\r\n       */\r\n      deprecated?: boolean;\r\n    }\r\n  }\r\n}\nimport typia from \"typia\";\r\n\r\nconsole.log(\r\n  typia.json.application<[\r\n    any,\r\n    unknown\r\n  ]>(),\r\n);\r\n  // [\r\n  //   {}, \r\n  //   {},\r\n  // ]\nIn the JSON schema definition, unknown type is expressed as above.In the TypeScript definition, it is equivalent any and unknown types.","components#Components":"export namespace OpenApi {\r\n  /**\r\n   * Reusable components in OpenAPI.\r\n   *\r\n   * A storage of reusable components in OpenAPI document.\r\n   *\r\n   * In other words, it is a storage of named DTO schemas and security schemes.\r\n   */\r\n  export interface IComponents<Schema extends IJsonSchema = IJsonSchema> {\r\n    /**\r\n     * An object to hold reusable DTO schemas.\r\n     *\r\n     * In other words, a collection of named JSON schemas.\r\n     */\r\n    schemas?: Record<string, Schema>;\r\n  }\r\n}\nimport typia from \"typia\";\r\n\r\ninterface ICircle {\r\n  type: \"circle\";\r\n  radius: number;\r\n}\r\ninterface ITriangle {\r\n  type: \"triangle\";\r\n  base: number;\r\n  height: number;\r\n}\r\ninterface IRectangle {\r\n  type: \"rectangle\";\r\n  width: number;\r\n  height: number;\r\n}\r\n\r\nconsole.log(\r\n  typia.json.application<[\r\n    | ICircle \r\n    | ITriangle \r\n    | IRectangle\r\n  ]>(),\r\n);\r\n  // {\r\n  //   version: \"3.1\",\r\n  //   components: {\r\n  //     schemas: {\r\n  //       ICircle: {\r\n  //         type: \"object\",\r\n  //         properties: {\r\n  //           type: { const: \"circle\" },\r\n  //           radius: { type: \"number\" },\r\n  //         },\r\n  //         required: [\"type\", \"radius\"],\r\n  //       },\r\n  //       ITriangle: {\r\n  //         type: \"object\",\r\n  //         properties: {\r\n  //           type: { const: \"triangle\" },\r\n  //           base: { type: \"number\" },\r\n  //           height: { type: \"number\" },\r\n  //         },\r\n  //         required: [\"type\", \"base\", \"height\"],\r\n  //       },\r\n  //       IRectangle: {\r\n  //         type: \"object\",\r\n  //         properties: {\r\n  //           type: { const: \"rectangle\" },\r\n  //           width: { type: \"number\" },\r\n  //           height: { type: \"number\" },\r\n  //         },\r\n  //         required: [\"type\", \"width\", \"height\"],\r\n  //       },\r\n  //     },\r\n  //   },\r\n  //   schemas: [\r\n  //     {\r\n  //       oneOf: [\r\n  //         { $ref: \"#/components/schemas/ICircle\" },\r\n  //         { $ref: \"#/components/schemas/ITriangle\" },\r\n  //         { $ref: \"#/components/schemas/IRectangle\" },\r\n  //       ],\r\n  //       discriminator: {\r\n  //         propertyName: \"type\",\r\n  //         mapping: {\r\n  //           circle: \"#/components/schemas/ICircle\",\r\n  //           triangle: \"#/components/schemas/ITriangle\",\r\n  //           rectangle: \"#/components/schemas/IRectangle\",\r\n  //         },\r\n  //       },\r\n  //     },\r\n  //   ],\r\n  // }\nCollection of named schemas.In the JSON schema definition, the components is a collection of named schemas. It is used for storing the reusable DTO schemas, and referenced by the reference type with $ref property and #/components/schemas/ prefixed addresses.Above second tab is the example code defining and utilizing the named schemas. As you can see, the named schemas are same with the TypeScript's named types. They're stored in the components.schemas object with the key-value pairs, and referenced by the $ref property with #/components/schemas/ prefixed addresses.","detailed-emendations#Detailed Emendations":"","decompositions#Decompositions":"","mixed#Mixed":"// OpenAPI v3.1\r\nconst original: OpenApiV3_1.IJsonSchema.IMixed = {\r\n  type: [\"number\", \"string\", \"object\"],\r\n  properties: {\r\n    id: { type: \"string\" },\r\n    validated: { type: \"boolean\" }, \r\n    required: [\"id\", \"validated\"],\r\n  },\r\n  minimum: 0,\r\n  exclusiveMinimum: true,\r\n  nullalble: true,\r\n};\r\n\r\n// Emended\r\nconst emended: OpenApi.IJsonSchema.IOneOf = {\r\n  oneOf: [\r\n    { type: \"null\" },\r\n    { \r\n      type: \"number\",\r\n      minimum: 0,\r\n      exclusiveMinimum: true,\r\n    },\r\n    { type: \"string\" },\r\n    {\r\n      type: \"object\",\r\n      properties: {\r\n        id: { type: \"string\" },\r\n        validated: { type: \"boolean\" }, \r\n        required: [\"id\", \"validated\"],\r\n      },\r\n    },\r\n  ],\r\n};\nexport namespace OpenApiV3_1 {\r\n  export type IJsonSchema =\r\n    | IJsonSchema.IMixed\r\n    | IJsonSchema.IConstant\r\n    | IJsonSchema.IBoolean\r\n    | IJsonSchema.IInteger\r\n    | IJsonSchema.INumber\r\n    | IJsonSchema.IString\r\n    | IJsonSchema.IArray\r\n    | IJsonSchema.IObject\r\n    | IJsonSchema.IReference\r\n    | IJsonSchema.IUnknown\r\n    | IJsonSchema.INull\r\n    | IJsonSchema.IAllOf\r\n    | IJsonSchema.IAnyOf\r\n    | IJsonSchema.IOneOf;\r\n  export namespace IJsonSchema {\r\n    export interface IMixed\r\n      extends IConstant,\r\n        Omit<IBoolean, \"type\" | \"default\" | \"enum\">,\r\n        Omit<INumber, \"type\" | \"default\" | \"enum\">,\r\n        Omit<IString, \"type\" | \"default\" | \"enum\">,\r\n        Omit<IArray, \"type\">,\r\n        Omit<IObject, \"type\">,\r\n        IReference,\r\n        IOneOf,\r\n        IAnyOf,\r\n        IAllOf {\r\n      type: Array<\r\n        \"boolean\" | \"integer\" | \"number\" | \"string\" | \"array\" | \"object\"\r\n      >;\r\n      default?: any[];\r\n      enum?: any[];\r\n    }\r\n  }\r\n}\nexport namespace OpenApi {\r\n  export type IJsonSchema =\r\n    | IJsonSchema.IConstant\r\n    | IJsonSchema.IBoolean\r\n    | IJsonSchema.IInteger\r\n    | IJsonSchema.INumber\r\n    | IJsonSchema.IString\r\n    | IJsonSchema.IArray\r\n    | IJsonSchema.ITuple\r\n    | IJsonSchema.IObject\r\n    | IJsonSchema.IReference\r\n    | IJsonSchema.IOneOf\r\n    | IJsonSchema.INull\r\n    | IJsonSchema.IUnknown;\r\n}\nIn the OpenAPI v3.1 specification, there is an mixed type in the JSON schema, which layed out every properties of individual JSON schema types. Such mixed type is unclear and dangerous to anyone who sees it, so \"Wrtn Studio Pro\" decomposes the mixed type to oneOf type for clarity.For reference, the reason why OpenAPI and JSON schema foundations have designed such all-rounder mixed type for OpenAPI document hand-writing users. It may be hard to believe that people would handwrite OpenAPI documentation, but this strategy actually exists. However, such strategy is actually exists and name of the strategy is \"CDD (Contract Driven Development)\".\nContract Driven Development\nHand write the OpenAPI document first (maybe as yaml extension)\nAPI interface designing, and developing server and client applications at the same time later.","enum#Enum":"// OpenAPI v3.1\r\nconst original: OpenApiV3_1.IJsonSchema.IString = {\r\n  type: \"string\",\r\n  enum: [\"cat\", \"dog\", \"lion\"],\r\n};\r\n\r\n// Emended\r\nconst emended: OpenApi.IJsonSchema.IOneOf = {\r\n  oneOf: [\r\n    { const: \"cat\" },\r\n    { const: \"dog\" },\r\n    { const: \"lion\" },\r\n  ],\r\n};","changements#Changements":"","allof#AllOf":"// OpenAPI v3.1\r\nconst original: OpenApiV3_1.IJsonSchema.IAllOf = {\r\n  allOf: [\r\n    {\r\n      type: \"object\",\r\n      properties: {\r\n        name: { type: \"string\" },\r\n        hobby: {\r\n          type: \"object\",\r\n          properties: {\r\n            name: { type: \"string\" },\r\n          },\r\n          required: [\"name\"],\r\n        },\r\n      },\r\n      required: [\"name\", \"hobby\"],\r\n    },\r\n    {\r\n      type: \"object\",\r\n      properties: {\r\n        age: { type: \"integer\" },\r\n        hobby: {\r\n          type: \"object\",\r\n          properties: {\r\n            category: { type: \"string\" },\r\n          },\r\n          required: [\"category\"],\r\n        },\r\n      },\r\n      required: [\"age\", \"hobby\"],\r\n    },\r\n  ],\r\n};\r\n\r\n// Emended\r\nconst emended: OpenApi.IJsonSchema.IObject = {\r\n  type: \"object\",\r\n  properties: {\r\n    name: { type: \"string\" },\r\n    hobby: {\r\n      type: \"object\",\r\n      properties: {\r\n        name: { type: \"string\" },\r\n        category: { type: \"string\" },\r\n      },\r\n      required: [\"name\", \"category\"],\r\n    },\r\n    age: { type: \"integer\" },\r\n  },\r\n  required: [\"name\", \"hobby\", \"age\"],\r\n};\nIn the OpenAPI v3.1 specification, there is a special reference type allOf. The allOf type is used for composing the schema by combining multiple schemas, and it is exactly similar to the TypeScript's intersection type like A & B.However, such intersection allOf type can be converted to a plain object or array type. Therefore, \"Wrtn Studio Pro\" forcibly casts the allOf type to the plain object or array type for clarity.","anyof#AnyOf":"// OpenAPI v3.1\r\nconst original: OpenApiV3_1.IJsonSchema.IAnyOf = {\r\n  anyOf: [\r\n    { type: \"number\" },\r\n    { type: \"string\" },\r\n  ],\r\n};\r\n\r\n// Emended\r\nconst emended: OpenApi.IJsonSchema.IOneOf = {\r\n  oneOf: [\r\n    { type: \"number\" },\r\n    { type: \"string\" },\r\n  ],\r\n};\nIn the OpenAPI v3.1 specification, there're two ways to composing union type. The first way is to defining oneOf, and the other way is to defining anyOf type. To pursue clartiy by removing synonym expression, \"Wrtn Studio Pro\" forcibly casts the anyOf type to oneOf type.For reference, \"Wrtn Studio Pro\" is compiling workflow program to TypeScript, and the TypeScript's union type is similar to the oneOf meaning. Such principle applies equally to other programming languages; oneOf, which must clearly refer to one type, is more appropriate than anyOf, which can be any type.This is the reason why \"Wrtn Studio Pro\" has adopted oneOf type instead of anyOf type.","recursivereference#RecursiveReference":"// OpenAPI v3.1\r\nconst original: OpenApiV3_1.IJsonSchema.IRecursiveReference = {\r\n  $recursiveRef: \"#/components/schemas/Category\",\r\n};\r\n\r\n// Emended\r\nconst emended: OpenApi.IJsonSchema.IReference {\r\n  $ref: \"#/components/schemas/Category\",\r\n};\nIn the OpenAPI v3.1 specification, there is a special reference type recursiveRef. The recursiveRef indicates the reference type is recursive, so that the reference type is referring to itself recursively when visiting the nested schema elements.However, the recursiveRef type is not a mandatory specification, and it is easy to check whether the reference type is recursive or not, so that \"Wrtn Studio Pro\" forcibly casts the recursiveRef type to the ref type for clarity.","separations#Separations":"","nullable#Nullable":"// OpenAPI v3.1\r\nconst original: OpenApiV3_1.IJsonSchema.IOneOf = {\r\n  oneOf: [\r\n    { \r\n      type: \"number\", \r\n      nullable: true,\r\n    },\r\n    {\r\n      type: \"string\",\r\n      nullable: true,\r\n    },\r\n  ],\r\n};\r\n\r\n// Emended\r\nconst emended: OpenApi.IJsonSchema.IOneOf = { \r\n  oneOf: [\r\n    { type: \"number\" },\r\n    { type: \"string\" },\r\n    { type: \"null\" },\r\n  ],\r\n};\nimport typia from \"typia\";\r\n\r\ntypia.json.application<[\r\n  number | string | null,\r\n]>();\r\n  // {\r\n  //   oneOf: [\r\n  //     {\r\n  //       type: \"null\",\r\n  //     },\r\n  //     {\r\n  //       type: \"string\",\r\n  //     },\r\n  //     {\r\n  //       type: \"number\",\r\n  //     },\r\n  //   ],\r\n  // }\n Playground Link\nIn the OpenAPI v3.1 specification, there're two ways to composing nullable type. The first is adding nullable property to a schema, and the second way is to declaring a null type and combinating it with the oneOf type.To pursue clarity by removing synonym expression, \"Wrtn Studio Pro\" adapts the second way; \"declaring null type and combinating it with the oneOf type.For reference, \"Wrtn Studio Pro\" has adopted the null type with oneOf type combination is, it is clear than nullable property case. As you can see from the above example code of the second tab, the nullable property can be duplicated when union type comes.","array-and-tuple#Array and Tuple":"export namespace OpenApiV3_1 {\r\n  export namespace IJsonSchema {\r\n    export interface IArray extends __ISignificant<\"array\"> {\r\n      items: IJsonSchema | IJsonSchema[];\r\n      prefixItems?: IJsonSchema[];\r\n      additionalItems?: boolean | IJsonSchema;\r\n      uniqueItems?: boolean;\r\n      /** @type uint64 */ minItems?: number;\r\n      /** @type uint64 */ maxItems?: number;\r\n    }\r\n  }\r\n}\r\n\r\nexport namespace OpenApi {\r\n  export namespace IJsonSchema {\r\n    export interface IArray extends __ISignificant<\"array\"> {\r\n      items: IJsonSchema;\r\n      uniqueItems?: boolean;\r\n      /** @type uint64 */ minItems?: number;\r\n      /** @type uint64 */ maxItems?: number;\r\n    }\r\n    export interface ITuple extends __ISignificant<\"array\"> {\r\n      prefixItems: IJsonSchema[];\r\n      additionalItems?: boolean | IJsonSchema;\r\n      uniqueItems?: boolean;\r\n      /** @type uint64 */ minItems?: number;\r\n      /** @type uint64 */ maxItems?: number;\r\n    }\r\n  }\r\n}\n//----\r\n// OpenAPI v3.1\r\n//----\r\nconst originalArray: OpenApiV3_1.IJsonSchema.IArray = {\r\n  type: \"array\",\r\n  items: {\r\n    type: \"boolean\",\r\n  }\r\n};\r\nconst originalTuple: OpenApiV3_1.IJsonSchema.IArray = {\r\n  type: \"array\",\r\n  items: [\r\n    { type: \"string\" },\r\n    { type: \"number\" },\r\n  ],\r\n}\r\n\r\n//----\r\n// Emended\r\n//---\r\nconst emendedArray: OpenApi.IJsonSchema.IArray = {\r\n  type: \"array\",\r\n  items: {\r\n    type: \"boolean\",\r\n  },\r\n};\r\nconst emendedTuple: OpenApi.IJsonSchema.ITuple = {\r\n  type: \"array\",\r\n  prefixItems: [\r\n    { type: \"string\" },\r\n    { type: \"number\" },\r\n  ],\r\n};\nimport typia from \"typia\";\r\n\r\ntypia.json.application<[\r\n  Array<boolean>,\r\n  [string, number],\r\n  [number, string, ...boolean[]],\r\n]>();\r\n// {\r\n//   version: \"3.1\",\r\n//   schemas: [\r\n//     {\r\n//       type: \"array\",\r\n//       items: { type: \"boolean\" },\r\n//     },\r\n//     {\r\n//       type: \"array\",\r\n//       prefixItems: [\r\n//         { type: \"string\" },\r\n//         { type: \"number\" },\r\n//       ],\r\n//     },\r\n//     {\r\n//       type: \"array\",\r\n//       prefixItems: [\r\n//         { type: \"number\" },\r\n//         { type: \"string\" },\r\n//       ],\r\n//       additionalItems: { type: \"boolean\" },\r\n//     },\r\n//   ],\r\n// }\n Playground Link\nAs you can see, original specification of OpenAPI v3.1 has define Array to be ambiguous.The items property can be either a single schema or an array of schemas. When the items property is a single schema, it means an Array<T> type in the TypeScript. On the other hand, when the items property is an array of schemas, it means a tuple type in TypeScript like [string, number] case.Also in the tuple type case, it is possible to utilize prefixItems property instead of the items proeprty. Furthermore, the additionalItems property can be used only when the tuple type case.To clarify the distinction between array and tuple types, \"Wrtn Studio Pro\" has separated OpenApiV3_1.IJsonSchema.IArray type to OpenApi.IJsonSchema.IArray and OpenApi.IJsonSchema.ITuple types, removing vulnerable properties to each side."}},"/tech-specs/swl/preface":{"title":"Preface","data":{}},"/tech-specs/openapi/preface":{"title":"Preface","data":{"everywhere#Everywhere":"\"Wrtn Studio Pro\" is utilizing OpenAPI specifications everywhere.\"Wrtn Studio Pro\" is a service providing a Meta LLM (A.I. Chatbot) which can perform various function callings from API marketplace sales, and an Workflow Compiler (with SWL language) that automates the Meta LLM scenario as an re-usable and executable program function with visual diagrams.By the way, \"Wrtn Studio Pro\" is utilizing OpenAPI specifications for standard schema/operation definitions, so that the OpenAPI specifications are used in every part of the \"Wrtn Studio Pro\"; LLM function calling, Workflow schema definitions, and API marketplace documentation.Therefore, if you want to learn the principles of \"Wrtn Studio Pro\", you have to understand the OpenAPI specifications. Let's start to see how the \"Wrtn Studio Pro\" defines and utilizes the OpenAPI specifications. Also, if you're planning to participant in \"Wrtn Studio Pro\" as an API provider, it would better to read the appendix article: Contract Driven Development.","specification#Specification":"\"Wrtn Studio Pro\" has adopted OpenAPI v3.1 specifications, but emended it for clarity and consistency.If user of API marketplace uploads a different version of OpenAPI specifications, \"Wrtn Studio Pro\" will convert it to the internal \"emended 3.1\" version of OpenAPI specifications. Below is the list of the OpenAPI specifications including the emended version of ours.\nOpenAPI v3.1 emended\nOpenAPI v3.1\nOpenAPI v3.0\nSwagger v2.0","plugins#Plugins":"\"Wrtn Studio Pro\" has defined additional OpenAPI plugin properties for special purposes.For example, x-wrtn-secret-key and x-wrtn-secret-scopes are plugin properties that indicating the user (or LLM) must assign the secret key value and the secret value must satisfy the scopes to the target string typed (OpenApi.IJsonSchema.IString) schema value.\nOperation Schema Plugin\nJSON Schema Plugins\n{\r\n  \"type\": \"string\",\r\n  \"x-wrtn-secret-key\": \"google\",\r\n  \"x-wrtn-secret-scopes\": [\"https://mail.google.com/\"]\r\n}","conversion#Conversion":"import { OpenApi, OpenApiV3, OpenApiV3_1, SwaggerV2 } from \"@samchon/openapi\";\r\nimport typia from \"typia\";\r\n\r\nconst main = async (): Promise<void> => {\r\n  // GET YOUR OPENAPI DOCUMENT\r\n  const response: Response = await fetch(\r\n    \"https://raw.githubusercontent.com/samchon/openapi/master/examples/v3.0/openai.json\"\r\n  );\r\n  const document: any = await response.json();\r\n\r\n  // TYPE ASSERTION\r\n  typia.assertGuard<\r\n    | OpenApiV3_1.IDocument\r\n    | OpenApiV3.IDocument\r\n    | SwaggerV2.IDocument\r\n  >(document);\r\n\r\n  // CONVERT TO EMENDED\r\n  const emended: OpenApi.IDocument = OpenApi.convert(document);\r\n  console.log(emended);\r\n};\r\nmain().catch(console.error);\n Playground Link\nManual conversion to \"emended OpenAPI v3.1 specification\".When you upload OpenAPI document to the \"Wrtn Studio Pro\", the uploaded OpenAPI document would be automatically converted to the \"emended OpenAPI v3.1 specification\". It does not matter whatever your OpenAPI document version is.By the way, if you want to pre-convert it to the \"emended OpenAPI v3.1 specification\" manually for testing, you can do it like above example code. Also, by following the above example TypeScript code, you can validate your OpenAPI document before the conversion, too."}},"/tech-specs/workflow/editor":{"title":"Editor","data":{}},"/tech-specs/workflow/backend":{"title":"Backend","data":{}},"/tech-specs/workflow/inspector":{"title":"Inspector","data":{}},"/tech-specs/workflow/preface":{"title":"Preface","data":{}},"/tech-specs/workflow/schema":{"title":"Schema","data":{"workflow#Workflow":"IStudioWorkflow\nIStudioWorkflowData\nIStudioWorkflowParameter\nIStudioWorkflowSwagger","statements#Statements":"IStudioWorkflowBlockStatement\nIStudioWorkflowBranchStatement\nIStudioWorkflowCallStatement\nIStudioWorkflowSetStatement\nIStudioWorkflowForEachStatement\nIStudioWorkflowWhileStatement\nIStudioWorkflowRepeatStatement\nIStudioWorkflowReturnStatement\nIStudioWorkflowSetReturnValueStatement\nIStudioWorkflowBreakStatement\nIStudioWorkflowContinueStatement","expressions#Expressions":"IAstArrayLiteralExpression\nIAstBinaryExpression\nIAstCallExpression\nIAstConditionalExpression\nIAstElementAccessExpression\nIAstNonNullExpression\nIAstObjectLiteralExpression\nIAstParenthesizedExpression\nIAstPrefixUnaryExpression\nIAstPostfixUnaryExpression\nIAstPropertyAccessExpression\nIAstSpreadElementExpression\nIAstTemplateExpression\nIAstIdentifier\nIAstTrueLiteral\nIAstFalseLiteral\nIAstNumericLiteral\nIAstNoSubstitutionTemplateLiteral\nIAstStringLiteral\nIAstNullLiteral\nIAstArrayFilterExpression\nIAstArrayFlatExpression\nIAstArrayFunctionParameterIdentifier\nIAstArrayFunctionIndexIdentifier\nIAstArrayMapExpression\nIAstObjectFlatExpression\nIAstObjectEntriesExpression\nIAstWorkflowParameterIdentifier\nIAstWorkflowVariableIdentifier\nIAstWorkflowCallStatementResultIdentifier\nIAstWorkflowEnvironmentVariableIdentifier\nIAstWorkflowLoopStatementElementIdentifier\nIAstWorkflowLoopStatementResultIdentifier\nIAstWorkflowSecretIdentifier\nIAstWorkflowMetadataIdentifier","repository-schema#Repository Schema":"","studio_repositories#studio_repositories":" .studio_repositories        ,\r\n      .  \r\n     .    ,  \r\n    ,\r\n  . ,   \r\n  ,    \r\n,  \r\n      .Properties\nid: Primary Key.\nstudio_account_id:   studio_accounts.id\nhub_customer_id:     hub_customers.id\ncode\n .   URL     .\ntitle:  \ndescription:    \ndisclosure\n  .\npublic:      .\nprotected:     .\nprivate:       .\ncreated_at:   .\nupdated_at:   .\ndeleted_at:   .","studio_repository_commits#studio_repository_commits":"  .  \r\n ,    \r\n .  studio_repository_commits  \r\n  \r\n     .      ,      ,\r\n    \r\n   .  ,       . \r\n     archived_at  null  \r\n    ,       \r\n .Properties\nid: Primary Key.\nstudio_repository_id:   studio_repositories.id\nparent_id:   id\nhub_customer_id:    hub_customers.id\ntitle:  .\ndescription:    .\ncreated_at:   .\nupdated_at:   .\ndeleted_at:   .\narchived_at\n   .    ,   .  ,     .","studio_repository_buckets#studio_repository_buckets":"   .studio_repository_buckets       ,\r\n   ,        .   ,      , \r\n   \r\n  .      \r\nstudio_repository_bucket_snapshots  , \r\n    ,       \r\n. ,    \r\n  ,   .   ,    ,\r\n   \r\n  .      ,   \r\n studio_repository_bucket_snapshots  .Properties\nid: Primary Key.\nstudio_repository_id:   studio_repositories.id\nhub_customer_id:    hub_customers.id\nstudio_repository_buckets_migration_id: Studio1.0   studio_repository_buckets_migration.id\ntype\n .   discriminator   .\ndirectory: \nfile:  ,  TS   \nworkflow:  \ncreated_at:   .\nupdated_at:   .\ndeleted_at:   .","studio_repository_bucket_snapshots#studio_repository_bucket_snapshots":"  .studio_repository_bucket_snapshots      \r\n,  \r\n     \r\n .,          \r\n  ,    \r\n.  ,        .\nstudio_repository_file_snapshots:  \nstudio_repository_workflow_snapshots:   \n    \nProperties\nid: Primary Key.\nstudio_repository_bucket_id:   studio_repository_buckets.id\nstudio_repository_commit_id:   studio_repository_commits.id\npath:   .\nlocation\n  .    ,       .\"foo/bar/baz.tz\"   ,   location  \"foo/bar\"  .\nname\n .LICENSE  ,     \"\"  .\nextension\n .LICENSE  ,     null  .      .\ncreated_at:   .\nupdated_at:   .","studio_repository_workflow_snapshots#studio_repository_workflow_snapshots":"   .studio_repository_workflow_snapshots     \r\n , studio  .   \r\n   ,       \r\n  .,           \r\n   ,  \r\n   .Properties\nid: Primary Key.\nstudio_meta_chat_session_connection_message_id\n Meta LLM    studio_meta_chat_session_connections.id   Meta LLM   , \r\n   \r\n ID \r\n .\nmeta_version\n .     .   \r\n ,  Studio    ., Studio  ,    \r\n      ,  \r\n      .\nnamespace:   .\nvalid\n .     . compile  execute       ,\r\n     null .,  ,    true    .\nis_chatbot:    .\nicon:    URL.\nthumbnail\n  .        .\ntitle:  .\nsummary:     .\ndescription:     .\ndata\n .DTO  IStudioWorkflowData.ICreate  .","studio_repository_releases#studio_repository_releases":"   .studio_repository_releases  \r\n    \r\n .  studio_repository_releases    \r\n   ,    \r\n studio_repository_release_nodes  . \r\n   ()  ,    \r\n.      .Properties\nid: Primary Key.\nstudio_repository_commit_id:    studio_repository_commits.id\nhub_customer_id:    hub_customers.id\nversion:  .\ncomponents\nJSON  .  .\nprogram_url\n URL .    script  s3 uri .\ndebug_url:   URL .\ncreated_at:   .\nopened_at:   .\ndeleted_at:   .","studio_repository_release_nodes#studio_repository_release_nodes":"     .studio_repository_release_nodes     ,\r\n   (export)     .       ,   .\r\n   \r\n    ,      \r\n   .,     Rest API  endpoint  . \r\n     import    ,\r\nRest API      .  \r\nGenerative Hub   ,   .Properties\nid: Primary Key.\nstudio_repository_release_id:    studio_repository_releases.id\nstudio_repository_bucket_snapshot_id:    studio_repository_buckets.id\naccessor\n  .     IAstExpression   .  ()  \"compute\" ,   \r\n  export  ,   IAstIdentifier  .\r\n re-export    namespace  export ,\r\n  IAstPropertyAccessExpression`    .\n{ type: \"Identifier\", text: \"compute\" }\r\n{\r\ntype: \"PropertyAccessExpression\",\r\nexpression: { type: \"Identifier\", text: \"Mathmatics\" },\r\nquestionDotToken: null,\r\nname: { type: \"Identifier\", text: \"compute\" },\r\n}\nsummary:  .\ndescription:  .\nmetadata\n .         .   DTO   .\nsequence:     .\npurpose:  "}},"/tech-specs/marketplace/examples":{"title":"Examples","data":{"connector-server#Connector Server":"","representative-product#Representative Product":"Representative product in the API marketplace.\nGithub Repository: https://github.com/wrtnio/connectors/\nSwagger UI: https://wrtnio.github.io/connectors/swagger/\nThe connector is an example project made by \"Wrtn Studio Pro\" team. It is a representative and default OpenAPI product in the marketplace. If a new customer has not purchased anything in the API marketplace, only the connector belonged API functions would be utilized in the \"Meta LLM (A.I. Chatbot)\".The connector has thousands of API functions interacting with significant services like Google, Github, Slack, and so on. The API functions are groupped by these service names as OpenAPI tags. You can see which API functions are provided in the connector server by visiting the Swagger UI. As you can see, every API functions and DTO types are fully documented with detailed descriptions. Such descriptions help the LLM function calling to select proper function to call and understand of it.Also, as this connector server has been disclosured in the Github repository as an open source project, you can learn how to make a well-structured OpenAPI based project. Even though the connector server has the \"AGPL 3.0\" license, so that you cannot use it for commercial purpose, the connector server's source codes and API/DTO definitions would be good reference to compose your OpenAPI product in the API marketplace.","pure-typescript-type#Pure TypeScript Type":"import { ApiProperty } from \"@nestjs/swagger\";\r\nimport {\r\n  ArrayNotEmpty,\r\n  Format,\r\n  IsArray,\r\n  IsObject,\r\n  IsOptional,\r\n  IsString,\r\n  Match,\r\n  MaxLength,\r\n  Type,\r\n  ValidateNested,\r\n} from \"class-validator\";\r\n\r\nexport class BbsArticle {\r\n  @ApiProperty({\r\n    format: \"uuid\",\r\n  })\r\n  @IsString()\r\n  id!: string;\r\n\r\n  // DUPLICATED SCHEMA DEFINITION\r\n  // - duplicated function call + property type\r\n  // - have to specify `isArray` and `nullable` props by yourself\r\n  @ApiProperty({\r\n    type: () => AttachmentFile,\r\n    nullable: true,\r\n    isArray: true,\r\n    description: \"List of attached files.\",\r\n  })\r\n  @Type(() => AttachmentFile)\r\n  @IsArray()\r\n  @IsOptional()\r\n  @IsObject({ each: true })\r\n  @ValidateNested({ each: true })\r\n  files!: AttachmentFile[] | null;\r\n\r\n  @ApiProperty({\r\n    type: \"string\",\r\n    nullable: true,\r\n    minLength: 5,\r\n    maxLength: 100,\r\n    description: \"Title of the article.\",\r\n  })\r\n  @IsOptional()\r\n  @IsString()\r\n  title!: string | null;\r\n\r\n  @ApiProperty({\r\n    description: \"Main content body of the article.\",\r\n  })\r\n  @IsString()\r\n  body!: string;\r\n\r\n  @ApiProperty({\r\n    format: \"date-time\",\r\n    description: \"Creation time of article\",\r\n  })\r\n  @IsString()\r\n  created_at!: string;\r\n}\r\n\r\nexport class AttachmentFile {\r\n  @ApiProperty({\r\n    type: \"string\",\r\n    maxLength: 255,\r\n    pattern: \"^[a-zA-Z0-9-_]+$\",\r\n    description: \"File name.\",\r\n  })\r\n  @Matches(/^[a-z0-9]+$/)\r\n  @MaxLength(255)\r\n  @IsString()\r\n  name!: string | null;\r\n\r\n  @ApiProperty({\r\n    type: \"string\",\r\n    nullable: true,\r\n    maxLength: 255,\r\n    pattern: \"^[a-zA-Z0-9-_]+$\",\r\n    description: \"File extension.\",\r\n  })\r\n  @Matches(/^[a-z0-9]+$/)\r\n  @MaxLength(8)\r\n  @IsOptional()\r\n  @IsString()\r\n  extension!: string | null;\r\n\r\n  @ApiProperty({\r\n    format: \"uri\",\r\n    description: \"URL of the file.\",\r\n  })\r\n  @Format(\"uri\")\r\n  @IsString()\r\n  url!: string;\r\n}\nimport { tags } from \"typia\";\r\n\r\nexport interface IBbsArticle {\r\n  /**\r\n   * Primary Key.\r\n   */\r\n  id: string & tags.Format<\"uuid\">;\r\n\r\n  /**\r\n   * List of attached files.\r\n   */\r\n  files: null | IAttachmentFile[];\r\n\r\n  /**\r\n   * Title of the article.\r\n   */\r\n  title: null | (string & tags.MinLength<5> & tags.MaxLength<100>);\r\n\r\n  /**\r\n   * Main content body of the article.\r\n   */\r\n  body: string;\r\n\r\n  /**\r\n   * Creation time of article.\r\n   */\r\n  created_at: string & tags.Format<\"date-time\">;\r\n}\r\n\r\nexport interface IAttachmentFile {\r\n  /**\r\n   * File name.\r\n   */\r\n  name: string & tags.Pattern<\"^[a-z0-9]+$\"> & tags.MaxLength<255>;\r\n\r\n  /**\r\n   * File extension.\r\n   */\r\n  extension: null | (string & tags.Pattern<\"^[a-z0-9]+$\"> & tags.MaxLength<8>);\r\n\r\n  /**\r\n   * URL of the file.\r\n   */\r\n  url: string & tags.Format<\"uri\">;\r\n}\nSafe and efficient OpenAPI generation by nestia.In the \"Wrtn Studio Pro\" application, every features start from the OpenAPI specification. API marketplace also trades the OpenAPI document specification. Therefore, exact and efficient OpenAPI generation is much important than anything other.By the way, the connector server is the representative OpenAPI product providing initial API functions for the newcomers. If there's an error on its OpenAPI document, it may lead to the unpexpected behavior from the LLM (Large Language Model) function calling, so that quality of the \"Wrtn Studio Pro\" would be downgraded just by such connector server's OpenAPI document level error. Otherwise there's no error on the OpenAPI document, but it is not efficient, the productivity of the \"Wrtn Studio Pro\" would be decreased.In such reason, \"Wrtn Studio Pro\" team had to find the best solution for OpenAPI document generation which can ensure both safety and efficiency. The solution is nestia developed by one of \"Wrtn Studio Pro\" developer, which does not require any extra dedication for the OpenAPI document generation. As you can see from the above code snippets, NestJS DTO definitions require triple duplicated schema definitions.One thing ridiculous is, NestJS has relatively few duplicate definitions or OpenAPI document elements that are handwritten by humans. Most other languages or frameworks cannot get beyond the level of handwriting OpenAPIs, which are not only redundant but also not type-safe. So even if a human makes a mistake while writing an OpenAPI spec, it often passes without any compilation error. And the most fatal aspect of this human mistake is that there can be a gap between the actual specifications of the API function and the specifications in the document. LLM function calling may be properly configured with parameters according to the given OpenAPI document specifications, but the actual document specifications may be incorrect, causing LLM function call execution to fail.In contrary, nestia does not need anything to do for OpenAPI document generation. nestia just analyzes the NestJS source code in the compilation level, and builds the OpenAPI document just by that automatically. In such reason, it does not need any duplicated definition, and API functions are always 100% synchronized with the OpenAPI document without any error. Efficiency from no duplicated definition, and safety from compiler level documentation. This is the reason why the connector server project has been adopted nestia for OpenAPI document generation.","test-driven-development#Test Driven Development":"import {\r\n  ArrayUtil,\r\n  GaffComparator,\r\n  RandomGenerator,\r\n  TestValidator,\r\n} from \"@nestia/e2e\";\r\n\r\nimport api from \"@ORGANIZATION/PROJECT-api/lib/index\";\r\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/bbs/IBbsArticle\";\r\nimport { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/common/IPage\";\r\n\r\nexport async function test_api_bbs_article_index_sort(\r\n  connection: api.IConnection,\r\n): Promise<void> {\r\n  // GENERATE 100 ARTICLES\r\n  const section: string = \"general\";\r\n  await ArrayUtil.asyncRepeat(100)(() =>\r\n    api.functional.bbs.articles.create(connection, section, {\r\n      writer: RandomGenerator.name(),\r\n      title: RandomGenerator.paragraph(5)(),\r\n      body: RandomGenerator.content(8)()(),\r\n      format: \"txt\",\r\n      files: [],\r\n      password: RandomGenerator.alphabets(8),\r\n    }),\r\n  );\r\n\r\n  // PREPARE VALIDATOR\r\n  const validator = TestValidator.sort(\"BbsArticleProvider.index()\")(async (\r\n    sort: IPage.Sort<IBbsArticle.IRequest.SortableColumns>,\r\n  ) => {\r\n    const page: IPage<IBbsArticle.ISummary> =\r\n      await api.functional.bbs.articles.index(connection, section, {\r\n        limit: 100,\r\n        sort,\r\n      });\r\n    return page.data;\r\n  });\r\n\r\n  // DO VALIDATE\r\n  const components = [\r\n    validator(\"created_at\")(GaffComparator.dates((x) => x.created_at)),\r\n    validator(\"updated_at\")(GaffComparator.dates((x) => x.updated_at)),\r\n    validator(\"title\")(GaffComparator.strings((x) => x.title)),\r\n    validator(\"writer\")(GaffComparator.strings((x) => x.writer)),\r\n    validator(\r\n      \"writer\",\r\n      \"title\",\r\n    )(GaffComparator.strings((x) => [x.writer, x.title])),\r\n  ];\r\n  for (const comp of components) {\r\n    await comp(\"+\", false);\r\n    await comp(\"-\", false);\r\n  }\r\n}\nTest Driven Development with strict e2e testing functions.As connector server is the representative product in the \"API Marketplace\", its runtime safety is much important than any other features. To ensure the connector server's runtime safety, \"Wrtn Studio Pro\" team has adopted the TDD (Test Driven Development) with strict e2e testing functions.At first, we never develop the main program first. Our rule is to define the interfaces of DTOs and API functions first. And then, we still do not write the main logic code. We write the e2e test program before the main logic code implementation. The main program development starts after the interface definitions and e2e test programs are completed.Here is the detailed process of our TDD rule for the connector server project.","1-definition#1. Definition":"Before developing the main program, define it before.At first, design the DB architecture on the Prisma Schema file.Writing the schema definitions, don't forget to write the detailed descriptions on each tables and properties. After that, build ERD (Enterprise Relationship Diagram) document through npm run build:prisma command. The ERD document will be generated on the docs/ERD.md path. If you share the ERD document with your companions, your team can enjoy increased productivity by standardizing words and entities.At second, write DTO structures under the src/api/structures directory and declare API endpoint specs under the src/controllers directory. Note that, do not implement the function body of the controller. Just write declaration only. Below code is never pseudo code, but actual code for current step.\n@Controlleer(\"bbs/articles\")\r\nexport class BbsArticleController {\r\n  @TypedRoute.Patch()\r\n  public async index(\r\n    @TypedBody() input: IBbsArticle.IRequest\r\n  ): Promise<IPage<IBbsArticle.ISummary>> {\r\n    input;\r\n    return null!;\r\n  }\r\n}","2-software-development-kit#2. Software Development Kit":"@wrtnio/connectors provides SDK (Software Development Kit) for convenience.SDK library means a collection of fetch functions with proper types, automatically generated by nestia. As you can see from the above gif image, SDK library boosts up client developments, by providing type hints and auto completions.Furthermore, the SDK library supports Mockup Simulator.If client developer configures simulate option to be true, the SDK library will not send HTTP request to your backend server, but simulate the API endpoints by itself. With that feature, frontend developers can directly start the interaction development, even when the main program development has not started.\n# BUILD SDK IN LOCAL\r\nnpm run build:sdk\r\n\r\n# BUILD SDK AND PUBLISH IT TO THE NPM\r\nnpm run package:api\nFor reference, if you run npm run benchmark command, your test functions defined in the test/features/api directory would be utilized for performance benchmarking. If you want to see the performance bench result earlier, visit below link please:\ndocs/benchmarks/AMD Ryzen 9 7940HS w Radeon 780M Graphics.md","3-test-automation-program#3. Test Automation Program":"TDD (Test Driven Development)\nAfter the Definition and client SDK generation, you've to design the use-case scenarios and implement a test automation program who represents those use-case scenarios and guarantees the Main Program.To add a new test function in the Test Automation Program, create a new TS file under the test/features directory following the below category and implement the test scenario function with representative function name and export symbol.Note that, the Test Automation Program resets the local DB schema whenever being run. Therefore, you've to be careful if import data has been stored in the local DB server. To avoid the resetting the local DB, configure the reset option like below.Also, the Test Automation Program runs all of the test functions placed into the test/features directory. However, those full testing may consume too much time. Therefore, if you want to reduce the testing time by specializing some test functions, use the include option like below.\nsupported options\ninclude: test only restricted functions who is containing the special keyword.\nexclude: exclude some functions who is containing the special keyword.\nreset: do not reset the DB\n# test without db reset\r\nnpm run test -- --reset false\r\n\r\n# include or exclude some features\r\nnpm run test -- --include something\r\nnpm run test -- --include cart order issue\r\nnpm run test -- --include cart order issue --exclude index deposit\r\n\r\n# run performance benchmark program\r\nnpm run benchmark\nFor reference, if you run npm run benchmark command, your test functions defined in the test/features/api directory would be utilized for performance benchmarking. If you want to see the performance bench result earlier, visit below link please:\ndocs/benchmarks/AMD Ryzen 9 7940HS w Radeon 780M Graphics.md","4-main-program#4. Main Program":"After Definition, client SDK building and Test Automation Program are all prepared, finally you can develop the Main Program. Also, when you complete the Main Program implementation, it would better to validate the implementation through the pre-built SDK and Test Automation Program.However, do not commit a mistake that writing source codes only in the src/controllers classes. The API Controller must have a role that only intermediation. The main source code should be write down separately following the directory categorizing. For example, source code about DB I/O should be written into the src/providers directory."}},"/tech-specs/meta/websocket":{"title":"Websocket","data":{"concept#Concept":"WebSocket protocol with RPC paradigm for A.I. chatbot.\"Wrtn Studio Pro\" has developed A.I. chatbot application with WebSocket protocol. Also, in the WebSocket protocol, \"Meta LLM\" has adopted the RPC (Remote Procedure Call) paradigm. By the RPC paradigm, client appliation of \"Meta LLM\" can call the server application's functions remotely. Of course, the server application can remotely call the client functions too.The WebSocket RPC (Remote Procedure Call) module is composed with four components: Communicator, Header, Provider and Driver. The Communicator is a class that taking responsibility of network communication and Provider is a collection of functions that providing to the remote system. At last, Driver is the RPC driver which can remotely call the functions of the remote system's Provider.In our \"Meta LLM\" system, there are two provides; IStudioMetaChatService and IStudioMetaChatListener. IStudioMetaChatService is a type of provider from server to client, and IStudioMetaChatListener is a type of provider from client to server. Also, IStudioMetaChatListener is providing many LLM function call related functions, so that Meta LLM server accomplishes the function call execution by calling the functions of IStudioMetaChatListener remotely.\nReferences\nRemote Procedure Call\nFeatures > RPC Components\nLearn from Examples > Remote Function Call\nProviders\nIStudioMetaChatService\nIStudioMetaChatListener","rpc-components#RPC Components":"Components of the Remote Procedure Call (RPC) paradigm.\nCommunicator: network communication with remote system\nHeader: header value directly delivered after the connection\nProvider: object provided for remote system\nDriver: proxy instance for remotely function calling to Provider","communicator#Communicator":"Communicates with a remote system.Communicator is a class taking full responsibility to network communication with remote system. You can register a Provider, an object would be provided to the remote system, to the Communicator. Also, Driver<Remote>, which can access to the remote system's Provider, is created by this Communicator.In the WebSocket protocol, WebSocketConnector and WebAcceptor are the classes responsible for the network communication. Also, this RPC paradigm is used not only in n the Meta LLM side with WebSocket protocol, but also in the Workflow Studio side with worker protocol.Here is the list of every communicator classes following the RPC paradigm.\nProtocol\tClient\tServer\tWeb Socket\tWebSocketConnector\tWebSocketAcceptor\tDedicated Worker\tWorkerConnector\tWorkerServer\tShared Worker\tSharedWorkerConnector\tSharedWorkerAcceptor","header#Header":"import { Driver, WebSocketConnector } from \"tgrid\";\r\n\r\nimport { ICalcConfig } from \"./interfaces/ICalcConfig\";\r\nimport { ICalcEvent } from \"./interfaces/ICalcEvent\";\r\nimport { ICalcEventListener } from \"./interfaces/ICalcEventListener\";\r\nimport { ICompositeCalculator } from \"./interfaces/ICompositeCalculator\";\r\n\r\nexport const webSocketClientMain = async () => {\r\n  const stack: ICalcEvent[] = [];\r\n  const listener: ICalcEventListener = {\r\n    on: (evt: ICalcEvent) => stack.push(evt),\r\n  };\r\n  const connector: WebSocketConnector<\r\n    ICalcConfig,\r\n    ICalcEventListener,\r\n    ICompositeCalculator\r\n  > = new WebSocketConnector(\r\n    { precision: 2 }, // header\r\n    listener, // provider for remote server\r\n  );\r\n  await connector.connect(\"ws://127.0.0.1:37000/composite\");\r\n\r\n  const remote: Driver<ICompositeCalculator> = connector.getDriver();\r\n  console.log(\r\n    await driver.plus(10, 20), // returns 30\r\n    await driver.multiplies(3, 4), // returns 12\r\n    await driver.divides(5, 3), // returns 1.67\r\n    await driver.scientific.sqrt(2), // returns 1.41\r\n    await driver.statistics.mean(1, 3, 9), // returns 4.33\r\n  );\r\n\r\n  await connector.close();\r\n  console.log(stack);\r\n};\nimport { Driver, WebSocketServer } from \"tgrid\";\r\n\r\nimport { ICalcConfig } from \"./interfaces/ICalcConfig\";\r\nimport { ICalcEventListener } from \"./interfaces/ICalcEventListener\";\r\nimport { CompositeCalculator } from \"./providers/CompositeCalculator\";\r\nimport { ScientificCalculator } from \"./providers/ScientificCalculator\";\r\nimport { SimpleCalculator } from \"./providers/SimpleCalculator\";\r\nimport { StatisticsCalculator } from \"./providers/StatisticsCalculator\";\r\n\r\nexport const webSocketServerMain = async () => {\r\n  const server: WebSocketServer<\r\n    ICalcConfig,\r\n    | CompositeCalculator\r\n    | SimpleCalculator\r\n    | StatisticsCalculator\r\n    | ScientificCalculator,\r\n    ICalcEventListener\r\n  > = new WebSocketServer();\r\n  await server.open(37_000, async (acceptor) => {\r\n    // LIST UP PROPERTIES\r\n    const config: ICalcConfig = acceptor.header;\r\n    const listener: Driver<ICalcEventListener> = acceptor.getDriver();\r\n\r\n    // ACCEPT OR REJECT\r\n    if (acceptor.path === \"/composite\")\r\n      await acceptor.accept(new CompositeCalculator(config, listener));\r\n    else if (acceptor.path === \"/simple\")\r\n      await acceptor.accept(new SimpleCalculator(config, listener));\r\n    else if (acceptor.path === \"/statistics\")\r\n      await acceptor.accept(new StatisticsCalculator(config, listener));\r\n    else if (acceptor.path === \"/scientific\")\r\n      await acceptor.accept(new ScientificCalculator(config, listener));\r\n    else {\r\n      await acceptor.reject(1002, `WebSocket API endpoint not found.`);\r\n      return;\r\n    }\r\n\r\n    // PING REPEATEDLY TO KEEP CONNECTION\r\n    acceptor.ping(15_000);\r\n  });\r\n  return server;\r\n};\nimport { Driver, WorkerServer } from \"tgrid\";\r\n\r\nimport { ICalcConfig } from \"./interfaces/ICalcConfig\";\r\nimport { ICalcEventListener } from \"./interfaces/ICalcEventListener\";\r\nimport { CompositeCalculator } from \"./providers/CompositeCalculator\";\r\n\r\nconst main = async () => {\r\n  const server: WorkerServer<\r\n    ICalcConfig,\r\n    CompositeCalculator,\r\n    ICalcEventListener\r\n  > = new WorkerServer();\r\n\r\n  const header: ICalcConfig = await server.getHeader();\r\n  const listener: Driver<ICalcEventListener> = server.getDriver();\r\n  const provider: CompositeCalculator = new CompositeCalculator(\r\n    header,\r\n    listener,\r\n  );\r\n  await server.open(provider);\r\n};\r\nmain().catch((exp) => {\r\n  console.error(exp);\r\n  process.exit(-1);\r\n});\nHeader value delivered after the connection.Header is a value, delivered from client to server directly, after the connection.Server can get the Header value through acceptor's header property.\nWebSocketAcceptor.header\nSharedWorkerAcceptor.header\nWorkerServer.getHeader()","provider#Provider":"import { Driver, WebSocketServer } from \"tgrid\";\r\n\r\nimport { ICalcConfig } from \"./interfaces/ICalcConfig\";\r\nimport { ICalcEventListener } from \"./interfaces/ICalcEventListener\";\r\nimport { CompositeCalculator } from \"./providers/CompositeCalculator\";\r\nimport { ScientificCalculator } from \"./providers/ScientificCalculator\";\r\nimport { SimpleCalculator } from \"./providers/SimpleCalculator\";\r\nimport { StatisticsCalculator } from \"./providers/StatisticsCalculator\";\r\n\r\nexport const webSocketServerMain = async () => {\r\n  const server: WebSocketServer<\r\n    ICalcConfig,\r\n    | CompositeCalculator\r\n    | SimpleCalculator\r\n    | StatisticsCalculator\r\n    | ScientificCalculator,\r\n    ICalcEventListener\r\n  > = new WebSocketServer();\r\n  await server.open(37_000, async (acceptor) => {\r\n    // LIST UP PROPERTIES\r\n    const config: ICalcConfig = acceptor.header;\r\n    const listener: Driver<ICalcEventListener> = acceptor.getDriver();\r\n\r\n    // ACCEPT OR REJECT\r\n    if (acceptor.path === \"/composite\")\r\n      await acceptor.accept(new CompositeCalculator(config, listener));\r\n    else if (acceptor.path === \"/simple\")\r\n      await acceptor.accept(new SimpleCalculator(config, listener));\r\n    else if (acceptor.path === \"/statistics\")\r\n      await acceptor.accept(new StatisticsCalculator(config, listener));\r\n    else if (acceptor.path === \"/scientific\")\r\n      await acceptor.accept(new ScientificCalculator(config, listener));\r\n    else {\r\n      await acceptor.reject(1002, `WebSocket API endpoint not found.`);\r\n      return;\r\n    }\r\n\r\n    // PING REPEATEDLY TO KEEP CONNECTION\r\n    acceptor.ping(15_000);\r\n  });\r\n  return server;\r\n};\nObject provided for remote system.Provider is an object provided for the remote system.The remote system can call the Provider's functions through Driver<Remote>.","driver#Driver":"import { Driver, WebSocketConnector } from \"tgrid\";\r\n\r\nimport { ICalcConfig } from \"./interfaces/ICalcConfig\";\r\nimport { ICalcEvent } from \"./interfaces/ICalcEvent\";\r\nimport { ICalcEventListener } from \"./interfaces/ICalcEventListener\";\r\nimport { ICompositeCalculator } from \"./interfaces/ICompositeCalculator\";\r\n\r\nexport const webSocketClientMain = async () => {\r\n  const stack: ICalcEvent[] = [];\r\n  const listener: ICalcEventListener = {\r\n    on: (evt: ICalcEvent) => stack.push(evt),\r\n  };\r\n  const connector: WebSocketConnector<\r\n    ICalcConfig,\r\n    ICalcEventListener,\r\n    ICompositeCalculator\r\n  > = new WebSocketConnector(\r\n    { precision: 2 }, // header\r\n    listener, // provider for remote server\r\n  );\r\n  await connector.connect(\"ws://127.0.0.1:37000/composite\");\r\n\r\n  const remote: Driver<ICompositeCalculator> = connector.getDriver();\r\n  console.log(\r\n    await driver.plus(10, 20), // returns 30\r\n    await driver.multiplies(3, 4), // returns 12\r\n    await driver.divides(5, 3), // returns 1.67\r\n    await driver.scientific.sqrt(2), // returns 1.41\r\n    await driver.statistics.mean(1, 3, 9), // returns 4.33\r\n  );\r\n\r\n  await connector.close();\r\n  console.log(stack);\r\n};\n$ npm start\r\n30 12 1.67 1.41 4.33\r\n[\r\n  { type: 'plus', input: [ 10, 20 ], output: 30 },\r\n  { type: 'multiplies', input: [ 3, 4 ], output: 12 },\r\n  { type: 'divides', input: [ 5, 3 ], output: 1.67 },\r\n  { type: 'sqrt', input: [ 2 ], output: 1.41 },\r\n  { type: 'mean', input: [ 1, 3, 9 ], output: 4.33 }\r\n]\nDriver of RPC (Remote Procedure Call).Driver is a proxy instance designed to call functions of the remote system. It has a generic argument Remote which means the type of remote system's Provider, and you can remotely call the functions of the Provider asynchronously through the Drive<Remote> instance.When you call some function of remote Provider by the Driver<Listener> instance, it hooks the function call expression, and delivers the function name and arguments (parameter values) to the remote system through the Communicator. If the remote system suceeded to reply the result of the function call, Communicator resolves the promise of the function call expression with the result, so that makes Driver<Remote> working.Otherwise exception is thrown in the remote Provider function, Communicator deliveries the exception instance instead to the remote system, so that actual exception being thrown from the Driver<Remote> instance.\n Playground Link","meta-llm-protocol#Meta LLM Protocol":"","istudiometachatservice#IStudioMetaChatService":"/**\r\n * Set of functions provided by the Meta LLM server to the client.\r\n * \r\n * `IStudioMetaChatService` is an interface that defines the set of functions\r\n * provided by the **server** to the Meta LLM (Large Language Model) client. The Meta \r\n * LLM client remotely calls the server's `IStudioMetaChatService` functions through \r\n * this interface with RPC (Remote Procedure Call) paradigm.\r\n * \r\n * Note that the client must call the {@link initialize} function immediately\r\n * after connecting to the Meta LLM server. If the client tries to skip the\r\n * {@link initialize} function call and directly call {@link talk}, the function\r\n * call will fail, so that exception would be thrown.\r\n */\r\nexport interface IStudioMetaChatService {\r\n  /**\r\n   * Publish/restore/initialize the chat session.\r\n   * \r\n   * The client must call this function once after connecting to the Meta LLM\r\n   * server to publish a new chat session or restore an existing session. If\r\n   * the client tries to skip the {@link initialize} function call and directly\r\n   * call {@link talk}, the function call will fail, so that exception would be\r\n   * thrown.\r\n   * \r\n   * Also, the returned session would be a new chat session if the client connected\r\n   * to the server via the new chat session API, and the existing session would be\r\n   * restored if the client connected to the server via the continue chat session\r\n   * API.\r\n   *\r\n   * - {@link HubApi.functional.studio.customers.meta.chat.sessions.start}\r\n   * - {@link HubApi.functional.studio.customers.meta.chat.sessions.restart}\r\n   */\r\n  initialize(): Promise<IStudioMetaChatSession>;\r\n\r\n  /**\r\n   * User talks to Meta LLM.\r\n   * \r\n   * A function called by the client to talk to the Meta LLM server.\r\n   * \r\n   * @param dialogue Dialogue information\r\n   */\r\n  talk(dialogue: IStudioMetaChatDialogue): Promise<void>;\r\n}\nProvider from server to client for chatting.\r\np\r\n\"Meta LLM\" server is providing an IStudioMetaChatService typed instane to the client.It provides only two functions: initialize() and talk(). At first, initialize() is a function that the client must call once after connecting to the Meta LLM server to publish a new chat session or restore an existing session. If the client tries to skip the initialize() function call and directly call talk(), the function call will fail, so that exception would be thrown.The other talk() is a function called by the client to talk to the Meta LLM server. When client talks to the Meta LLM server, LLM reads and analyzes the message, and do something proper behavior calling the remotely provided functions of IStudioMetaChatListener.","istudiometachatlistener#IStudioMetaChatListener":"/**\r\n * Set of functions provided by the Meta LLM client to the server.\r\n * \r\n * `IStudioMetaChatListener` is an interface that defines the set of functions\r\n * provided by the **client** to the Meta LLM (Large Language Model) server. The Meta \r\n * LLM server remotely calls the client's `IStudioMetaChatListener` functions through\r\n * this interface with RPC (Remote Procedure Call) paradigm.\r\n */\r\nexport interface IStudioMetaChatListener {\r\n  /**\r\n   * Meta LLM server talks to the user.\r\n   * \r\n   * A function called by the Meta LLM server to talk to the user.\r\n   *\r\n   * @param dialogue Dialogue information\r\n   */\r\n  talk(dialogue: IStudioMetaChatDialogue): Promise<void>;\r\n\r\n  /**\r\n   * Notify the client of the server's listenability.\r\n   * \r\n   * The Meta LLM server notifies the client whether it is possible to listen.\r\n   *  \r\n   * In other words, this function informs the client whether it can call\r\n   * {@link IStudioMetaChatService.talk} immediately or not.\r\n   * \r\n   * Note that when the client calls the server's RPC function\r\n   * {@link IStudioMetaChatService.talk}, the value `false` is passed to this\r\n   * function {@link IStudioMetaChatListener.listenable} immediately. On the\r\n   * other hand, the value `true` is passed to this function in various cases.\r\n   *\r\n   * @param status Listenability status\r\n   */\r\n  listenable(status: boolean): Promise<void>;\r\n\r\n  /**\r\n   * Explain the function call plan.\r\n   * \r\n   * The Meta LLM server explains the function call plan to the user.\r\n   * \r\n   * The function call plan provided includes a list of functions that LLM\r\n   * wants to execute in order, and a description of the entire plan and the\r\n   * purpose of each function call.\r\n   * \r\n   * The client can read this and decide whether to proceed with the LLM\r\n   * function call execution. If `true` is returned, the Meta LLM will call\r\n   * the functions according to the plan. Otherwise `false` be returned, the plan\r\n   * would be withdrawn.\r\n   * \r\n   * @param plan Function call plan\r\n   * @returns Whether to proceed with the plan or not\r\n   */\r\n  explainFunctionCall(plan: IStudioMetaChatFunctionCallPlan): Promise<boolean>;\r\n\r\n  /**\r\n   * Select a function to call.\r\n   * \r\n   * A function called by the Meta LLM server when LLM (Large Language Model) has\r\n   * determined the target function to call during the conversation with the user.\r\n   * \r\n   * After this function be called, the server will call the {@link fillArguments} \r\n   * functionns remotely to commpose parameter values, and then call the \r\n   * {@link completeFunction} function after the function call execution.\r\n   *\r\n   * @param props Information of the target function\r\n   */\r\n  selectFunction(props: IStudioMetaChatFunctionCall.ISelect): Promise<void>;\r\n\r\n  /**\r\n   * Fill in the argument of the function call.\r\n   * \r\n   * A function called by the Meta LLM server when the user needs to fill in \r\n   * some of the argument for the LLM function call. For example, when the user\r\n   * needs to enter an authentication key for a Google account, or upload a file\r\n   * manually.\r\n   * \r\n   * `IStudioMetaFunctionCall.arguments` is a function called when the user needs\r\n   * to compose some (or all) of the arguments to be used in the function call\r\n   * directly. The returned value means the value that the client has composed.\r\n   * \r\n   * The only cases where the client receives input separately from the server\r\n   * in our service are as follows:\r\n   *\r\n   * - {@link IOpenAiSchema.IString[\"x-wrtn-secret-key\"]}\r\n   * - {@link IOpenAiSchema.IString.contentMediaType}\r\n   *\r\n   * @param props Information of the target function and argument types\r\n   * @returns The value composed by the client, or rejection by hin/her\r\n   */\r\n  fillArgument(\r\n    props: IStudioMetaChatFunctionCall.IFillArgument,\r\n  ): Promise<IStudioMetaChatListener.IFillArgumentResult>;\r\n\r\n  /**\r\n   * Complete the function call.\r\n   * \r\n   * A function called by the Meta LLM server to inform the client of the \r\n   * completion of the LLM function call execution. \r\n   * \r\n   * It embodies the `Try<T, E>` structure, so that contains whether the function call \r\n   * was successful or not. Also, it contains the return value when suceeded, and the\r\n   * exception information when failed.\r\n   *\r\n   * @param props Information of the execution result\r\n   */\r\n  completeFunction(props: IStudioMetaChatFunctionCall.IComplete): Promise<void>;\r\n\r\n  /**\r\n   * Workflow has been prepared.\r\n   * \r\n   * A function called by the Meta LLM server when the workflow creation is ready.\r\n   * Client can decide whether to save the {@link IStudioWorkflow workflow document} \r\n   * based on the {@link IStudioWorkflowData.ICreate creation information} received \r\n   * from the server.\r\n   * \r\n   * If client returns a {@link IStudioMetaChatWorkflowConfirm} instance in this \r\n   * function, the server will create the workflow at the specified \r\n   * {@link IStudioRepository repository} location. Otherwise the client returns\r\n   * `null`, the server will not create the workflow.\r\n   *\r\n   * @param data Workflow creation information\r\n   * @param plan Workflow configuration plan including detailed descriptions\r\n   * @returns Whether to create the workflow document or not\r\n   */\r\n  prepareWorkflow(\r\n    data: IStudioWorkflowData.ICreate,\r\n    plan: IStudioMetaChatWorkflowPlan,\r\n  ): Promise<IStudioMetaChatWorkflowConfirm | null>;\r\n\r\n  /**\r\n   * Workflow has been created/updated.\r\n   * \r\n   * A function called by the Meta LLM server when an {@link IStudioWorkflow workflow}\r\n   * has been newly created or updated by the client had returned a non-null value from\r\n   * the {@link prepareWorkflow} function.\r\n   * \r\n   * Whether the server creates or updates the workflow depends on the return value of\r\n   * the {@link prepareWorkflow} function. If the client orders a new workflow document,\r\n   * it would be created by the server. Otherwise the client directed the existing\r\n   * workflow document, it would be updated.\r\n   * \r\n   * The provided parameter object is the detailed information of the workflow\r\n   * {@link IStudioWorkflow} and its location information with {@link IStudioRepository}, \r\n   * so that the client can check it and enter the workflow editor or provide \r\n   * a preview image.\r\n   *\r\n   * @param workflow Newly created or updated workflow\r\n   * @param related Account and repository information related to the workflow\r\n   */\r\n  completeWorkflow(\r\n    workflow: IStudioWorkflow,\r\n    related: Pick<IStudioMetaChatWorkflowConfirm, \"account\" | \"repository\">,\r\n  ): Promise<void>;\r\n\r\n  /**\r\n   * Meta LLM server requests the client to terminate.\r\n   * \r\n   * When the Meta LLM session suddenly died due to the bug from LLM \r\n   * (Large Language Model) like OpenAI, the server requests the client to terminate \r\n   * the connection, and retry it again a little bit later.\r\n   *\r\n   * @param error Error from the LLM module\r\n   */\r\n  kill(error?: any): Promise<void>;\r\n}\nProvider from client to server for chatting.\"Meta LLM\" client is providing an IStudioMetaChatListener typed instance to the server.It provides many listener methods for the server for interaction. At first, it providers talk() and listenable() methods. The talk() method is designed to listen what the LLM server is saying, and the listenable() method informs the client to whether the server is ready to listen client's talk or not. If server has delivered false value to the listenable() method, the client must not call the talk() method until the server delivers true value to the listenable() method.When user writes a chatting text, so that client remotely calls IStudioMetaChatService.talk() method, LLM (Large Language Model) analyzes the chatting text. Sometimes, the LLM predicates the chatting text indicates the LLM function call. In that case, LLM server starts the function call execution process by calling the explainFunctionCall() method remotely. In the process, server fills the LLM side parameters by user's chatting text, and fill Human side parameters by calling fillArgument() method.At last, if client request to create a reusable program function about the chatting by text input delivered by remotely calling IStudioMetaChatService.talk() method, LLM server composes the Workflow document with SWL language, and delivers it to the client by calling the prepareWorkflow() function remotely. If client returns the IStudioMetaChatWorkflowConfirm instance, LLM server actually creates the Workflow document at the specified repository location, and then delivers the created Workflow document to the completeWorkflow() method.","parameter-structures#Parameter Structures":"","dialogue#Dialogue":"/**\r\n * Conversion in the Meta LLM chat.\r\n * \r\n * `IStudioMetaChatDialogue` is a union type that represents the \r\n * conversation information occured in the Meta LLM (A.I. chatbot).\r\n * \r\n * Currently, only text conversation type exists, but in the future, it \r\n * may be possible to add voice, image, or composite types. It's because \r\n * OpenAI GPT-4o model has started supporting the voice input.\r\n */\r\nexport type IStudioMetaChatDialogue = IStudioMetaChatDialogue.IText;\r\nexport namespace IStudioMetaChatDialogue {\r\n  /**\r\n   * Text conversation information.\r\n   */\r\n  export interface IText {\r\n    /**\r\n     * Discriminator of union type.\r\n     */\r\n    kind: \"text\";\r\n\r\n    /**\r\n     * The text input by Human or LLM.\r\n     */\r\n    text: string;\r\n  }\r\n}\nChat dialogue information.When Human or LLM sends chatting text to the other, client or server remotely call the IStudioMetaChatListener.talk() or IStudioMetaChatService.talk() method, and their sole parameter type is IStudioMetaChatDialogue of above.","functioncallplan#FunctionCallPlan":"/**\r\n * Explanation of the function call plan.\r\n * \r\n * `IStudioMetaChatFunctionCallPlan` is an interface that describes the plan\r\n * of function calls in the Meta LLM chat session when the server explains the\r\n * plan to the client. \r\n * \r\n * It contains the list of functions to be called, the overall/development-level \r\n * description of the plan, and the description list for each function call.\r\n * \r\n * In the RPC (Remote Procedure Call) context, this structure \r\n * `IStudioMetaChatFunctionCallPlan` is used in the\r\n * {@link IStudioMetaChatListener.explainFunctionCall} method. After the method be\r\n * called, each function in the plan would be excuted by below sequence:\r\n * \r\n * 1. {@link IStudioMetaChatListener.selectFunction} to inform function metadata\r\n * 2. {@link IStudioMetaChatListener.fillArgument} per each argument of Human side\r\n * 3. {@link IStudioMetaChatListener.completeFunction} after function call execution\r\n */\r\nexport interface IStudioMetaChatFunctionCallPlan {\r\n  /**\r\n   * List of functions to call.\r\n   * \r\n   * Do not provide all metadata of the functions, but only identifier \r\n   * ({@link method} and {@link path}) of the function, and its {@link summary} and \r\n   * {@link descriptions}.\r\n   */\r\n  functions: IStudioMetaChatFunctionCallPlan.IFunction[];\r\n\r\n  /**\r\n   * General description of the entire plan.\r\n   */\r\n  general: string;\r\n\r\n  /**\r\n   * Individual description list for each function call.\r\n   */\r\n  steps: string[];\r\n}\r\nexport namespace IStudioMetaChatFunctionCallPlan {\r\n  export interface IFunction {\r\n    method: \"get\" | \"post\" | \"patch\" | \"put\" | \"delete\";\r\n    path: string;\r\n    summary?: string;\r\n    description?: string;\r\n    icon?: string & tags.Format<\"uri\">;\r\n  }\r\n}\nDescription of the function call plan.IStudioMetaChatFunctionCallPlan is an interface that describes the plan of function calls in the Meta LLM chat session when the server explains the plan to the client. It contains the list of functions to be called, the overall/development-level description of the plan, and the description list for each function call.In the RPC (Remote Procedure Call) context, this structure IStudioMetaChatFunctionCallPlan is used in the IStudioMetaChatListener.explainFunctionCall() method. After the method be called, each function in the plan would be excuted by below sequence:\nIStudioMetaChatListener.selectFunction() to inform function metadata\nIStudioMetaChatListener.fillArgument() per each argument of Human side\nIStudioMetaChatListener.completeFunction() after function call execution","functioncall#FunctionCall":"import { IOpenAiFunction, IOpenAiSchema } from \"@wrtnio/openai-function-schema\";\r\nimport { Primitive, tags } from \"typia\";\r\nimport { OmitNever } from \"typia/lib/typings/OmitNever\";\r\n\r\nexport namespace IStudioMetaChatFunctionCall {\r\n  /**\r\n   * Selection information of the function to call.\r\n   * \r\n   * `IStudioMetaChatFunctionCall.ISelect` is an interface that providing metadata\r\n   * of the target function to call when the Meta LLM server selects a proper function \r\n   * to call during the conversation with the user.\r\n   * \r\n   * In the context of RPC (Remote Procedure Call), this `IStudioMetaChatFunctionCall`\r\n   * structure is used in the {@link IStudioMetaChatListener.selectFunction} method.\r\n   * Also after delivering this information. the server will step below sequence:\r\n   * \r\n   * 1. {@link IStudioMetaChatListener.fillArgument} to compose Human side parameters\r\n   * 2. {@link IStudioMetaChatListener.completeFunction} after function call execution\r\n   */\r\n  export interface ISelect {\r\n    /**\r\n     * Primary Key.\r\n     */\r\n    id: string & tags.Format<\"uuid\">;\r\n\r\n    /**\r\n     * Metadata of the target function to call.\r\n     */\r\n    function: OmitNever<Primitive<IOpenAiFunction>>;\r\n  }\r\n\r\n  /**\r\n   * Request of arguments filling of Human side parameter.\r\n   * \r\n   * `IStudioMetaChatFunctionCall.IFillArgument` is an interface that providing\r\n   * the request to client for composing some of the arguments of the target\r\n   * function that must be filled by Human side, intead of LLM (Large Language Model).\r\n   * \r\n   * As a case of the values that must be filled by Human side, there are secret key\r\n   * and file upload. In the context of {@link IOpenAiSchema}, those typed values\r\n   * must be filled by Human:\r\n   * \r\n   * - {@link IOpenAiSchema.IString[\"x-wrtn-secret-key\"]}\r\n   * - {@link IOpenAiSchema.IString.contentMediaType}\r\n   */\r\n  export interface IFillArgument {\r\n    /**\r\n     * Identifier of the target function.\r\n     * \r\n     * It is same with the {@link IStudioMetaChatFunctionCall.ISelect.id}.\r\n     */\r\n    id: string & tags.Format<\"uuid\">;\r\n\r\n    /**\r\n     * Index of the parameter to fill.\r\n     */\r\n    index: number & tags.Type<\"uint32\">;\r\n\r\n    /**\r\n     * Schema information that must be composed by Human.\r\n     */\r\n    schema: IOpenAiSchema;\r\n\r\n    /**\r\n     * Metadata of the parameter that can be filled by LLM.\r\n     * \r\n     * If this value is `null`, it means that the parameter must be filled only by \r\n     * Human. Otherwise, LLM (Large Language Model) also can fill the parameter value\r\n     * by analyzing the client's conversation, and Meta LLM merges it with the \r\n     * Human composed.\r\n     */\r\n    llm: null | {\r\n      /**\r\n       * SChema information that can be filled by LLM.\r\n       */\r\n      schema: IOpenAiSchema;\r\n\r\n      /**\r\n       * Actual value filled by LLM.\r\n       */\r\n      value: any;\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Result of the function call execution.\r\n   * \r\n   * `IStudioMetaChatFunctionCall.IComplete` is an interface that providing the\r\n   * result of the function call execution.\r\n   * \r\n   * In the RPC (Remote Procedure Call) context, this `IStudioMetaChatFunctionCall`\r\n   * structure is used in the {@link IStudioMetaChatListener.completeFunction} method.\r\n   */\r\n  export interface IComplete {\r\n    /**\r\n     * Primary Key.\r\n     * \r\n     * It is same with the {@link IStudioMetaChatFunctionCall.ISelect.id}.\r\n     */\r\n    id: string & tags.Format<\"uuid\">;\r\n\r\n    /**\r\n     * Arguments list used in the function call.\r\n     */\r\n    arguments: any[];\r\n\r\n    /**\r\n     * Whether the function call was successful or not.\r\n     */\r\n    success: boolean;\r\n\r\n    /**\r\n     * Returned value as a result of the function call.\r\n     * \r\n     * If the function call has been failed, this value would be exception instance \r\n     * thrown by the target function.\r\n     */\r\n    value: any;\r\n\r\n    /**\r\n     * Time of the function call start.\r\n     */\r\n    created_at: string & tags.Format<\"date-time\">;\r\n\r\n    /**\r\n     * Time of the function call completion.\r\n     * \r\n     * If this value is `null`, it means that the connection to the target function\r\n     * (API operation) itself has failed. On the other hand, if the connection has been\r\n     * succeeded but exception has been thrown during the function call, this time\r\n     * would be the time when the exception has been thrown.\r\n     */\r\n    completed_at: null | (string & tags.Format<\"date-time\">);\r\n\r\n    /**\r\n     * Status of the response.\r\n     * \r\n     * The HTTP protocol response status if the connection has been succeeded.\r\n     * Otherwise the connection has been failed, this value would be `null`.\r\n     */\r\n    status: number | null;\r\n  }\r\n}\nStructure for function call execution.After the Meta LLM server has explained the function call plan to the client by remotely calling the IStudioMetaChatListener.explainFunctionCall() method with IStudioMetaChatFunctionCallPlan typed parameter, the Meta LLM server steps the function call execution process by calling below methods.\nIStudioMetaChatListener.selectFunction() to inform function metadata\nIStudioMetaChatListener.fillArgument() per each argument of Human side\nIStudioMetaChatListener.completeFunction() after function call execution\nAt first, IStudioMetaChatFunctionCall.ISelect is an interface that providing metadata of the target function to call with IStudioMetaChatListener.selectFunction() method, when the Meta LLM server selects a proper function to call during the conversation with the user.At next, IStudioMetaChatFunctionCall.IFillArgument is an interface that providing the request to client for composing some of the arguments of the target function that must be filled by Human side, intead of LLM (Large Language Model), by IStudioMetaChatListener.selectFunction() method. As a case of the values that must be filled by Human side, there are secret key and file uploading.At last. IStudioMetaChatFunctionCall.IComplete is an interface that providing the result of the function call execution by IStudioMetaChatListener.completeFunction() method. It contains the argument values used for function call execution, and the result value from target function. If the function call has been failed, the result value would be exception instance thrown by the target function.","workflowplan#WorkflowPlan":"/**\r\n * Description of workflow composition plan.\r\n * \r\n * `IStudioMetaChatWorkflowPlan` is an interface that describes the plan of\r\n * the workflow composition in the Meta LLM chat session. The server explains\r\n * how to compose the workflow document in the general level, and also provides\r\n * the detailed description of each step.\r\n * \r\n * In the RPC (Remote Procedure Call) context, this structure \r\n * `IStudioMetaChatWorkflowPlan` is used in the \r\n * `IStudioMetaChatListener.prepareWorkflow` function, and the client determines\r\n * whether to actually build the workflow document or not based on this plan.\r\n */\r\nexport interface IStudioMetaChatWorkflowPlan {\r\n  /**\r\n   * General description of the entire plan.\r\n   */\r\n  general: string;\r\n\r\n  /**\r\n   * Detailed description list for each step.\r\n   */\r\n  steps: string[];\r\n\r\n  /**\r\n   * Title of the workflow.\r\n   */\r\n  title: string;\r\n\r\n  /**\r\n   * Summary of the workflow.\r\n   * \r\n   * This `summary` is different with the {@link general} description. The \r\n   * {@link general} description is the overall description of the entire plan,\r\n   * and this `summary` would be written in the workflow document when it compiled\r\n   * to a resuable program function.\r\n   * \r\n   * In other words, this `summary` would be assigned to \r\n   * {@link OpenApi.IOperation.summary} in the API level, and written on the \r\n   * programming comment in the source code level.\r\n   */\r\n  summary: string;\r\n\r\n  /**\r\n   * Description of the workflow.\r\n   * \r\n   * This `description` is different with the {@link general} description. The\r\n   * {@link general} description is the overall description of the entire plan,\r\n   * and this `description` would be written in the workflow document when it \r\n   * compiled to a resuable program function.\r\n   * \r\n   * In other words, this `description` would be assigned to \r\n   * {@link OpenApi.IOperation.description} in the API level, and written on the\r\n   * programming comment in the source code level.\r\n   */\r\n  description: string;\r\n}\nDescription of the workflow composition plan.When user requests to create a reusable program function from a chatting session, Meta LLM collects entire function call histories, and introduces the workflow composition plan before the actual workflow document creation. IStudioMetaChatWorkflowPlan is the interface providing the workflow composition plan with IStudoMetaCatListener.prepareWorkflow() method.In the IStudoMetaCatListener.prepareWorkflow() method, if client accepts the workflow composition plan and returns somewhere place to save the workflow document, the server actually creates the workflow document bypass SWL language, and delivers the created workflow document to the IStudioMetaChatListener.completeWorkflow() method.","workflowconfirm#WorkflowConfirm":"/**\r\n * Confirmation of the workflow creation.\r\n * \r\n * `IStudioMetaChatWorkflowConfirm` is an interface that accepting the \r\n * workflow creation with location to save the workflow document\r\n * including target {@link IStudioAccount account}, \r\n * {@link IStudioRepository repository}, {@link IStudioRepositoryCommit commit} \r\n * and {@link IStudioWorkflow.path path} information.\r\n * \r\n * In the RPC (Remote Procedure Call) context, this structure\r\n * `IStudioMetaChatWorkflowConfirm` is used in the \r\n * {@link IStudioMetaChatListener.prepareWorkflow} function, and the client\r\n * returns this typed instance acceptinng the workflow creation\r\n */\r\nexport interface IStudioMetaChatWorkflowConfirm {\r\n  /**\r\n   * Belonged account's {@link IStudioAccount.code}.\r\n   */\r\n  account: string;\r\n\r\n  /**\r\n   * Belonged repository's {@link IStudioRepository.code}.\r\n   */\r\n  repository: string;\r\n\r\n  /**\r\n   * Target commit.\r\n   * \r\n   * Create a new commit or update to an existing commit.\r\n   */\r\n  commit:\r\n    | IStudioMetaChatWorkflowConfirm.ICommitCreate\r\n    | IStudioMetaChatWorkflowConfirm.ICommitUpdate;\r\n\r\n  /**\r\n   * Workflow to create.\r\n   * \r\n   * Information of workflow where to save, including path and file name.\r\n   */\r\n  workflow: Omit<\r\n    IStudioWorkflow.ICreate,\r\n    \"data\" | \"title\" | \"summary\" | \"description\"\r\n  >;\r\n}\r\nexport namespace IStudioMetaChatWorkflowConfirm {\r\n  /**\r\n   * Create new commit.\r\n   */\r\n  export interface ICommitCreate\r\n    extends Omit<\r\n      IStudioRepositoryCommit.ICreate,\r\n      \"creates\" | \"updates\" | \"erases\"\r\n    > {\r\n    /**\r\n     * Discriminator of union type.\r\n     */\r\n    kind: \"create\";\r\n  }\r\n\r\n  /**\r\n   * Update to existing commit.\r\n   */\r\n  export interface ICommitUpdate\r\n    extends Omit<\r\n      IStudioRepositoryCommit.IUpdate,\r\n      \"creates\" | \"updates\" | \"erases\"\r\n    > {\r\n    /**\r\n     * Discriminator of union type.\r\n     */\r\n    kind: \"update\";\r\n\r\n    /**\r\n     * Target commit's {@link IStudioRepositoryCommit.id}.\r\n     */\r\n    commit_id: \"latest\" | (string & tags.Format<\"uuid\">);\r\n  }\r\n}\nConfirmation of workflow document creation.When Meta LLM server explains the workflow composition plan to the client by remotely calling IStudioMetaChatListener.prepareWorkflow() method, the client can decide whether to actually build the workflow document or not based on the plan. If client returns IStudioMetaChatWorkflowConfirm typed instance in the method, the server actually builds the workflow document through SWL language, and inform the completion by calling IStudioMetaChatListener.completeWorkflow() method.IStudioMetaChatWorkflowConfirm is such an interface that accepting the workflow creation. The IStudioMetaChatWorkflowConfirm contains somewhere location to save the workflow document including target account, repository, commit and file path.","function-call-execution#Function Call Execution":"/**\r\n * Set of functions provided by the Meta LLM server to the client.\r\n * \r\n * `IStudioMetaChatService` is an interface that defines the set of functions\r\n * provided by the **server** to the Meta LLM (Large Language Model) client. The Meta \r\n * LLM client remotely calls the server's `IStudioMetaChatService` functions through \r\n * this interface with RPC (Remote Procedure Call) paradigm.\r\n * \r\n * Note that the client must call the {@link initialize} function immediately\r\n * after connecting to the Meta LLM server. If the client tries to skip the\r\n * {@link initialize} function call and directly call {@link talk}, the function\r\n * call will fail, so that exception would be thrown.\r\n */\r\nexport interface IStudioMetaChatService {\r\n  /**\r\n   * Publish/restore/initialize the chat session.\r\n   * \r\n   * The client must call this function once after connecting to the Meta LLM\r\n   * server to publish a new chat session or restore an existing session. If\r\n   * the client tries to skip the {@link initialize} function call and directly\r\n   * call {@link talk}, the function call will fail, so that exception would be\r\n   * thrown.\r\n   * \r\n   * Also, the returned session would be a new chat session if the client connected\r\n   * to the server via the new chat session API, and the existing session would be\r\n   * restored if the client connected to the server via the continue chat session\r\n   * API.\r\n   *\r\n   * - {@link HubApi.functional.studio.customers.meta.chat.sessions.start}\r\n   * - {@link HubApi.functional.studio.customers.meta.chat.sessions.restart}\r\n   */\r\n  initialize(): Promise<IStudioMetaChatSession>;\r\n\r\n  /**\r\n   * User talks to Meta LLM.\r\n   * \r\n   * A function called by the client to talk to the Meta LLM server.\r\n   * \r\n   * @param dialogue Dialogue information\r\n   */\r\n  talk(dialogue: IStudioMetaChatDialogue): Promise<void>;\r\n}\n/**\r\n * Set of functions provided by the Meta LLM client to the server.\r\n * \r\n * `IStudioMetaChatListener` is an interface that defines the set of functions\r\n * provided by the **client** to the Meta LLM (Large Language Model) server. The Meta \r\n * LLM server remotely calls the client's `IStudioMetaChatListener` functions through\r\n * this interface with RPC (Remote Procedure Call) paradigm.\r\n */\r\nexport interface IStudioMetaChatListener {\r\n  /**\r\n   * Meta LLM server talks to the user.\r\n   * \r\n   * A function called by the Meta LLM server to talk to the user.\r\n   *\r\n   * @param dialogue Dialogue information\r\n   */\r\n  talk(dialogue: IStudioMetaChatDialogue): Promise<void>;\r\n\r\n  /**\r\n   * Notify the client of the server's listenability.\r\n   * \r\n   * The Meta LLM server notifies the client whether it is possible to listen.\r\n   *  \r\n   * In other words, this function informs the client whether it can call\r\n   * {@link IStudioMetaChatService.talk} immediately or not.\r\n   * \r\n   * Note that when the client calls the server's RPC function\r\n   * {@link IStudioMetaChatService.talk}, the value `false` is passed to this\r\n   * function {@link IStudioMetaChatListener.listenable} immediately. On the\r\n   * other hand, the value `true` is passed to this function in various cases.\r\n   *\r\n   * @param status Listenability status\r\n   */\r\n  listenable(status: boolean): Promise<void>;\r\n\r\n  /**\r\n   * Explain the function call plan.\r\n   * \r\n   * The Meta LLM server explains the function call plan to the user.\r\n   * \r\n   * The function call plan provided includes a list of functions that LLM\r\n   * wants to execute in order, and a description of the entire plan and the\r\n   * purpose of each function call.\r\n   * \r\n   * The client can read this and decide whether to proceed with the LLM\r\n   * function call execution. If `true` is returned, the Meta LLM will call\r\n   * the functions according to the plan. Otherwise `false` be returned, the plan\r\n   * would be withdrawn.\r\n   * \r\n   * @param plan Function call plan\r\n   * @returns Whether to proceed with the plan or not\r\n   */\r\n  explainFunctionCall(plan: IStudioMetaChatFunctionCallPlan): Promise<boolean>;\r\n\r\n  /**\r\n   * Select a function to call.\r\n   * \r\n   * A function called by the Meta LLM server when LLM (Large Language Model) has\r\n   * determined the target function to call during the conversation with the user.\r\n   * \r\n   * After this function be called, the server will call the {@link fillArguments} \r\n   * functionns remotely to commpose parameter values, and then call the \r\n   * {@link completeFunction} function after the function call execution.\r\n   *\r\n   * @param props Information of the target function\r\n   */\r\n  selectFunction(props: IStudioMetaChatFunctionCall.ISelect): Promise<void>;\r\n\r\n  /**\r\n   * Fill in the argument of the function call.\r\n   * \r\n   * A function called by the Meta LLM server when the user needs to fill in \r\n   * some of the argument for the LLM function call. For example, when the user\r\n   * needs to enter an authentication key for a Google account, or upload a file\r\n   * manually.\r\n   * \r\n   * `IStudioMetaFunctionCall.arguments` is a function called when the user needs\r\n   * to compose some (or all) of the arguments to be used in the function call\r\n   * directly. The returned value means the value that the client has composed.\r\n   * \r\n   * The only cases where the client receives input separately from the server\r\n   * in our service are as follows:\r\n   *\r\n   * - {@link IOpenAiSchema.IString[\"x-wrtn-secret-key\"]}\r\n   * - {@link IOpenAiSchema.IString.contentMediaType}\r\n   *\r\n   * @param props Information of the target function and argument types\r\n   * @returns The value composed by the client, or rejection by hin/her\r\n   */\r\n  fillArgument(\r\n    props: IStudioMetaChatFunctionCall.IFillArgument,\r\n  ): Promise<IStudioMetaChatListener.IFillArgumentResult>;\r\n\r\n  /**\r\n   * Complete the function call.\r\n   * \r\n   * A function called by the Meta LLM server to inform the client of the \r\n   * completion of the LLM function call execution. \r\n   * \r\n   * It embodies the `Try<T, E>` structure, so that contains whether the function call \r\n   * was successful or not. Also, it contains the return value when suceeded, and the\r\n   * exception information when failed.\r\n   *\r\n   * @param props Information of the execution result\r\n   */\r\n  completeFunction(props: IStudioMetaChatFunctionCall.IComplete): Promise<void>;\r\n\r\n  /**\r\n   * Workflow has been prepared.\r\n   * \r\n   * A function called by the Meta LLM server when the workflow creation is ready.\r\n   * Client can decide whether to save the {@link IStudioWorkflow workflow document} \r\n   * based on the {@link IStudioWorkflowData.ICreate creation information} received \r\n   * from the server.\r\n   * \r\n   * If client returns a {@link IStudioMetaChatWorkflowConfirm} instance in this \r\n   * function, the server will create the workflow at the specified \r\n   * {@link IStudioRepository repository} location. Otherwise the client returns\r\n   * `null`, the server will not create the workflow.\r\n   *\r\n   * @param data Workflow creation information\r\n   * @param plan Workflow configuration plan including detailed descriptions\r\n   * @returns Whether to create the workflow document or not\r\n   */\r\n  prepareWorkflow(\r\n    data: IStudioWorkflowData.ICreate,\r\n    plan: IStudioMetaChatWorkflowPlan,\r\n  ): Promise<IStudioMetaChatWorkflowConfirm | null>;\r\n\r\n  /**\r\n   * Workflow has been created/updated.\r\n   * \r\n   * A function called by the Meta LLM server when an {@link IStudioWorkflow workflow}\r\n   * has been newly created or updated by the client had returned a non-null value from\r\n   * the {@link prepareWorkflow} function.\r\n   * \r\n   * Whether the server creates or updates the workflow depends on the return value of\r\n   * the {@link prepareWorkflow} function. If the client orders a new workflow document,\r\n   * it would be created by the server. Otherwise the client directed the existing\r\n   * workflow document, it would be updated.\r\n   * \r\n   * The provided parameter object is the detailed information of the workflow\r\n   * {@link IStudioWorkflow} and its location information with {@link IStudioRepository}, \r\n   * so that the client can check it and enter the workflow editor or provide \r\n   * a preview image.\r\n   *\r\n   * @param workflow Newly created or updated workflow\r\n   * @param related Account and repository information related to the workflow\r\n   */\r\n  completeWorkflow(\r\n    workflow: IStudioWorkflow,\r\n    related: Pick<IStudioMetaChatWorkflowConfirm, \"account\" | \"repository\">,\r\n  ): Promise<void>;\r\n\r\n  /**\r\n   * Meta LLM server requests the client to terminate.\r\n   * \r\n   * When the Meta LLM session suddenly died due to the bug from LLM \r\n   * (Large Language Model) like OpenAI, the server requests the client to terminate \r\n   * the connection, and retry it again a little bit later.\r\n   *\r\n   * @param error Error from the LLM module\r\n   */\r\n  kill(error?: any): Promise<void>;\r\n}\nimport { IOpenAiFunction, IOpenAiSchema } from \"@wrtnio/openai-function-schema\";\r\nimport { Primitive, tags } from \"typia\";\r\nimport { OmitNever } from \"typia/lib/typings/OmitNever\";\r\n\r\nexport namespace IStudioMetaChatFunctionCall {\r\n  /**\r\n   * Selection information of the function to call.\r\n   * \r\n   * `IStudioMetaChatFunctionCall.ISelect` is an interface that providing metadata\r\n   * of the target function to call when the Meta LLM server selects a proper function \r\n   * to call during the conversation with the user.\r\n   * \r\n   * In the context of RPC (Remote Procedure Call), this `IStudioMetaChatFunctionCall`\r\n   * structure is used in the {@link IStudioMetaChatListener.selectFunction} method.\r\n   * Also after delivering this information. the server will step below sequence:\r\n   * \r\n   * 1. {@link IStudioMetaChatListener.fillArgument} to compose Human side parameters\r\n   * 2. {@link IStudioMetaChatListener.completeFunction} after function call execution\r\n   */\r\n  export interface ISelect {\r\n    /**\r\n     * Primary Key.\r\n     */\r\n    id: string & tags.Format<\"uuid\">;\r\n\r\n    /**\r\n     * Metadata of the target function to call.\r\n     */\r\n    function: OmitNever<Primitive<IOpenAiFunction>>;\r\n  }\r\n\r\n  /**\r\n   * Request of arguments filling of Human side parameter.\r\n   * \r\n   * `IStudioMetaChatFunctionCall.IFillArgument` is an interface that providing\r\n   * the request to client for composing some of the arguments of the target\r\n   * function that must be filled by Human side, intead of LLM (Large Language Model).\r\n   * \r\n   * As a case of the values that must be filled by Human side, there are secret key\r\n   * and file upload. In the context of {@link IOpenAiSchema}, those typed values\r\n   * must be filled by Human:\r\n   * \r\n   * - {@link IOpenAiSchema.IString[\"x-wrtn-secret-key\"]}\r\n   * - {@link IOpenAiSchema.IString.contentMediaType}\r\n   */\r\n  export interface IFillArgument {\r\n    /**\r\n     * Identifier of the target function.\r\n     * \r\n     * It is same with the {@link IStudioMetaChatFunctionCall.ISelect.id}.\r\n     */\r\n    id: string & tags.Format<\"uuid\">;\r\n\r\n    /**\r\n     * Index of the parameter to fill.\r\n     */\r\n    index: number & tags.Type<\"uint32\">;\r\n\r\n    /**\r\n     * Schema information that must be composed by Human.\r\n     */\r\n    schema: IOpenAiSchema;\r\n\r\n    /**\r\n     * Metadata of the parameter that can be filled by LLM.\r\n     * \r\n     * If this value is `null`, it means that the parameter must be filled only by \r\n     * Human. Otherwise, LLM (Large Language Model) also can fill the parameter value\r\n     * by analyzing the client's conversation, and Meta LLM merges it with the \r\n     * Human composed.\r\n     */\r\n    llm: null | {\r\n      /**\r\n       * SChema information that can be filled by LLM.\r\n       */\r\n      schema: IOpenAiSchema;\r\n\r\n      /**\r\n       * Actual value filled by LLM.\r\n       */\r\n      value: any;\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Result of the function call execution.\r\n   * \r\n   * `IStudioMetaChatFunctionCall.IComplete` is an interface that providing the\r\n   * result of the function call execution.\r\n   * \r\n   * In the RPC (Remote Procedure Call) context, this `IStudioMetaChatFunctionCall`\r\n   * structure is used in the {@link IStudioMetaChatListener.completeFunction} method.\r\n   */\r\n  export interface IComplete {\r\n    /**\r\n     * Primary Key.\r\n     * \r\n     * It is same with the {@link IStudioMetaChatFunctionCall.ISelect.id}.\r\n     */\r\n    id: string & tags.Format<\"uuid\">;\r\n\r\n    /**\r\n     * Arguments list used in the function call.\r\n     */\r\n    arguments: any[];\r\n\r\n    /**\r\n     * Whether the function call was successful or not.\r\n     */\r\n    success: boolean;\r\n\r\n    /**\r\n     * Returned value as a result of the function call.\r\n     * \r\n     * If the function call has been failed, this value would be exception instance \r\n     * thrown by the target function.\r\n     */\r\n    value: any;\r\n\r\n    /**\r\n     * Time of the function call start.\r\n     */\r\n    created_at: string & tags.Format<\"date-time\">;\r\n\r\n    /**\r\n     * Time of the function call completion.\r\n     * \r\n     * If this value is `null`, it means that the connection to the target function\r\n     * (API operation) itself has failed. On the other hand, if the connection has been\r\n     * succeeded but exception has been thrown during the function call, this time\r\n     * would be the time when the exception has been thrown.\r\n     */\r\n    completed_at: null | (string & tags.Format<\"date-time\">);\r\n\r\n    /**\r\n     * Status of the response.\r\n     * \r\n     * The HTTP protocol response status if the connection has been succeeded.\r\n     * Otherwise the connection has been failed, this value would be `null`.\r\n     */\r\n    status: number | null;\r\n  }\r\n}\nLLM function call execution with RPC paradigm.Until now, we have learned principle of RPC (Remote Procedure Call), and how Meta LLM (A.I. chatbot) is utilizing the paradigm with detailed structures. Now, let's see how the LLM (Large Language Model) function call execution is being done with the RPC paradigm. Above sequence diagram would be helpful to understand the entire process.The Meta LLM starts by client's IStudioMetaChatService.initialize() remotely method calling, so that the chatting session be published (or restored). After that, the client may sends some conversation text to the server by calling IStudioMetaChatService.talk() method. This is the start of every function call execution step.When Meta LLM server listens the client's chatting text, it analyzes the text and predicts whether the conversation indicates a function call or not. If the conversation is suspicious to requesting some action, Meta LLM server finds proper functions to call. If suceeded to find some functions which can accomplish the user's request, Meta LLM makes a function call execution plan, and explains the plan to the client by calling IStudioMetaChatListener.explainFunctionCall() method. If client accepts the plan, so that returns tue value in the method, the Meta LLM server starts the function call execution process.For each functions to call, at first, Meta LLM server delivers the metadata information of the target function to call to the client by calling IStudioMetaChatListener.selectFunction() method. Also, Meta LLM server requests the client to fill parameter arguments. Such request and response would be done by chatting text through IStudioMetaChatService.talk() and IStudioMetaChatListener.talk() methods. Meta LLM analyzes user replied chatting text, and fill arguments of the target function by itself.By the way, some functions may have special arguments that only Human can compose. Secret key and file uploading cases would be such examples. In that case, Meta LLM requests client to fill the Human side arguments by calling IStudioMetaChatListener.fillArgument() method per each parameter argument. In the method, client manually composes the argument through Inspector component, and returns it. Meta LLM merges the Human composed argument with the LLM composed, and executes the function.After the function call execution, Meta LLM server informs the function call result by calling IStudioMetaChatListener.completeFunction() method. Parameter of the method (IStudioMetaChatFunctionCall.IComplete type) contains everything about the function call result, including whether to suceeded or not, and return value from the target function or thrown exception information. If the returned value is simple, Meta LLM server will describe the result as conversation text. Otherwise, client side Meta LLM application may provide a return value viewer to show the result."}}}